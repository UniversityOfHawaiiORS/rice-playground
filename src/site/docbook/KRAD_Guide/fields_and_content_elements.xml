<?xml version='1.0' encoding='UTF-8'?> 
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xml:id="fields_and_content_elements" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook"  version="5.0">    
    <title>Fields and Content Elements </title>
    <para>Throughout the next few chapters, we will be taking a detailed look at the component types and the individual components available out of 
        the box with KRAD. We will start small and work our way up to the entire view. By the end of this section, you will be armed with the 
        knowledge you can use to create a wide variety of rich web interfaces!</para>
    <para>In this chapter, we will look at the Content Element and Field component types. These form the palette from which we can paint our page. 
         Content elements are components that will generate an HTML element tag. Their properties are generally used to populate an available 
         attribute of the HMTL tag.  Therefore, if you are familiar with the base set of HTML tag learning these components should be no problem!</para>
    <para>The Field component type is a wrapper. It is associated with the HTML span tag that allows us to enclose one or more elements and treat 
        them as one unit for layout purposes. The field also allows us to declare a label which will be presented with the field block. For 
        convenience, KRAD includes field components that have present elements included. This allows for easily bundling in a group and applying a 
        layout to the set of fields. If a span is not needed, the elements can be directly configured in a group and rendered using the configured
        layout manager.</para>
    <para>So to learn more about what we can do with elements and fields, let’s take a look at each component we have in these types.
    </para>
    <section>
        <title>Field Labels </title>
        <para>One commonly used content element we have is the Label component. As you might have
            guessed, this component will render an HTML Label element. To create a new label
            component, we create a new bean with parent=”Uif-Label”:</para>
        <para>One commonly used content element we have is the Label component. As you might have
            guessed, this component will render an HTML Label element. To create a new label
            component, we create a new bean with parent=”Uif-Label”:</para>
        <programlisting>&lt;bean parent=”Uif-Label” ... &gt;</programlisting>
        <para>The label component is one of the simplest to use since there are few properties which
            it accepts. However, there is one required property – the label text! This is the actual
            text that will appear on the screen as the label. To specify this we can use the
            labelText property:</para>
        <programlisting>&lt;bean parent=”Uif-Label” p:labelText=”Book Title”/&gt;</programlisting>
        <para>In most cases, this is all we need to do! The resulting HTML will look like the
            following:</para>
        <programlisting>&lt;label id="66_label”&gt;Field Label&lt;/label&gt;</programlisting>
        <para>Wait, where did the id come from? Recall that all components extend ComponentBase
            which provides several properties for us, including the id property. If not specified,
            the framework will generate an id for us automatically and use for the element id
            attribute. We can specify a different in either of the following two ways:</para>
        <programlisting>&lt;bean id=”mylabel” parent=”Uif-Label” p:labelText=”Book Title”/&gt;</programlisting>
        <programlisting>&lt;bean parent=”Uif-Label” p:id=”mylabel” p:labelText=”Book Title”/&gt;</programlisting>
        <para>In addition to the id property provided by ComponentBase, there are many others we
            might want to use. Some that might be useful for the label component include title,
            style, and styleClasses.</para>
        <para>When generating a label, it is a best practice (for accessibility reasons) to also
            specify the for attribute. The value for this attribute is the id of the element for
            which the label applies. On the label component, we can configure this value using the
            labelForComponentId property:</para>
        <programlisting>&lt;bean parent=”Uif-Label” p:labelText=”Book Title” p:labelForComponentId=”bookTitle”/&gt;</programlisting>
        <para>However, this is usually not necessary. Instead of creating the label component
            directly, we can let the field component create one for us. The field component provides
            some assistance to us for configuring the label and associating it with a component. To
            understand this, first let’s look at the generic FieldBase class from which all fields
            extend:</para>
        <programlisting>
public class FieldBase extends ComponentBase implements Field {
    private Label fieldLabel;
} </programlisting>
        <para>We see the field base encapsulates a label component. Thus when creating a field
            component we can set the label component properties using the spring nested syntax (dot
            notation)</para>
        <programlisting>&lt;bean parent=”Uif-DataField” p:fieldLabel.labelText=”My Data Field” ... &gt;</programlisting>
        <para>We see the field base encapsulates a label component. Thus when creating a field
            component we can set the label component properties using the spring nested syntax (dot
            notation)</para>
        <programlisting>&lt;bean parent=”Uif-DataField” p:fieldLabel.labelText=”My Data Field” ... &gt;</programlisting>
        <para>Since the label is bundled within the field which is a wrapper for another component,
            the labelForComponentId property will be automatically set (to the id of that wrapped
            component).</para>
        <para>The Field component also provides a more convenient way of setting the label text.
            Instead of using the nested notation of ‘fieldLabel.labelText’, we can simply set the
            ‘label’ property:</para>
        <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” ... &gt;</programlisting>
        <para>The given value will then be set on the label property of the nested label
            component.</para>
        <section>
            <title>Other Label Options</title>
            <para>In addition to the properties described previously, the label component offers the
                following properties:</para>
            <para><emphasis role="bold">renderColon</emphasis> – This indicates whether a colon
                should be rendered after the label text. For example label text of ‘Foo’ will result
                in ‘Foo:’ being rendered.</para>
            <para><emphasis role="bold">requiredMessage</emphasis> – This is a message component
                that will be rendered with the label to indicate the element associated with the
                label (generally a control) is required. By default, the message text is configured
                to be ‘*’ but can be changed on a global or case by case basis:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:label.requiredMessage=”required”/&gt;</programlisting>
            <para>Like all components, the required message will be displayed if its render property
                is true. Therefore we can set the required message to not display as follows:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:label.requiredMessage.render=”false”/&gt;</programlisting>
            <para>However, we typically want to display the required message when the component the label is 
                associated with is required. This is again where our Field component provides value. The 
                field will look at the required property (on all components) of the wrapped component, 
                and if set to true will then set the render property to true for the label’s required message. 
                Likewise if the component’s required property is false, the render property on the required 
                message will be set to false. Therefore these two properties are synced.</para>
            <note>
                <title>Automatic Setting of Properties?</title>
                <para>In this section we have mentioned a few cases where the field component will
                    automatically set values for us based on a condition. Where does this happen?
                    Well in code of course! Besides simply holding the property values for us, the
                    component class can also perform logic which are invoked during the view
                    lifecycle. Therefore if we wanted to change the component behavior, we would
                    need to create a new class and then override the base bean definition as
                    described </para>
            </note>
            <para><emphasis role="bold">requiredMessagePlacement</emphasis> – Along with the
                required message the label component also provides a required message placement
                option. This indicates where the required message should be rendered in relation to
                the label text. The type for this property is
                org.kuali.rice.krad.uif.UifConstants.Position which is an enum for the four possible
                positions (LEFT, TOP, RIGHT, BOTTOM). However in the case of the required message,
                only the LEFT and RIGHT positions are supported.</para>
        </section>
        <section>
            <title>Other Field Label Options</title>
            <para>The field also provides some additional properties that related to the label.
                These are:</para>
            <para><emphasis role="bold">labelPlacement </emphasis>– Similar to the
                requiredMessagePlacement of the label component this property is of type Position.
                It indicates where the label should be placed in relation to the other field content
                (the wrapped component(s)). The LEFT, TOP, or RIGHT position may be
                specified:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:labelPlacement=”LEFT”/&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:labelPlacement=”TOP”/&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:labelPlacement=”RIGHT”/&gt;</programlisting>
            <para>These three configurations are shown in the figure below. </para>
            <figure>
                <title>labelPlacement Options</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/labelPlacement.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para><emphasis role="bold">shortLabel</emphasis> – On the field component we can also
                configure an alternate ‘short’ label. When necessary the short label can be pulled
                instead of the standard ‘long’ label. For example, the table layout manager in KRAD
                will use the short label for the table headers.</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:shortLabel=”My Fld”/&gt;</programlisting>
        </section>
        <section>
            <title>Base Beans</title>
            <para>With the various configuration options such as what to render and where, it can
                overwhelming. We certainly do not want to think through each setting for every field
                we create. To help with this, base beans are provided sensible defaults based on the
                label placement. These beans exist for the data field and input field (two most
                commonly used fields). </para>
            <para>Uif-DataField – Default which sets label placement to left, render colon as true,
                and required message placement to right</para>
            <para>Uif-DataField-LabelTop – Sets label placement as top, render colon as false, and
                required message placement to right</para>
            <para>Uif-DataField-LabelRight – Sets label placement to right, render colon as false,
                and required message placement to left</para>
            <para>Similar beans exist for the Uif-InputField. To use one of the label
                configurations, we simply change our parent bean:</para>
            <programlisting>&lt;bean parent=”Uif-DataField-LabelTop” p:labelText=”My Data Field” /&gt;</programlisting>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>The link content element component renders an html label tag</para>
                </listitem>
                <listitem>
                    <para>The text for the label is specified using the <emphasis role="bold"
                        >labelText</emphasis> property</para>
                </listitem>
                <listitem>
                    <para>The <emphasis role="bold">labelForComponentId</emphasis> property on label
                        specifies the component id the label is associated with</para>
                </listitem>
                <listitem>
                    <para>Generally we don’t need to create label components ourselves, but instead
                        configuring them through a field component</para>
                </listitem>
                <listitem>
                    <para>Labels can also include a required message that indicates the field
                        associated with the label is has required input</para>
                </listitem>
                <listitem>
                    <para>The field component will automatically set the for property on the label
                        for us along with setting the required message field component’s render flag
                        to true if the field is required</para>
                </listitem>
                <listitem>
                    <para>On the label component we can specify whether a colon should be added with
                        the <emphasis role="bold">renderColon</emphasis> Boolean</para>
                </listitem>
                <listitem>
                    <para>On the label component we can also specify whether the required message
                        appears to the left or right of the label using the <emphasis role="bold"
                            >requiredMessagePlacement</emphasis> property</para>
                </listitem>
                <listitem>
                    <para>The field component allows us to specify where the label is placed in
                        relation to the field contents. The options are left, top, or right</para>
                </listitem>
                <listitem>
                    <para>The field component allows us to specify a short label that can be used
                        instead of the ‘long’ label by some layout managers (for example the table
                        layout manager)</para>
                </listitem>
                <listitem>
                    <para>Base beans are provided for data and input fields that have different
                        configurations for label. The render colon and requirement message placement
                        properties are set based on the label placement</para>
                </listitem>
            </itemizedlist>
        </section>        
    </section>
    <section>
        <title>Data Fields and Input Fields </title>
        <para>Two fields that are used often in enterprise applications are the DataField and
            InputField. Generally enterprise applications have a large amount of data input and
            output. This IO is performed using an HTML Form. The properties that back the form
            (provide and accept the data) are stored on a model. For our purposes now, we can think
            of the model as a simple JavaBean (more information will be given in the section ‘Data
            Binding’. When we need to display one of these properties using KRAD we configure a
            DataField or InputField.</para>
        <section>
            <title>Data Field</title>
            <para>A Data Field is used to display a property value from the model as read-only. When
                we say read-only, this means the value is displayed as static text on the page and
                the user cannot changes its value. To create a data field we specify a new bean with
                parent=”Uif-DataField”:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” ... &gt;</programlisting>
            <para>When configuring a data field for our view, we must associate it with a property
                on the model object. This is accomplished using the propertyName property. For
                example, suppose we had the following model object:</para>
            <programlisting>
public class BookForm {
  private String bookId;
  private String bookTitle;
  // getters/setters
}
            </programlisting>
            <para>To create a data field for the bookId property, our configuration would be as
                follows:</para>
            <para>&lt;bean parent=”Uif-DataField” p:propertyName=”bookId” p:label=”Book”/&gt;</para>
            <para>the page. Recall from the previous section our data field includes a label element
                and by default is configured to be placed to the left of the field content.
                Therefore the result of this will appear as in the figure below.</para>
            <figure>
                <title>Data Field Label</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/dataFieldLabel.png"/>
                    </imageobject>
                </mediaobject>
            </figure>                
            <para>The given property name can be a nested path. For an example of this, suppose now
                our model is the following:</para>
            <programlisting>
public class BookForm {
  private Book book;
  
  // getters/setters
}

public class Book {
  private String bookId;
  private String bookTitle;
}
            </programlisting>
            <para>To display the bookId now, our property name should be “book.bookId”. This is the
                same as doing getBook().getBookId(). More complex situations will be covered in the
                section ‘Data Binding’.</para>            
        </section>
        <section>
            <title>Input Field</title>
            <para>An Input Field extends from the Data Field and gives edit capability. This means
                the user can change the value for the associated property and submit back using the
                HTML form. Values are edited using an HTML control which is represented in KRAD with
                a Control content element. We will learn all about the various types of controls
                later on in this chapter. </para>
            <para>To create a new input field we specify a new bean with
                parent=”Uif-InputField”:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” ... &gt;</programlisting>
            <para>Now since input field is also a data field, we must specify the property it is
                associated with using the propertyName property:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId”/&gt;</programlisting>
            <para>Furthermore, since we have an input field and want to allow the user to change the
                value, we need to configure a control component to use. We set the control component
                for the input field using the <emphasis role="bold">control</emphasis>
                property:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:label=”Book Id”&gt;
    &lt;property name=”control”&gt;
    &lt;bean parent=”Uif-TextControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
            <para>The control component is a new object, not a primitive. Therefore we use a bean or
                ref tag to provide the value. In this example we are using the text control whose
                bean id is ‘Uif-TextControl’. If needed, we could set properties on the text control
                component using the  p namespace or nested property tags.</para>
            <para>In the figure below we see the result of the above input field
                configuration.</para>
            <para>The rendered HTML for our input field will be the following:</para>
            <programlisting>&lt;input id="u66" name="bookId" class="uif-control uif-textControl valid" tabindex="0" type="text" value="" size="30" aria-invalid="false"&gt;</programlisting>
            <para>Where did all these attributes come from? Since we didn’t assign an id, the framework generated 
            one for us and outputted as the element id. Next, the propertyName given for the input field was used 
            as the name attribute on the tag. This is important for binding the data which will be discussed in the 
            section ‘Data Binding’. The ‘Uif-TextControl’ bean that was used for the control property included a 
            default size of ‘30’, and also includes the style classes ‘uif-control’ and ‘uif-textControl’. Finally 
            the framework set a tabindex for us (this happens to be the first field on the page) and added aria markup 
            for accessibility. Don’t worry if this all doesn’t make sense now, we’ll see all these properties many more times!</para>
            <tip>
                <title>Data and Input Fields</title>
                <para>Whenever this training manual refers to data field, the same will also apply to 
                    input fields (by inheritance). However the reverse is not always true. </para>
            </tip>
        </section>
        <section>
            <title>Default Values</title>
            <para>Through configuration of the data field, we can also initialize the backing
                property of the model. The value specified will then be set as the property value
                when the model is initialized. Chapter 12 will cover how the model gets initialized
                along with other concerns of the lifecycle. In terms of default values, it is just
                important to know the model gets created for a new request to a view (such as a
                request from the portal or other application menu), and once created is reused
                throughout the conversation (series of posts on the same view). Generally for
                initial requests we do not need to perform a lot of business logic. That is, usually
                we just want to display the view for the user to begin completing. Being able to set
                default values that will display on the initial view is convenient in that we don’t
                have to override the controller method to do the same in code.</para>
            <para>There are two properties available on data field that allows us to configure a
                default value. The first is the property ‘defaultValue’ which takes the actual value
                to use. For example, suppose we want to set a default value of ‘2012’ for the
                bookYear property. This would be done as follows:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookYear” p:defaultValue=”2012”/&gt;</programlisting>
            <para>This is equivalent to code:</para>
            <programlisting>bookForm.setBookYear(“2012”);</programlisting>
            <para>The default value given must be convertible to the property type without a custom
                property editor. </para>
            <tip>
                <title>Default Type Conversion</title>
                <para>Spring uses PropertyEditor classes when converting a configured value in the XML 
                    to the type for the property being populated. Furthermore, these are used when formatting 
                    the value between the user interface and a custom editor can be specified on the data field. 
                    As of Rice 2.0, any custom editor is not used to apply the default value. This 
                    is being looked at for a potential enhancement in 2.2.</para>
            </tip>
            <para>A very powerful feature we will be looking at later on in this training manual is
                the Spring Expression Language (EL). KRAD allows you to use expressions for most
                component properties, including the defaultValue. There are many things you can do
                with EL, but to give you a taste here are a couple:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookYear” p:defaultValue=”@{2010 + 2}”/&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookYear” p:defaultValue=”@{bookId &lt; 1000 ? 2011 : 2012}”/&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookTitle” p:defaultValue=”New Book for @{bookYear}”/&gt;</programlisting>
            <para>The second way to configure a default value is by setting the <emphasis
                    role="bold">defaultValueFinderClass</emphasis> property. This is the full class
                name for the class that implements the <emphasis role="bold"
                    >org.kuali.rice.krad.valuefinder.ValueFinder</emphasis> interface. This
                interface is very simple with just the one method:</para>
            <programlisting>public String getValue();</programlisting>
            <para>Implementations of this can be made to determine the default value in whatever
                manner necessary. Previous to KRAD, this was helpful for retrieving the default
                value from a system parameter. However, with KRAD EL, you can do this with the
                defaultValue property using the <emphasis role="bold">getParm</emphasis>
                function.</para>
            <para>Let’s create a default value finder class that calls a service to retrieve the
                value. Our finder class would be setup like:</para>
            <programlisting>
package edu.myedu.sample;
public class BookCopyrightYearValueFinder implements ValueFinder {
  public String getValue() {
     return getBookService().getDefaultCopyrightYear();
  }

  Protected BookService getBookService() {
     ServiceLocator.getBookService();
  }
}
            </programlisting>
            <para>We would then configure the data field to use our value finder class like
                this:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookYear” p:defaultValueFinderClass=”edu.myedu.sample.BookCopyrightYearValueFinder”/&gt;</programlisting>
            <para>One additional note that should be made regarding default values is for collection
                group fields. Data or Input fields declared in these groups behave differently from
                the standard group, in that for each collection line that exists in the model, a new
                set of fields is created. When configuring a default value (by either mechanism) for
                a collection field, the value is picked up each time a new line is created (as a
                result of an add line request). Thus it is a default value for the collection line. </para>
        </section>
        <section>
            <title>Alternate and Additional Display Properties</title>
            <para>In certain situations, it is necessary to change the display of a data or input
                field when it is read only. For example, we might want to display additional
                information along with the value of the property, or we might want to display a
                different property value. This can be accomplished using the alternate and
                additional display properties that are available on data field (and therefore input
                field through inheritance).</para>
            <para>As is the case throughout much of the UIF, there is more than one way to
                accomplish this. The first method we can use is to directly configure the alternate
                or additional value that should be displayed. This is done using the
                alternateDisplayValue and additionalDisplayValue properties respectively. For
                example, instead of display the value for the bookId property, we want to display
                the string ‘Id Val’:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:alternateDisplayValue=”Id Val”/&gt;</programlisting>
            <para>This would result in the text ‘Id Val’ being displayed (along with the field
                label).</para>
            <para>Now, we decide we just want to append the ‘Id Val’ string the actual value of the
                bookId property, our configuration would then be:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:additionalDisplayValue=”Id Val”/&gt;</programlisting>
            <para>Assuming the bookId is ‘3’, this would result in the text ‘3 *-* Id Val’ being
                displayed as shown below.</para>
            <figure>
                    <title>Data Field Label</title>
                    <mediaobject>
                       <imageobject>
                           <imagedata fileref="../images/KRAD_Guide/fixedDelimiter.png"/>
                       </imageobject>
                    </mediaobject>
            </figure>
            <note>
                <title>*-*</title>
                <para>Where did the *-* come from? KRAD inserts this fixed delimiter between 
                    the property value and the additional display value. Currently this can only 
                    be changed by modifying the template; however this will be customizable in the
                    future.
                </para>
            </note>
            <para>This has limited benefits by itself, but as mentioned earlier, KRAD allows us to
                use expressions to set a value. With EL we can display one or more other property
                values, perform operations and functions, and mix in static text! </para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:additionalDisplayValue=”with title @{bookTitle}”/&gt;</programlisting>
            <para>Again assuming the bookId is ‘3’ and bookTitle is ‘Dogs and Cats’, this would
                result in the text ‘3 *-* with title Dogs and Cats’ being displayed.</para>
            <para>Often, there is a need to display another property value as the alternate or
                additional display value. For example, when we have an id or code field (that
                generally doesn’t have any meaning to the user), it is preferred to display the name
                instead of the code or in addition to. For these cases, you can simply configure the
                alternateDisplayPropertyName or additionalDisplayPropertyName properties with the
                name of the property whose value should be used:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:alternateDisplayPropertyName=”bookTitle”/&gt;</programlisting>
            <para>Assuming bookTitle is ‘Dogs and Cats’, this would result in the text ‘Dogs and
                Cats’.</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:additionalDisplayPropertyName =”bookTitle”/&gt;</programlisting>
            <para>Assuming bookId is ‘3’ and bookTitle is ‘Dogs and Cats’, this would result in the text ‘3 *-* Dogs and Cats’.</para>
            <tip><title>Alternate/Additional Display and Input Field</title>
                <para>The alternate and additional display values are only used 
                when the field is read-only. But input field allows the user to edit the value so does it make sense to 
                configure these properties for an input field? The answer is yes! An input field has a readOnly property 
                (inherited form ComponentBase) which dictates whether the control is rendered. So there might be conditions 
                that set this property to true, causing the control not to render and the value.</para></tip>
        </section>
        <section>
            <title>Recap</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>The Data Field and Input Field components are used to perform data
                            IO</para>
                    </listitem>
                    <listitem>
                        <para>These components are used within an HTML form, corresponding to the
                            KRAD form view component</para>
                    </listitem>
                    <listitem>
                        <para>Data and input fields are associated with a property on the model
                            object (object providing the data)</para>
                    </listitem>
                    <listitem>
                        <para>A data field is used to give a read-only display of a property
                            value</para>
                    </listitem>
                    <listitem>
                        <para>A data field is created with a bean whose parent is
                            ‘Uif-DataField’</para>
                    </listitem>
                    <listitem>
                        <para>The model property associated with the data field is specified using
                            the <emphasis role="bold">propertyName</emphasis> property</para>
                    </listitem>
                    <listitem>
                        <para>The property name can refer to a property on a nested object using the
                            dot notation</para>
                    </listitem>
                    <listitem>
                        <para>An input field adds edit capability for a property’s value</para>
                    </listitem>
                    <listitem>
                        <para>A input field is created with a bean whose parent is
                            ‘Uif-InputField’</para>
                    </listitem>
                    <listitem>
                        <para>The input field contains a control element component which is used to
                            set the  property value (for example, a text control)</para>
                    </listitem>
                    <listitem>
                        <para>We can set a default value with the <emphasis role="bold"
                                >defaultValue</emphasis> property. A static value can be given or an
                            expression which uses data from the model or a provided variable</para>
                    </listitem>
                    <listitem>
                        <para>Default values can also be set by creating a class that implements the
                                <emphasis role="bold">ValueFinder</emphasis> interface</para>
                    </listitem>
                    <listitem>
                        <para>The value finder class is configured for use with the field using the
                                <emphasis role="bold">defaultValueFinderClass</emphasis>
                            property</para>
                    </listitem>
                    <listitem>
                        <para>Default values for fields with a collection group are used to
                            initialize properties on new lines for the collection (after the add
                            action has been taken)</para>
                    </listitem>
                    <listitem>
                        <para>In some cases when the state is read-only we might need to display the
                            value for another property instead of the field’s property, or display
                            the value in addition to. this is done by using the <emphasis
                                role="bold">alternateDisplayPropertyName</emphasis> and <emphasis
                                role="bold">additionalDisplayPropertyName</emphasis>
                            properties</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
    <section>
        <title>Data Binding </title>
        <para>The purpose for our data and input fields is to perform IO between the user interface
            and our application model (or domain objects). The population of data between these two
            layers is known as the data binding process. </para>
        <para>The binding process is mostly handled for us with use of the Spring MVC framework (in 
            previous versions on Rice with the KNS this was handled by the Struts framework). In the 
            majority of cases, all we need to do is correctly point to our property in the model. 
            Sounds easy, right? In cases such as our BookForm example, it is. However, model objects 
            (also called form objects) can contain nested data objects that go down several levels and 
            include collection structures such as List and Map. In order to correctly push and pull the value, 
            Spring needs to know the full ‘path’ of the property relative to the model.</para>
        <para>To understand this better, let’s take a look at how Spring performs the binding process. First, 
            let’s take the outgoing direction (data from model outputted to the page). We know from the 
            previous sections we must specify a propertyName for the data and input fields. In the case of the 
            input field, an input HTML element will be generated within the input field template. However, this 
            is not generated directly but instead uses a helper tag provided by the Spring framework:</para>
        <programlisting>&lt;form:input id="${control.id}" path="${field.bindingInfo.bindingPath}" ... &gt;</programlisting>
        <para>Notice the path attribute (disregard the value for now). This is an attribute of the
            Spring input tag that specifies the path to the property this input should be associated
            with. Spring will do two things with this information. First, it will retrieve the value
            for that property from the model and set as the value attribute for the input tag. Next,
            it will use the path given as the value for the name attribute (if you are wondering the
            id attribute just gets passed through to the id attribute for the HTML tag). Assuming we
            had a property path of ‘bookId’ with value ‘3’, the resulting HTML input would be as
            follows:</para>
        <programlisting>&lt;input id=”u3” name=”bookId” value=”3” ... &gt;</programlisting>
        <para>The value of ‘3’ will then appear inside the rendered text box. All other controls
            types work in a similar manner.</para>
        <para>In the case of a data field or when the input field is read only, the Spring bind tag
            is used. This tells Spring to pull the value for the given property and stick the value
            into a JSP variable (page or request scope). We can then write out that value to stream
            which result in the static text being display.</para>
        <programlisting>
&lt;s:bind path="${field.bindingInfo.bindingPath}"&gt;${status.value}&lt;/s:bind&gt;${status.value}    
        </programlisting>
        <tip>
            <title>Confused by the JSP Syntax?</title>
            <para>If you didn’t completely follow the previous JSP examples, there are a couple of
                things that should help. One any tag that starts with '&lt;s' or '&lt;form': is a Spring tag that was bound to the ‘s’ and ‘form’ 
                namespaces. At the beginning of each template file an include is to done to a JSP that setups the common tag 
                libraries for use. This looks like the following:</para>
            <programlisting>&lt;%@ include file="/krad/WEB-INF/jsp/tldHeader.jsp"%&gt;</programlisting>
            <para>Within tldHeader.jsp we then have the following line:</para>
            <programlisting>&lt;%@ taglib uri="http://www.springframework.org/tags" prefix="s" %&gt;</programlisting>
            <programlisting>&lt;%@ taglib uri="http://www.springframework.org/tags/form" prefix="form"%&gt;</programlisting>
            <para>This allows the Spring tags to be used with the ‘s’ or ‘form’ prefix. A full
                listing of the Spring tags can be found here: </para>
            <para><link
                    xlink:href="http://static.springsource.org/spring/docs/2.0.x/reference/spring.tld.html"
                    >http://static.springsource.org/spring/docs/2.0.x/reference/spring.tld.html</link></para>
            <para><link
                    xlink:href="http://static.springsource.org/spring/docs/2.0.x/reference/spring-form.tld.html"
                    >http://static.springsource.org/spring/docs/2.0.x/reference/spring-form.tld.html</link></para>
            <para>The second thing to be aware of are the ‘${ }’ expressions. These are JSTL (Java
                Standard Tag Library) expression that allow use to evaluate expressions similar to
                the use of scriptlets. JSTL also includes a set of tags that are bound to the ‘c’
                namespace. More information on JSTL can be found at the following website:</para>
            <para><link xlink:href="http://java.sun.com/products/jsp/jstl/reference/docs/index.html"
                    >http://java.sun.com/products/jsp/jstl/reference/docs/index.html</link></para>
        </tip>
        <para>Now let’s look at the incoming direction. This is data contained in the HTML form
            (with the controls) that we wish to populate onto the model. Recall that when we used
            the Spring tag, our property path was used for the name attribute value. When the page
            is submitted, the browser will use the name attribute as the corresponding name of the
            request parameter. The request parameter value will then be the value that was set on
            the control. </para>
        <para>On the server, Spring will then iterate through the request parameter map and attempt
            to find a property on the model that matches the request parameter key. If a match is
            made, the corresponding request parameter value is set as the value of the property.
            That’s it! Our binding is complete. Therefore, as long as we have configured the
            property name to match a property on our model (nested or not), Spring will take care of
            the rest.</para>
        <section>
            <title>Property Editors</title>
            <para>When binding the data between the JSP page and the model, Spring will again invoke
                registered Property Editors to perform the necessary type conversion. All values
                within the interface are treated as Strings. When going from or to a property type,
                other than the primitive types or String type, a property editor must be
                used.</para>
            <para>Spring provides out-of-the-box property editors for common Java types that are
                registered by default (registration is the process of configuring the Spring
                container to use a property editor). Also, some optional property editor
                implementations are provided that can be used. These include:
                ByteArrayPropertyEditor, ClassEditor, CustomBooleanEditor, CustomCollectionEditor,
                CustomDateEditor, CustomNumberEditor, FileEditor, InputStreamEditor, LocaleEditor,
                PatternEditor, PropertiesEditor, StringTrimmerEditor, and URLEditor.</para>
            <para>In addition to the provided Spring property editors, KRAD provides a set that can
                be used with the custom Kuali types (such as KualiDecimal and KualiInteger) and
                other common formatting practices. These include:</para>
            <para><emphasis role="bold">UifBooleanEditor</emphasis> – Formats any of the strings
                "/true/yes/y/on/1/" to the Boolean true, and any of the strings "/false/no/n/off/0/"
                to Boolean false. Conversely, the Boolean true is formatted as the string “true” and
                the Boolean false is formatted as the string “false”. </para>
            <para><emphasis role="bold">UifCurrencyEditor</emphasis> – Used for converting between a
                KualiDecimal and a string. String is formatted uses commas and to two decimals
                places.</para>
            <para><emphasis role="bold">UifDateEditor</emphasis> – Use for converting between a
                java.util.Date and a string. The Rice <emphasis role="bold"
                    >DateTimeService</emphasis> is used to perform the string formatting and for
                parsing the string to create a date object.</para>
            <para><emphasis role="bold">UifKualiIntegerEditor</emphasis> – Used for converting
                between a KualiInteger and a string. String is formatted uses commas and to zero
                decimals places.</para>
            <para><emphasis role="bold">UifPercentageEditor</emphasis> – Used for converting between
                a KualiPercent and a string. Formatting is similar to UifCurrencyEditor.</para>
            <para><emphasis role="bold">UifTimestampEditor</emphasis> – Used for converting between
                a java.sql.Timestamp and a string. The Rice DateTimeService is used to perform the
                string formatting and Timestamp creation.</para>
            <para>These property editors, along with Spring editors, are registered with Spring by
                property type. This means whenever Spring encounters the associated type for the
                property being bound to, it will use the registered property editor. For example,
                the UifCurrencyEditor is registered with the KualiDecimal type. Thus, when binding
                to a property with type KualiDecimal, the UifCurrencyEditor will be used. </para>
            <para>If needed, KRAD allows you to also specify a property editor to use for a data field. 
                This might be needed to support a custom data type or to perform custom formatting 
                (formatting refers to the process of rendering a String from an object). To create a 
                new property editor, a class must be created that implements the PropertyEditor interface. 
                The easiest way to do this is to extend the Spring provided class 
                java.beans.PropertyEditorSupport, and then override the getAsText() and setAsText(String 
                text) methods.</para>
            <programlisting>
package edu.sampleu.demo.kitchensink;
public class UITestPropertyEditor extends PropertyEditorSupport implements Serializable {
    private static final long serialVersionUID = -4113846709722954737L;

    /**
     * @see java.beans.PropertyEditorSupport#getAsText()
     */
    @Override
    public String getAsText() {
        Object obj = this.getValue();

        if (obj == null) {
            return null;
        }

        String displayValue = obj.toString();
        if (displayValue.length() > 3) {
            displayValue = StringUtils.substring(displayValue, 0, 3) + "-" + StringUtils.substring(displayValue, 3);
        }

        return displayValue;
    }

    /**
     * @see java.beans.PropertyEditorSupport#setAsText(java.lang.String)
     */
    @Override
    public void setAsText(String text) {
        String value = text;
        if (StringUtils.contains(value, "-")) {
            value = StringUtils.replaceOnce(value, "-", "");
        }

        this.setValue(value);
    }
}
            </programlisting>
            <para>The two methods implemented here correspond to the two directions: outgoing to the page (to string), 
                and incoming to the model (to object). The getAsText() method is invoked to build the string that 
                should be displayed. We can use the getValue() method provided by the base class to get current object, 
                then build the string and return. The setAsText(String text) method is used to build the object from 
                the String. After we have constructed the object, we can call the setValue method to set the object 
                that will be used for the model property value.</para>
            <para>Once we have the property editor class created, we can configure it to be used
                with our data field by specifying the full class name in the propertyEditor
                property:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookId” p:propertyEditor=”edu.sampleu.demo.kitchensink.UITestPropertyEditor”/&gt;</programlisting>
            <para>Likewise the property editor can be specified for an input field:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:propertyEditor=”edu.sampleu.demo.kitchensink.UITestPropertyEditor”/&gt;</programlisting>
        </section>
        <section>
            <title>Complex Paths</title>
            <para>So far, we have used examples where the property was either directly on the model
                (form) object or one level down. Now let’s look at more complex paths for binding
                that include many levels of nesting and collection properties. </para>
            <para>Let’s assume we have the following objects:</para>
            <programlisting>
public class TestForm {
  private String field1;
  private Test1Object test1Object;
}

public class Test1Object {
  private String t1Field;
  private Test2Object test2Object;
  private List&lt;Test2Object&gt; test2List;
}

public class Test2Object {
  private String t2Field;
  private Map&lt;String, String&gt; t2Map;
}
                
            </programlisting>
            <para>Some examples paths for these properties would be:</para>
            <programlisting>Field1 on TestForm – “field1”</programlisting>
            <para>T1Field on Test1Object = “test1Object.t1Field” (each time we go into a nested
                object, we use a dot)</para>
            <programlisting>T2Field on Test2Object – “test1Object.test2Object.t2Field”</programlisting>
            <para>T2Field on Test1List – “test1Object.test2List[0].t2Field”,
                “test1Object.test2List[1].t2Field”, “test1Object.test2List[2].t2Field”, … (the path
                for a collection field must specify the item index using the brackets [] and the
                index within the brackets).</para>
            <para>T2Map on Test2Object – “test1Object.test2Object.t2Map[‘key1’]”,
                “test1Object.test2Object.t2Map[‘key2’]” (for binding to a map we again use the
                brackets with the map key within the brackets and quoted).</para>
            <para>We can continue forming paths for objects that are nested at deeper levels by
                adding additional dots to the path. In this way, we can form the path and set as the
                propertyName value for any model property:</para>
            <para>&lt;bean parent=”Uif-DataField”
                p:propertyName=”test1Object.test2Object.t2Field”&gt;</para>
            <para>Now suppose Test2Object had a large set of fields we wanted to display, we could
                configure all of them just as the previous example:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”test1Object.test2Object.t2Field1”&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”test1Object.test2Object.t2Field2”&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”test1Object.test2Object.t2Field3”&gt;</programlisting>
            <para>This is, however, very tedious and repetitive. Luckily, the UIF provides a class
                named <emphasis role="bold">BindingInfo</emphasis> for which a property exists on
                data field. This class separates the path into three parts. The first is called the
                binding object path. This is the path to a data object on the model. The second is
                called the binding prefix, and the third part is the binding name.</para>
            <para>The binding name is usually the same as the given property name and will be synced if not set. The binding prefix is 
                then a prefix to add before the binding name (property name). Finally, the full path is formed by joining the prefix 
                and name to the object path. This is known as the binding path and is invoked by the templates to set the Spring path 
                attribute. Please note the binding prefix is optional and not always beneficial to use.</para>
            <para>Let’s breakdown the path ”test1Object.test2Object.t2Field1” from the previous
                example. A good candidate for the object path is “test1Object.test2Object”. That
                just leaves “t2Field1” so there is not really a need for a binding prefix.
                Therefore, our configuration would be:</para>
            <para>&lt;bean parent=”Uif-DataField”
                p:bindingInfo.bindingObjectPath=”test1Object.test2Object”
                p:propertyName=”t2Field1”&gt;</para>
            <para>We could also configure out data field as follows:</para>
            <para>&lt;bean parent=”Uif-DataField” p:bindingInfo.bindingObjectPath=”test1Object”
                p:bindingInfo.bindByNamePrefix=”test2Object” p:propertyName=”t2Field1”&gt;</para>
            <para>You might be wondering what the KRAD designers were thinking at this point. This
                doesn’t seem to remove the repetition, and in fact, it is much more verbose! On an
                individual field level, that is true. The benefit is that we can put multiple fields
                which share similar paths together into a group. </para>
            <para>We will learn all about the Group component in the next chapter, but two
                properties that exist are fieldBindByNamePrefix and fieldBindingObjectPath. When one
                or both of these properties are configured on the group, the value will be taken and
                set on corresponding binding info property for each group field.</para>
            <para>For example:</para>
            <programlisting>
&lt;bean parent=”Uif-VerticalBoxGroup” p:fieldBindingObjectPath=”test1Object.test2Object”&gt;
    &lt;property name=”items”&gt;
        &lt;list&gt;
            &lt;bean parent=”Uif-DataField” p:propertyName=”t2Field1”&gt;
            &lt;bean parent=”Uif-DataField” p:propertyName=”t2Field2”&gt;
            &lt;bean parent=”Uif-DataField” p:propertyName=”t2Field3”&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
            <para>This will result in “test1Object.test2Object” being set as the
                bindingInfo.bindingObjectPath for each of the three contained fields. Now that’s
                better!</para>
            <para> But KRAD goes one step further! We can also specify a default object binding path
                for the entire view. This is done by setting the defaultBindingObjectPath property
                on the View component. This will set the binding object path for all fields (and
                collection groups) if not already set (we can override if necessary). This is very
                useful in particular for the various view types provided. One example is the
                MaintenanceView. This view targets the maintenance of a data object instance. This
                data object instance is found in the model with path
                ‘document.newMaintainableObject.dataObect’. Since typically all of these views do
                are all data for a particular record to be edited, we just need to specify the
                properties of the data object we want to present. The maintenance view makes this
                easy for us by setting “document.newMaintainableObject.dataObject” as the
                defaultBindingObjectPath. Therefore when specifying the view fields we just need to
                specify the property name relative to the data object: </para>
            <programlisting>       
&lt;bean parent="Uif-InputField" p:propertyName="number"/&gt;
&lt;bean parent="Uif-InputField" p:propertyName="name"/&gt;
...</programlisting>
            <para>Which would result in binding paths:</para>
            <programlisting>
‘document.newMaintainableObject.dataObect.number 
‘document.newMaintainableObject.dataObect.name’
            </programlisting>
            <tip>
                <title>Bean Reuse</title>
                <para>Separating out the object path or binding prefix also allows for more reuse.
                    For example, when extending a group bean, it is a simple property change to
                    modify the binding object path or prefix. However, if the object path and prefix
                    is embedded on the property name for each field in the group, the child bean
                    would need to override the entire items list and duplicate all the field
                    information.</para>
            </tip>
            <para>The data and input field components implement the interface <emphasis role="bold"
                    >org.kuali.rice.krad.uif.component.DataBinding</emphasis>. This indicates to the
                framework that the component binds to the model and provides the binding info and
                property name properties. The other component that implements this interface is the
                CollectionGroup. A collection group is a group that iterates over a model collection
                and presents fields for each line. Therefore, when configuring a collection group we
                must point it to the property that holds the collection. This is done exactly the
                same as for data fields, using the propertyName property and the bindingInfo
                property. For example:</para>
            <programlisting>&lt;bean parent=”Uif-TableCollectionGroup” p:propertyName=”mycollection” ... &gt;</programlisting>
            <para>One thing to note is how the binding path for the fields within the collection
                group is formed. These fields will automatically receive a binding prefix that is
                the path for the collection line. This path includes the collection path plus the
                line index: “mycollection[0]”, “mycollection[1]”. Therefore the fields specified
                within the collection are relative to the line (data object for the collection).
                This would be the same as setting the fieldBindByNamePrefix property on a standard
                group component.</para>
            <para>Finally, there are a couple other properties on the binding info class that are
                helpful to know about. The first of these is the bindToMap property. This is
                necessary when our property name (or binding name) is actually a Map key. Recall in
                these cases we need to use the special bracket notation. When this property is true,
                the binding path will be formed using the object path, binding prefix, then the
                brackets with the binding name in quotes.</para>
            <programlisting>
&lt;bean parent=”Uif-DataField” p:bindingInfo.bindingObjectPath=”test1Object.test2Object” p:bindingInfo.bindByNamePrefix=”t2Map” p:bindingInfo.bindToMap=”true” p:propertyName=”key1”&gt;</programlisting>
            <para>Would result in the following binding path:</para>
            <para>“test1Object.test2Object.t2Map[‘key1’]”</para>
            <para>Another useful property on binding info is the <emphasis role="bold"
                    >bindToForm</emphasis> property. This is essentially an indicator to not add on
                any binding object path (either from the view or a group). The binding prefix is
                still added if specified.</para>
            <para>For example:</para>
            <programlisting>
&lt;bean parent=”Uif-VerticalBoxGroup” p:fieldBindingObjectPath=”test1Object.test2Object”&gt;
    &lt;property name=”items”&gt;
        &lt;list&gt;
            &lt;bean parent=”Uif-DataField” p:propertyName=”t2Field1”&gt;
            &lt;bean parent=”Uif-DataField” p:propertyName=”field1” p:bindingInfo.bindToForm=”true”&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
            <para>The binding path for the first data field would be
                “test1Object.test2Object.t2Field1”, but the binding path for the second data field
                will only be “field1”, due to the bindToForm property being set to true.</para>
        </section>
        <section>
            <title>Recap</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>The process of populating the model from an HTTP request and
                            outputting values to the response from the model is referred to as data
                            binding</para>
                    </listitem>
                    <listitem>
                        <para>The Spring MVC framework takes performs the binding process </para>
                    </listitem>
                    <listitem>
                        <para>For the incoming direction (request to model), Spring looks for
                            request parameters that match a property name on the model (starting
                            from the top object and using dot notation for nested objects)</para>
                    </listitem>
                    <listitem>
                        <para>For the outgoing direction (model to response), we use the provided
                            Spring JSP tags and specify the path attribute to the property whose
                            value should be outputted</para>
                    </listitem>
                    <listitem>
                        <para>The Spring tags in KRAD have the namespaces ‘s’ and ‘form’</para>
                    </listitem>
                    <listitem>
                        <para>When a conversion between data types is needed (for example String to
                            Date), Spring uses a <emphasis role="bold">PropertyEditor</emphasis>. 
                            Spring comes with default property editors for basic Java types and
                            additional editors that can be used as needed. In addition KRAD provides
                            property editors which include:</para>
                        <itemizedlist>
                                <listitem>
                                    <para>UifBooleanEditor</para>
                                </listitem>
                                <listitem>
                                    <para>UifCurrencyEditor</para>
                                </listitem>
                                <listitem>
                                    <para>UifDateEditor</para>
                                </listitem>
                                <listitem>
                                    <para>UifKualiIntegerEditor</para>
                                </listitem>
                                <listitem>
                                    <para>UifPercentageEditor</para>
                                </listitem>
                                <listitem>
                                    <para>UifTimestampEditor</para>
                                </listitem>
                            </itemizedlist>
                    </listitem>
                    <listitem>
                        <para>Using the data field propertyEditor property, custom editors can be
                            associated with a property for binding (this includes using one of the
                            provided editors or creating a custom editor)</para>
                    </listitem>
                    <listitem>
                        <para>Complex property paths are created in the following manner:</para>
                        <itemizedlist>
                                <listitem>
                                    <para>Each time a nested object is encountered in the path it is
                                        separated by a dot (eg
                                        ‘nestedObject.nestedObject2.property’)</para>
                                </listitem>
                                <listitem>
                                    <para>A property on a List type is specified using the
                                        collection path then the line index inside brackets (eg
                                        ‘collectionPath[index].property’)</para>
                                </listitem>
                                <listitem>
                                    <para>A Map property is specified using the map path then the
                                        map key in quotes and inside a bracket (eg
                                        ‘mapPath[‘key’].property’)</para>
                                </listitem>
                            </itemizedlist>
                    </listitem>
                    <listitem>
                        <para>When configuring multiple fields that belong to the same nested object
                            (or list or map), it can be tedious to specify the full path each time.
                            To help with this KRAD provides the BindingInfo object. This can be used
                            to set the following properties:</para>
                        <itemizedlist>
                                <listitem>
                                    <para>bindingObjectPath – Path to the parent data object</para>
                                </listitem>
                                <listitem>
                                    <para>bindByNamePrefix – Prefix to add after the object path and
                                        before the binding name (property name)</para>
                                </listitem>
                            </itemizedlist>
                    </listitem>
                    <listitem>
                        <para>Since specifying the bindingObjectPath for each field does not really
                            help with the verbosity, the <emphasis role="bold"
                                >fieldBindingObjectPath</emphasis> on the parent Group can be used
                            instead. Likewise the group component contains the <emphasis role="bold"
                                >fieldBindByNamePrefix</emphasis> property.</para>
                    </listitem>
                    <listitem>
                        <para>We can set a default object path for the entire view using the view
                            component property <emphasis role="bold"
                                >defaultBindingObjectPath</emphasis></para>
                    </listitem>
                    <listitem>
                        <para>Separating the property name into an object path helps with the
                            reusability of bean configuration.</para>
                    </listitem>
                    <listitem>
                        <para> The BindingInfo object also contains the property <emphasis
                                role="bold">bindToMap</emphasis> which is used to indicate the
                            property is a map key (which impacts how the final binding path is
                            formed). In addition, we can set the property bindToForm to true which
                            means we do not want any binding object path (coming from the group or
                            the view) to be prepended. </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
    </section>
    <section>
        <title>Data Dictionary Backing </title>
        <para>In Chapter 4, we learned about the data dictionary and attribute definition entries.
            We learned that we could define a label, control, and certain other properties in the
            attribute definition that will drive the rendering of that attribute wherever it appears
            in the UI. So how does this work with the data fields?</para>
        <para>First, as we have seen, we can configure everything we need directly on the data
            fields; therefore, the UIF does not require the data dictionary to be used. However, the
            UIF does have a process for determining and using an attribute definition for backing a
            data or input field. What this means is if an attribute definition is found, the
            properties specified on the definition will be used as defaults for the data field. If
            the same property is specified on the data field, it will override the value from the
            attribute definition.</para>
        <para>For example, suppose we have the following data object entry and attribute
            definition:</para>        
<programlisting>            
&lt;bean id="TravelAccount" parent="DataObjectEntry"&gt;
    &lt;property name="dataObjectClass" value="edu.sampleu.travel.bo.TravelAccount"/&gt;
        &lt;property name="attributes"&gt;
            &lt;list&gt;
                &lt;ref bean="TravelAccount-number"/&gt;
            &lt;/list&gt;
        &lt;/property&gt;
    &lt;/bean&gt;

&lt;bean id="TravelAccount-number" parent="AttributeDefinition"&gt;
    &lt;property name="name" value="number"/&gt;
    &lt;property name="label" value="Travel Account Number"/&gt;
    &lt;property name="shortLabel" value="Travel Account Number"/&gt;
    &lt;property name="forceUppercase" value="false"/&gt;
    &lt;property name="maxLength" value="10"/&gt;
    &lt;property name="constraintText" value="Must be 10 digits"/&gt;
    &lt;property name="validationPattern"&gt;
        &lt;bean parent="AnyCharacterValidationPattern"/&gt;
    &lt;/property&gt;
    &lt;property name="controlField"&gt;
        &lt;bean parent="Uif-TextControl" p:size="10"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
        <para>And we have the following input field which the previous attribute definition is
            backing:</para>
        <programlisting>  &lt;bean parent=”Uif-InputField” p:propertyName=”number” p:label=”New Travel Account Number” p:forceUppercase=”true”/&gt;</programlisting>
        <para>During the view lifecycle initialize phase, the properties from the attribute
            definition are picked up and set onto the input field (if not set). Note that the names
            do not always match exactly (for example the control property of input field is feed
            from the controlField property of attribute definition). The above example would result
            in an input field with the following state:</para>
        <itemizedlist>
                <listitem>
                    <para>Label: “New Travel Account Number” (from the input field config)</para>
                </listitem>
                <listitem>
                    <para>Short Label: “Travel Account Number” (from the attr def config)</para>
                </listitem>
                <listitem>
                    <para>Force Uppercase: true (from the input field config)</para>
                </listitem>
                <listitem>
                    <para>Max Length: 10 (from the attr def config)</para>
                </listitem>
                <listitem>
                    <para>Constraint Text: “Must be 10 digits” (from the attr def config)</para>
                </listitem>
                <listitem>
                    <para>Validation Pattern: Any Character Validation ((from the attr def
                        config)</para>
                </listitem>
                <listitem>
                    <para>Control: Text control with size 10 (from the attr def config)</para>
                </listitem>
            </itemizedlist>
        <para>An attribute definition can be linked manually through the data field configuration,
            or the framework will attempt to find one based on the field binding path.</para>
        <para>For manual configuration, we use the <emphasis role="bold"
                >dictionaryObjectEntry</emphasis> and <emphasis role="bold"
                >dictionaryAttributeName</emphasis> properties. The dictionary object entry is the
            name of the entry in the data dictionary for which the attribute definition belongs.
            This is generally the full class name a data object. The dictionary attribute name is
            then the value for the name attribute on the definition we want to pick up. For our
            previous example this configuration would be as follows:</para>
        <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”number” p:dictionaryObjectEntry=”edu.sampleu.travel.bo.TravelAccount” p:dictionaryAttributeName=”number”/&gt; </programlisting>
        <para>We can also leave off the dictionaryAttributeName, in which case the framework will
            default it to the given propertyName:</para>
        <para>&lt;bean parent=”Uif-InputField” p:propertyName=”number” </para>
        <programlisting>p:dictionaryObjectEntry=”edu.sampleu.travel.bo.TravelAccount”/&gt;</programlisting>
        <para>If the dictionary properties are not set, the UIF will attempt to find an attribute
            definition with the binding path. This works as follows:</para>
        <orderedlist>
                <listitem>
                    <para>Take the model class as the dictionary object entry (form class which is
                        given on the view) and the binding path as the dictionary attribute name. Is
                        there an entry? If so use it. Else go to step 2.</para>
                </listitem>
                <listitem>
                    <para>Is the binding path nested (contains the dot separator)? If so, get the
                        name before the first dot and gets its type from the form. This will be the
                        dictionary object entry. Use the part after the first dot as the dictionary
                        attribute name. Is there an entry? If so use it. If not, repeat step.</para>
                </listitem>
            </orderedlist>
        <para>As an example let’s take the following model:</para>
        <programlisting>
package edu.myedu.sample;
public class TravelForm {
  private TravelAccount travelAccount;
}

package edu.myedu.sample;
public class TravelAccount {
  private String number;
}
        </programlisting>
        <para>Now suppose we have the following input field:</para>
        <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”travelAccount.number”/&gt;</programlisting>
        <para>The UIF will first ask the data dictionary if it has an entry for
            ‘edu.myedu.sample.TravelForm’ and attribute ‘travelAccount.number’, is so that attribute
            definition will be used to populate the input field. If not, it will then get the
            property type for ‘travelAccount’ from TravelForm. This is of type
            edu.myedu.sample.TravelAccount. Therefore, it will ask the data dictionary if it has an
            entry for ‘edu’myedu.sample.TravelAccount’ and attribute ‘number’, and if so that
            attribute definition will be used. The process continues until an attribute definition
            is found or the binding path is no longer nested.</para>
        <para>The one exception to the above rule is for fields in collection groups. Since the
            assumption is these are properties on the data object for the collection lines, the
            framework begins by asking for entries for that data object class and the property name
            of the field.</para>
        <programlisting>
&lt;bean parent=”Uif-TableCollectionGroup” p:propertyName=”testObject1.mycollection” p:collectionObjectClass=”edu.myedu.sample.Test3Object”&gt;
    &lt;property name=”items”&gt;
        &lt;list&gt;
            &lt;bean parent=”Uif-InputField” p:propertyName=”field1”/&gt;
                ...
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
        <para>The binding path for our field here will be ‘testObject1.mycollection[index].field1’.
            The framework does not begin asking for a definition with this name and form entry type,
            but rather asks the data dictionary for a definition with entry
            ‘edu.myedu.sample.Test3Object’ and attribute name ‘field1’. If the field propertyName is
            nested (or has a bindingInfo.bindByNamePrefix specified), and an entry was not found for
            the full name, the framework will recurse down the path as it does for non-collection
            fields.</para>
        <section>
            <title>Recap</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>We can default the properties for a data or input field from a data
                            dictionary AttributeDefinition</para>
                    </listitem>
                    <listitem>
                        <para> If an AttributeDefinition is used for a data field, the corresponding
                            properties from the definition are used if a value for that property has
                            not been specified for the field (in other words we can override any
                            value on the attribute definition) </para>
                    </listitem>
                    <listitem>
                        <para>We can explicitly associate an attribute definition with a data field
                            using the properties <emphasis role="bold"
                                >dictionaryObjectName</emphasis> and <emphasis role="bold"
                                >dictionaryAttributeName</emphasis></para>
                    </listitem>
                    <listitem>
                        <para>The dictionary object name gives the name of the data object entry in
                            the data dictionary</para>
                    </listitem>
                    <listitem>
                        <para>The dictionary attribute name is the name of the property (the
                            attribute definition ‘name’) associated with the attribute definition.
                            If not given but the dictionary object name is, the propertyName
                            configured on the data field will be used</para>
                    </listitem>
                    <listitem>
                        <para>For fields configured on collection groups, the dictionaryObjectName
                            is automatically set to the collectionObjectClass configured on the
                            group</para>
                    </listitem>
                    <listitem>
                        <para>If an attribute definition is not explicitly defined, the framework
                            will attempt to discover an attribute definition to use. This process
                            involves performing substrings on the binding path (starting from the
                            object path and substringing on the dot) and making a series of calls to
                            determine if an attribute definition exists for a given object entry and
                            attribute name. This continues until a definition is found or until all
                            substrings of the binding path have been tried</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>        
    </section>
    <section>
        <title>Types of Controls </title>
        <para>A very important type of content element is the control. Control components are used
            with an HTML Form to allow the user to interact with the data. The control holds one or
            more data values. These values are first initialized when the page renders (known as the
            initial value) and then can be changed by the user or script (known as the current
            value). When the form is submitted, the controls have their name attribute paired with
            their current value to form a request parameter that is sent to the server.</para>
        <para>Controls are wrapped with the input field component. As described in the beginning of
            this chapter, the input field holds the pointer to the model property who value will be
            used as the initial value of the control. The input field also contains other
            configuration related to the control and its value, such as helper widgets and
            validation constraints.</para>
        <para>HTML controls have different types. Some of these types are represented by different
            tag elements (such as textarea and select), while variations of the input control are
            indicated with the type attribute (technically these might all be considered input
            controls, but KRAD treats each type as a different control). In this section we will
            learn about the different types of controls and their UIF component
            representation.</para>
        <section>
            <title>Checkbox</title>
            <para>The Checkbox control renders an HTML input tag with type of “checkbox”. This
                control is used to toggle the state of a property between two values (usually the
                Booleans true and false). The image shows an example checkbox
                control.</para>
            <figure>
                <title>Checkbox Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/checkboxControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>To create a new checkbox control, we create a new bean with parent of
                ‘Uif-CheckboxControl’. Controls cannot set on their own; they must be defined within
                an input field using the control property:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”acceptIndicator” p:label=”Accept?”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-CheckboxControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <para>The checkbox control has one custom property that can be set which is the value property. 
                This can be used to specify a string value that will be sent to the server when the checkbox
                is checked. If not set, the default Boolean ‘true’ will be sent.</para>
            <tip>
                <title>Checkbox Request Parameters</title>
                <para>It is important to note that browsers only send a request parameter for
                    checkbox controls if their state is checked. That is, if the checkbox is not
                    checked, no request parameter will be sent. Therefore if the value for a
                    checkbox property was true before rendering the page, then the user unselects
                    the checkbox and submits, unless special logic is in place the property will not
                    be set to false. KRAD uses the Spring checkbox tag which adds a hidden that will
                    indicate the presence of a checkbox for each request, then if a corresponding
                    checkbox parameter does not exist, Spring will set the property to false.
                    However when setting the value attribute for use with a non-Boolean type, the
                    reset logic must be taken care of by the developer. </para>
            </tip>
        </section>
        <section>
            <title>File</title>
            <para>The File control is used to allow the user to select a file from their file system
                whose contents will be submitted with the form. The server can then make use of the
                file contents or simply store the file on the server (for example a note
                attachment).</para>
            <para>To specify a file control should be used, a bean with parent of ‘Uif-FileControl’
                should be given:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”fileUpload” p:label=”File
                Upload”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-FileControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</programlisting>
            <para>This control supports no custom properties (just the inherited component and base
                control properties). The image below shows an example file control:</para>
            <figure>
                <title>File Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/fileControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>In order to use the control, there are a couple of requirements for the backend.
                First, the backing property must be of type
                org.springframework.web.multipart.MultipartFile. This is so Spring can set all the
                necessary file information (name, content type, size, bytes). Many times, a pattern
                employed is to have a property on the form with this type that is used for holding
                the upload, and then in a controller method pull the contents to populate a property
                with type File (or store the File object). The MultipartFile class provides a
                convenient method for doing this called transferTo(java.io.File file). </para>
            <para>The second requirement for uploading files is the HTML form encoding type is
                "multipart/form-data". KRAD takes care of this by setting this as the encoding type
                for all forms.</para>
            <tip>
                <title>Multipart Form</title>
                <para>Always using the multipart form encoding (even when no file uploads are present) has 
                    an impact on performance. An upcoming enhancement to KRAD will be to use this encoding 
                    only when a file upload is present (with the use of script detection).  </para>
            </tip>
        </section>
        <section>
            <title>Hidden</title>
            <para>The Hidden control is used to render an HTML input of type hidden. A hidden
                control is not visible to the user, therefore its value can only be changed by
                script. These are often used to hold some state that is needed when the page is
                posted back, or to provide data for scripting purposes.</para>
            <para>To specify a hidden control should be used, a bean with parent of
                ‘Uif-HiddenControl’ should be given:</para>
            <programlisting>    
&lt;bean parent=”Uif-InputField” p:propertyName=”hiddenField”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-HiddenControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <tip>
                <title>Request/Session State</title>
                <para>All model data is stored with the user session and when a form is submitted
                    the request data is overlaid. This means any model properties that were not
                    present in the request will remain untouched. This alleviates the need to write
                    all state to the request (using hiddens) so that it is not lost. </para>
            </tip>
            <para>Using a hidden control is not the same as making the field state hidden (covered
                in Chapter 10). When the field state is hidden, all of the field contents will be
                rendered (including a control that is possibly not hidden) but not visible by
                default. The field contents then can be shown with script once a condition is met.
                With the hidden control, the other field contents (such as label and lookup) can
                still be visible. One usage of the hidden control is to provide a field quickfinder
                (lookup icon) that forces the user to select a value from the lookup instead of
                allowing them to type the value. </para>
            <tip>
                <title>Min/Max Length</title>
                <para>The input field control also has properties for setting min  and max length.
                    If the corresponding properties on the control are not set, they will be synced
                    with the field settings. It can be necessary to have a different setting for the
                    control than the field due to formatting. The min and max length settings for
                    the control are used on the client, which is working with the formatted value.
                    On the server, validation is performed against the model property value
                    (unformatted) and uses the field length settings. </para>
            </tip>
        </section>
        <section><title>Text</title><para>The Text control renders the HTML input element with type
                of “text”. This is a single-line box that allows the user to type the
                value.</para><para>To specify a text control should be used, a bean with parent of
                ‘Uif-TextControl’ should be
                given:</para><programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”title” p:label=”Title”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-TextControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <para>The text control supports the following properties:</para>
            <para><emphasis role="bold">size</emphasis> – This is the display size for the control
                in number of characters</para>
            <para><emphasis role="bold">maxLength</emphasis> – When a value is given, this is the
                maximum number of characters in length the value can have. If set, the browser will
                stop the user from entering more characters than allowed.</para>
            <para><emphasis role="bold">minLength</emphasis> – When a value is given, this is the
                minimum number of characters in length the value can have. Note this is not
                supported by the HTML input tag itself, but is used by the KRAD validators to check
                the value client side or server side.</para>
            <para><emphasis role="bold">datePicker</emphasis> – This is a nested widget component
                that renders an icon next to the text input that can be used  to selected a calendar
                day. Like all components the date picker will be rendered if is render property is
                set to true. This widget and others are covered in Chapter 8.</para>
            <para><emphasis role="bold">watermarkText</emphasis> – Specifies text that will appear
                in the text control when the value is empty. This is used to show example inputs to
                the user and is sometimes referred to as a placeholder (HTML 5). Once the user
                begins to input a value the watermark text is cleared.</para>
            <para><emphasis role="bold">textExpand</emphasis> – A Boolean type which indicates
                whether the text input can be expanded. When enabled, an icon is rendered next to
                the text input that allows the user to click for getting a text area input that
                allows more room for entering the value. This is useful if the maximum length for
                the field is longer than the display size.</para>
            <para>The UIF provides a handful of base beans for the text control that have various
                commonly used configuration. These are as follows:</para>
            <para><emphasis role="bold">Uif-TextControl</emphasis> – The default text control bean
                which sets the size to 30. None of the other text control properties are set by
                default.</para>
            <para><emphasis role="bold">Uif-SmallTextControl</emphasis> – Similar to Uif-TextControl
                but sets the size to 10 and applies an additional style class of
                ‘uif-smallTextControl’.</para>
            <para><emphasis role="bold">Uif-MediumTextControl </emphasis>– The same as
                Uif-TextControl except adds a style class of ‘uif-mediumTextControl’.</para>
            <para><emphasis role="bold">Uif-LargeTextControl</emphasis> – Similar to Uif-TextControl
                but sets the size to 100 and applies an additional style class of
                ‘uif-largeTextControl’.</para>
            <para><emphasis role="bold">Uif-CurrencyTextControl</emphasis> – Same as Uif-TextControl
                except an added style class of ‘uif-currencyControl’. This adds a right align style
                to the control useful for displaying currency.</para>
            <para><emphasis role="bold">Uif-DateControl</emphasis> – Same as Uif-SmallTextControl
                with the data picker added and an additional style class of
                ‘uif-dateControl’.</para>
            <para>Below are various examples of using these beans and setting other
                properties:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”field” p:label=”Field Label”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-MediumControl” p:watermarkText=”It’s watermarked”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <figure>
                <title>Watermark Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/watermarkControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <programlisting>            
&lt;bean parent=”Uif-InputField” p:propertyName=”field” p:label=”Date 1”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-DateControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <figure>
                <title>Date Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/dateControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <programlisting>            
&lt;bean parent=”Uif-InputField” p:propertyName=”field” p:label=”Field Label”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-TextControl” p:textExpand=”true”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <figure>
                <title>Text Expand Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/textExpandControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
        <section>
            <title>TextArea</title>
            <para>The TextArea control is similar to the text control with the exception of
                providing multiple lines for input. This control is used for entering longer strings
                of data such as a description.</para>
            <para>To specify a text area control should be used, a bean with parent of
                ‘Uif-TextAreaControl’ should be given:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”title” p:label=”Title”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-TextAreaControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <para>The text area control supports the following properties:</para>
            <para><emphasis role="bold">rows</emphasis> – Specifies the number of rows (or lines)
                the input should have. This determines the height of the control.</para>
            <para><emphasis role="bold">cols</emphasis> – Specifies the width in characters the
                input should have.</para>
            <para><emphasis role="bold">maxLength</emphasis> – Similar to the text control, when a
                value is given restricts the number to a certain  number of characters. </para>
            <para><emphasis role="bold">minLength</emphasis> – When a value is given, requires the
                length be greater than or equal to a certain number of characters.</para>
            <para><emphasis role="bold">textExpand</emphasis> - A Boolean type which indicates
                whether the text are input can be expanded.</para>
            <para><emphasis role="bold">watermarkText</emphasis> – Specifies text that will appear
                in the text area control when the value is empty.</para>
            <para>The UIF provides a handful of base beans for the text area control that have
                various commonly used configuration. These are as follows:</para>
            <para><emphasis role="bold">Uif-TextAreaControl </emphasis>– The default text area
                control bean which sets rows to 3, and cols to 40.</para>
            <para><emphasis role="bold">Uif-SmallTextAreaControl</emphasis> – Sets rows to 2 and
                cols to 35. Adds the style class ‘uif-smallTextAreaControl’. </para>
            <para><emphasis role="bold">Uif-MediumTextAreaControl</emphasis> – Sets rows to 3 and
                cols to 40. Adds the style class ‘uif-mediumTextAreaControl’. </para>
            <para><emphasis role="bold">Uif-LargeTextAreaControl</emphasis> – Sets rows to 6 and
                cols to 50. Adds the style class ‘uif-largeTextAreaControl’. </para>
            <para>Below shows an example text area control.</para>
            <figure>
                <title>TextArea Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/textAreaControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
        <section>
            <title>Spinner</title>
            <para>The Spinner control is a special text control that renders up and down arrows to
                the right of the control for incrementing and decrementing the value. This is an
                example of a ‘decorated’ control. That is, HTML does not support a Spinner control
                inherently, but we use JavaScript to provide the additional functionality. This
                means the rendered content will be the input element with type of ‘text’, with a
                script invocation to add the spinner functionality.</para>
            <para>Within the UIF, these script decorations are represented by a widget component.
                The widget is associated with the component it works with. In this case, we extend
                the text control component and add the spinner widget. The spinner widget will be
                covered in more detail in Chapter 8.</para>
            <para>To specify a spinner control should be used, a bean with parent of
                ‘Uif-SpinnerControl’ should be given:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”count” p:label=”Spinner Control”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-SpinnerControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <para> Screen shot 13 shows the spinner control. </para>
            <figure>
                <title>Spinner Control</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="../images/KRAD_Guide/spinnerControl.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
        </section>
        <section>
            <title>Multi-Value Controls</title>
            <para>Up to this point, the controls we have seen hold a single value. Next, we will
                look at controls that can hold multiple values to choose from. Some also allow
                selecting multiple values to be submitted. These components are known as multi-value
                controls and implement the org.kuali.rice.krad.uif.control.MultiValueControl
                interface.</para>
            <section>
                <title>Options</title>
            <para>When using a multi-value control, we need to specify a list of options the control
                will present. Each option has two parts: the option key and the option value. The
                key gives the value for the field that will be submitted to the server when the
                option is chosen. The label is display to the user for that option. These do not
                necessarily have to be different, but it is a useful feature to display a friendlier
                label for the value.</para>
            <para>As an example, let’s assume we need to render a control that presents the list of
                states as options. In our model, the property expects the state code (two letter
                abbreviation). However, to help the user we want to display the full name for each
                state. Our options would then look like the following:</para>
                <table frame="all">
                    <title>State Options Example</title>
                    <tgroup cols="2">
                        <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                        <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                        <thead>
                            <row>
                                <entry>Key</entry>
                                <entry>Value</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>AL</entry>
                                <entry>Alabama</entry>
                            </row>
                            <row>
                                <entry>CO</entry>
                                <entry>Colorado</entry>
                            </row>
                            <row>
                                <entry>IN</entry>
                                <entry>Indiana</entry>
                            </row>
                            <row>
                                <entry>OH</entry>
                                <entry>Ohio</entry>
                            </row>
                            <row>
                                <entry>TX</entry>
                                <entry>Texas</entry>
                            </row>
                        </tbody>
                    </tgroup>
                </table>
                <para>To represent these options, Rice provides the <emphasis role="bold"
                        >KeyValue</emphasis> interface and the <emphasis role="bold"
                        >ConcreteKeyValue</emphasis> implementation. This class provides a string
                    property for the key and a string property for the value, with corresponding
                    getters and setters. Furthermore, for configuring key value objects within XML,
                    the bean with name ‘Uif-KeyLabelPair’ is provided (whose class is
                    ConcreateKeyValue). The following demonstrates creating the above list in Spring
                    XML:</para>
                <programlisting>
&lt;property name=”options”&gt;
    &lt;list&gt;
        &lt;bean parent=”Uif-KeyLabelPair” p:key=”AL” p:value=”Alabama”/&gt;
        &lt;bean parent=”Uif-KeyLabelPair” p:key=”CO” p:value=”Colorado”/&gt;
        &lt;bean parent=”Uif-KeyLabelPair” p:key=”IN” p:value=”Indiana”/&gt;
        &lt;bean parent=”Uif-KeyLabelPair” p:key=”OH” p:value=”Ohio”/&gt;
        &lt;bean parent=”Uif-KeyLabelPair” p:key=”TX” p:value=”Texas”/&gt;
&lt;/property&gt;
                </programlisting>    
            </section>
            <section><title>Key Value Finders</title>
                <para>Hard-coding in the options works for some simple cases (like ‘Yes’, ‘No’ type
                    options), however most of the time the options need to be built up dynamically.
                    This might require performing a database query to retrieve code/name pairs, or
                    invoking a service to retrieve the options. For this, a small piece of code must
                    be written that implements the org.kuali.rice.krad.keyvalues.KeyValuesFinder
                    interface. The easiest way to implement a key value finder is to extend the base
                    class org.kuali.rice.krad.keyvalues.KeyValuesBase. When extending this base
                    class, we must implement the following method:</para>
                <programlisting>public List&lt;KeyValue&gt; getKeyValues();</programlisting>
                <para>Hopefully, it is
                    clear what we need to do here. As stated previously, each option is represented
                    by a KeyValue object, so we return a List of KeyValue objects that will make up
                    our options. How the method is implemented depends purely on the application
                    logic needed. A common pattern is to query the database to retrieve all records
                    of a certain type, and then to use two fields from the record (usually the
                    primary key property and a description property) as the key and value. Here is
                    an example from the Rice project that is building up the options for
                    state:</para>
                <programlisting>
public List&lt;KeyValue&gt; getKeyValues() {
    List&lt;KeyValue&gt; labels = new ArrayList&lt;KeyValue&gt;();
    List&lt;State&gt; codes = 
LocationApiServiceLocator.getStateService().findAllStatesInCountry(countryCode);

labels.add(new ConcreteKeyValue("", ""));
for (State state : codes) {
    if(state.isActive()) {
        labels.add(new ConcreteKeyValue(state.getCode(), state.getName()));
        }
    }
    return labels;
}
                </programlisting>
                <para>Notice the construction of ConcreteKeyValue objects using the state code and
                    name properties. </para>
                <para>Once a key value finder class is created, it needs to be specified on the
                    input field for which the options should apply. This is done using the <emphasis
                        role="bold">optionsFinder</emphasis> or <emphasis role="bold"
                        >optionsFinderClass</emphasis> properties. This first of these takes an
                    actual KeyValueFinder instance, so it will be an inner bean or bean reference in
                    the XML. This is useful if a reusable finder has been created that contains
                    properties which can be configured. For example, suppose our state finder had an
                    option indicating whether inactive state codes should be included.  First, we
                    could setup a base bean as follows:</para>
                <programlisting>&lt;bean id=”StateOptionsFinder” class=”org.kuali.rice.location.framework.state. StateValuesFinder”/&gt;</programlisting>
                <para>Next, we can specify that the state finder should be used for an input field
                    and configure the include inactive option:</para>
                <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”stateCode”&gt;
    &lt;property name=”optionsFinder”&gt;
        &lt;bean parent=”StateOptionsFinder” p:includeInactive=”true”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>If our finder class does not have any options, or we just want to use the
                    default, we can specify the class using the optionsFinderClass property:</para>
                <programlisting> &lt;bean parent=”Uif-InputField” p:propertyName=”stateCode” p:optionsFinderClass=” org.kuali.rice.location.framework.state.StateValuesFinder”/&gt; </programlisting>
                <note>
                    <title>Reusable Key Value Finders</title>
                    <para>Since the majority of key value finder implementations employ the pattern of 
                        retrieving all records for a business object, a ‘generic’ key value finder could 
                        easily be built that is configured with the business object class to retrieve, and 
                        properties that should be used for the key and value. Then this finder can be referenced 
                        and configured within input fields saving the need to create a new class each time. 
                        This along with potentially other reusable key value finders will be added in Rice 
                        2.2.</para>
                </note>
                <para>When the key value finder class is configured on an input field, during the
                    view lifecycle it will be invoked to build the options, which will then in turn
                    be set on the options property of the control. If the options property was
                    already set on the control, it will not be overridden.</para>
                <para>The KeyValueFinder class is actually used not only in KRAD but in various
                    places throughout the Rice project. In terms of building options for our
                    controls, it has one big gap. Our getKeyValues method takes no parameters, so
                    unless our model data is provided through some global variable, it is not
                    possible to conditionally build the options based on a model property value.
                    This is a use case that comes up often. For example, think of two dropdown
                    controls, the first providing options for the food groups (Dairy, Fruit,
                    Vegetables, and so on). The second dropdown should provide options for the
                    particular foods within the selected group of the first dropdown. Thus, our key
                    value finder for the food dropdown needs to know the current value for the food
                    group.</para>
                <para>To allow for this, KRAD extends the KeyValueFinder interface with
                    org.kuali.rice.krad.uif.control.UifKeyValuesFinder. One of the methods this
                    interface adds is the following:</para>
                <programlisting>public List&lt;KeyValue&gt; getKeyValues(ViewModel model);</programlisting>
                <para>Notice we now have a getKeyValues method that takes in the model for which we
                    can get at our application data. A base class named
                    org.kuali.rice.krad.uif.control.UifKeyValuesFinderBase is provided for creating
                    new UIF key value finders. The following demonstrates implementing conditional
                    logic for building the options:</para>
                <programlisting>
public class FoodKeyValuesFinder extends UifKeyValuesFinderBase {  

@Override
public List&lt;KeyValue&gt; getKeyValues(ViewModel model) {
    UifComponentsTestForm testForm = (UifComponentsTestForm) model;           
                        
    List&lt;KeyValue&gt; options = new
                        ArrayList&lt;KeyValue&gt;();           

        if (testForm.getFoodGroup().equals("Fruits")) {
            options.add(new ConcreteKeyValue("Apples", "Apples"));
            options.add(new ConcreteKeyValue("Bananas", "Bananas"));
            options.add(new ConcreteKeyValue("Cherries", "Cherries"));
            options.add(new ConcreteKeyValue("Oranges", "Oranges"));
            options.add(new ConcreteKeyValue("Pears", "Pears"));
        } else if (testForm.getFoodGroup().equals("Vegetables")) {
            options.add(new ConcreteKeyValue("Beans", "Beans"));
            options.add(new ConcreteKeyValue("Broccoli", "Broccoli"));
            options.add(new ConcreteKeyValue("Cabbage", "Cabbage"));
            options.add(new ConcreteKeyValue("Carrots", "Carrots"));
            options.add(new ConcreteKeyValue("Celery", "Celery"));
            options.add(new ConcreteKeyValue("Corn", "Corn"));
            options.add(new ConcreteKeyValue("Peas", "Peas"));
        }           
        
        return options;
    }
}
                </programlisting>
                <para>In this example, foodGroup which is on our test form holds the value for the
                    selected food group. This key value finder is then associated with the field
                    that will display the available foods for that group:</para>
                <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="food" p:label="Foods” p:optionsFinderClass="edu.sampleu.travel.options.FoodKeyValuesFinder" p:refreshWhenChanged="field88"&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-DropdownControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>Notice the refreshWhenChanged property setting pointing to foodGroup. This is
                    configuring refresh behavior which we will learn about in Chapter 11. When the
                    value of the foodGroup control changes, it will refresh our food control which
                    will then rebuild the options based on the new food group!</para>
                <para>Besides making the model data available, the UIF key value finder also
                    provides another convenience. In some cases (depending on whether our field is
                    required) we want to display a blank option for our control, while others we do
                    not (forcing a value to be selected). You might have noticed in our state finder
                    the following line:</para>
                <programlisting>labels.add(new ConcreteKeyValue("", ""));</programlisting>
                <para>This is adding a blank option at the beginning of the options list. Previous
                    to KRAD, if you then wanted the same options on another screen but did not want
                    to provide the blank option, a new key value finder class would need to be
                    created. The UifKeyValuesFinder makes this a simple configuration option with
                    the following method:</para>
                <programlisting>public boolean isAddBlankOption();</programlisting>
                <para>When this is set to true, the framework will add a blank option to the
                    returned list of options from the key value finder. Using the mechanism
                    described above for setting key value finder properties, we can reuse the same
                    class in multiple places and configure whether a blank option should be
                    added.</para>
            </section>
            <section>
                <title>CheckboxGroup</title>
                <para>The CheckboxGroup control is a multi-value control that presents each option
                    as a checkbox. When a checkbox is selected the corresponding option key will be
                    selected as a value. The checkbox group allows selecting multiple options,
                    therefore multiple checkboxes for the group may be selected. The option label
                    for each checkbox is rendered to the right of the control.</para>
                <para>The checkbox group control supports one custom property named delimiter. This
                    is a string that will be rendered between each checkbox (including the label).
                    Two common options for this are the ‘&amp;nbsp;’ and ‘&lt;/br&gt;’ strings. Note
                    this is the HTML entity and tag and thus the first adds a space between each
                    checkbox, while the second add a link break between each. These can be used to
                    horizontally or vertically align the checkboxes. KRAD provides base beans for
                    both these options named ‘Uif-HorizontalCheckboxesControl’ and
                    ‘Uif-VerticalCheckboxesControl’.</para>
                <para>To specify a checkbox control should be used, a bean with parent of
                    ‘Uif-HorizontalCheckboxesControl’ or ‘Uif-VerticalCheckboxesControl’ should be
                    given:</para>
                <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”selectedOpts” p:label=”Checkboxes 1”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-VerticalCheckboxesControl”&gt;
            &lt;property name=”options”&gt;
                &lt;list&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O1” p:value=”Option 1”/&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O2” p:value=”Option 2”/&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O3” p:value=”Option 3”/&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>Note we could also have chosen to configure the optionsFinder or
                    optionsFinderClass on the input field bean instead of configuring the options
                    directly on the control.</para>
                <para>Below shows the checkbox group control.</para>
                <figure>
                    <title>CheckboxGroup Control</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../images/KRAD_Guide/checkBoxGroupControl.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>Since the checkbox group control allows selecting multiple values, our back
                    model property must be a List type of primitives (usually string). For
                    example:</para>
                <programlisting>private List&lt;String&gt; checkboxGroupProperty;</programlisting>
                <para>After the request data is bound to the model, each value that was checked will
                    be an entry in the List.</para>
            </section>
            <section>
                <title>RadioGroup</title>
                <para>The RadioGroup control is similar to the checkbox group control, with the
                    exception of it only allows one value to be selected. Similar to checkbox group
                    it supports the delimiter property and the UIF provides two base beans for the
                    space and line break delimiters.</para>
                <para>To specify a radio control should be used, a bean with parent of
                    ‘Uif-HorizontalRadioControl’ or ‘Uif-VerticalRadioControl’ should be
                    given:</para>
                <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”selectedOpt” p:label=”Radio 1”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-VerticalRadioControl”&gt;
            &lt;property name=”options”&gt;
                &lt;list&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O1” p:value=”Option 1”/&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O2” p:value=”Option 2”/&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O3” p:value=”Option 3”/&gt;
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>  
                <para>Since the radio control only allows selection of one option, the backing property 
                    should be a non-List type.</para>
            </section> 
            <section><title>Select</title><para>The Select control is another variation of a
                    multi-value control. The select control appears similar to the text control, but
                    with an arrow to display a dropdown list of options. The select control can be
                    configured to only allow one selection, or multiple.</para><para>To specify a
                    select control should be used that allows only one value to be selected, a bean
                    with parent of ‘Uif-DropdownControl’ should be used:</para><programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”selectedOpt” p:label=”Select Control”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-DropdownControl”&gt;
            &lt;property name=”options”&gt;
                &lt;list&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O1” p:value=”Option 1”/&gt;
                    ...         
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>The backing property in this case should be a simple primitive (string, integer, …). </para>
                <para>Below shows the select control allowing only one selection.</para>
                <figure>
                    <title>Select Control</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../images/KRAD_Guide/selectControl.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>To specify a select control should be used that allows one or more values to
                    be selected, a bean with parent of ‘Uif-MultiSelectControl’ should be used: </para>
                <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”selectedOpts” p:label=”Multi Select Control”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-MultiSelectControl”&gt;
            &lt;property name=”options”&gt;
                &lt;list&gt;
                    &lt;bean parent=”Uif-KeyLabelPair” p:key=”O1” p:value=”Option 1”/&gt;
                    ...
                &lt;/list&gt;
            &lt;/property&gt;
        &lt;/bean&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>Below shows the select control allowing multiple values to be selected. </para>
                <figure>
                    <title>Multi Select Control</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../images/KRAD_Guide/multiSelectControl.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
                <para>The select control supports two custom properties. The first is the multiple
                    property which is a boolean indicating whether selection of more than one value
                    is allowed (set to true by the ‘Uif-MultiSelectControl’ bean). The second
                    property is named size and configures how many options should be visible to the
                    user without using the arrow. This dictates the vertical size of the control. As
                    an example the select control is Screen Shot 17 was set as 3. </para>
            </section>
            <section>
                <title>KIM Group</title>
                <para>The KIM Group control is not an actual different type of HTML control.
                    Instead, it is a wrapper for the text control that provides additional
                    functionality related to selecting a KIM group. The KIM group and KIM user
                    entities are used often in Rice enabled applications, therefore these controls
                    are provided to simplify the configuration.</para>
                <para>The group control adds a quickfinder (lookup icon) to the text control that is
                    configured to invoke the KIM group lookup. The lookup is configured to return
                    the group id, namespace, and name. The namespace and name fields can then be
                    displayed as data or input fields, and the group id will be added as a
                    hidden.</para>
                <para>To use the KIM group control a bean with parent of ‘Uif-KimGroupControl’
                    should be given. The property that backs the input field for which the control
                    is configured is assumed to hold the group name. As usual this is configured
                    using the propertyName property on input field. In order for the control to work
                    properly, we must then specify the properties that hold the group id and
                    namespace:</para>
                <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="groupNamespaceCode" p:label="Namespace Code"/&gt;
&lt;bean parent="Uif-InputField" p:propertyName="groupName" p:label="Name"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-KimGroupControl" p:groupIdPropertyName="groupId" p:namespaceCodePropertyName="groupNamespaceCode"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>Notice we are displaying the group namespace in an input field before the group name.</para>
            </section>
            <section>
                <title>KIM User</title>
                <para>The KIM User control is similar to the KIM Group control but instead of a KIM
                    group, allows us to find a KIM User. This control does several things for us.
                    First like the group control, it will configured a quickfinder for our field
                    that is configured to invoke the KIM User lookup. The lookup will then return
                    the principal id, principal name (username), and person name (full name). Also
                    like the group control it will automatically add the principal id as a hidden
                    field for us. In addition, it sets up a field query (covered in later on in this
                    chapter) that display the person name under the control on return from the
                    lookup or when tabbing out of the control.</para>
                <para>To use the KIM User control a bean with parent of ‘Uif-KimPersonControl’
                    should be given. The property that backs the input field for which the control
                    is configured is assumed to hold the principal name. As usual this is configured
                    using the propertyName property on input field. In order for the control to work
                    properly, we must then specify the properties that hold the principal id and the
                    person name:</para>
                <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="principalName" p:label="Person Name" p:required="true"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-KimPersonControl" p:principalIdPropertyName="principalId" p:personNamePropertyName="personName"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>It a common setup to carry the principal id as a primitive field, with a
                    nested Person object. In these cases it is not necessary to have a separate
                    property for the principal name and person name, but instead the properties on
                    the nested person object can be used. For these cases, the user control provides
                    a simpler way to configure it by setting the personObjectPropertyName. This is
                    the name of the property that holds the nested person object. </para>
                <programlisting>
&lt;bean parent="Uif-InputField" p:propertyName="principalName" p:label="Person Name" p:required="true"&gt;
    &lt;property name="control"&gt;
        &lt;bean parent="Uif-KimPersonControl" p:personObjectPropertyName="person”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
                </programlisting>
                <para>Below shows the user control with the person name displayed:</para>
                <figure>
                    <title>KIM Group Control</title>
                    <mediaobject>
                        <imageobject>
                            <imagedata fileref="../images/KRAD_Guide/KIMGroupControl.png"/>
                        </imageobject>
                    </mediaobject>
                </figure>
            </section>    
        </section>
        <section>
            <title>Recap</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>A control is a type of content element that allows the user to input
                            data through the HTML form</para>
                    </listitem>
                    <listitem>
                        <para>A control has an initial value that comes from a model property, and
                            can then be changed by the user or script on behalf of the user</para>
                    </listitem>
                    <listitem>
                        <para>When the form is submitted, the value for each control is sent as a
                            request parameter. Where the parameter name is the taken from the name
                            attribute and the value is the actual control value</para>
                    </listitem>
                    <listitem>
                        <para>Controls are associated with an input field which holds a pointer to
                            the property from which the control value will be pulled</para>
                    </listitem>
                    <listitem>
                        <para>HTML controls have different types which are represented by different
                            control components in KRAD</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">Checkbox</emphasis> component is used to
                            render an HTML input of type ‘checkbox’. A checkbox is used to toggle a
                            value (typically a boolean property with true or false values)</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">File</emphasis> component is used to render
                            an HTML input of type ‘file’. This allows the user to select a file from
                            the local filesystem that will be uploaded to the server. The backing
                            property for a file control must be of type
                            org.springframework.web.multipart.MultipartFile</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">Hidden</emphasis> component is used to
                            render an HTML input of type ‘hidden’. This control is not visible to
                            the user and therefore cannot be changed directly by the user (only by
                            script)</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">Text</emphasis> component is used to render
                            an HTML input of type ‘text’. This renders a single line text box where
                            the user can type a value. This control supports the following options:</para>
                        <itemizedlist>
                                <listitem>
                                    <para>size – The horizontal display size of the text box</para>
                                </listitem>
                                <listitem>
                                    <para>maxLength – The maximum number of the characters the user
                                        can enter (corresponding to the length of the value)</para>
                                </listitem>
                                <listitem>
                                    <para>minLength – The minimum number of characters that are
                                        required for the value</para>
                                </listitem>
                                <listitem>
                                    <para>dataPicker – A nested data picker widget that allows the
                                        user to select a date from a calendar</para>
                                </listitem>
                                <listitem>
                                    <para>watermarkText – Text that will appear in the control when
                                        there is no value. This is used to help the user know the
                                        format for the value</para>
                                </listitem>
                                <listitem>
                                    <para>textExpand – A boolean that indicates whether the text
                                        expand widget should be enabled for the control. This allows
                                        the user to click an icon and get an expanded text
                                        box</para>
                                </listitem>
                            </itemizedlist>
                    </listitem>
                    <listitem>
                        <para>The UIF provides base beans that promote standard sizes for small,
                            medium, and large text controls. These include ‘Uif-SmallTextControl’,
                            ‘Uif-MediumTextControl’, and ‘Uif-LargeTextControl’</para>
                    </listitem>
                    <listitem>
                        <para>The UIF also provides the bean ‘Uif-DateControl’ which is a text
                            control with the date picker widget enabled. Furthermore the bean
                            ‘Uif-CurrencyTextControl’ can be used when the value is a
                            currency</para>
                    </listitem>
                    <listitem>
                        <para>The TextArea component renders an HTML text area tag. This is a
                            multi-line text box used for long values. The text area components
                            supports the rows and cols properties, which determine the vertical and
                            horizontal display size of the control.</para>
                    </listitem>
                    <listitem>
                        <para>The Spinner component render as HTML input of type ‘text’ that is
                            decorated with the jQuery Spinner plugin. This allows the user to
                            increment or decrement the value using a arrows rendered within the text
                            box</para>
                    </listitem>
                    <listitem>
                        <para>Multi-Value controls are controls which can present multiple values
                            for selection and possibly allow multiple values to be submitted for a
                            single field</para>
                    </listitem>
                    <listitem>
                        <para>When creating a multi-value control we must specify the options that
                            should be available. These are built by configuring instances of the
                            Rice KeyValue interface (ConcreteKeyValue implementation)</para>
                    </listitem>
                    <listitem>
                        <para>KeyValue objects can be created in XML by using the bean
                            ‘Uif-KeyLabelPair’</para>
                    </listitem>
                    <listitem>
                        <para>The list of KeyValues are associated with a control using the
                                <emphasis role="bold">options</emphasis> property</para>
                    </listitem>
                    <listitem>
                        <para>Instead of specifying the options directly in the XML, we can create a
                            class of type org.kuali.rice.krad.keyvalues.KeyValuesFinder and
                            implement the method List&lt;KeyValue&gt; getKeyValues(). This class is
                            then configured on the input field using the property <emphasis
                                role="bold">optionsFinderClass</emphasis> (or an object can be
                            injected using the optionsFinder property)</para>
                    </listitem>
                    <listitem>
                        <para>The UIF provides a special key value finder
                            org.kuali.rice.krad.uif.control.UifKeyValuesFinder that allows
                            conditional key values to be built based on the model</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">CheckboxGroup</emphasis> component is a
                            multi-value control that presents the options are a set of
                            checkboxes</para>
                    </listitem>
                    <listitem>
                        <para>The checkbox group control supports a delimiter which will be rendered
                            between each checkbox. The UIF provides two beans with a delimiter set:
                            ‘Uif-HorizontalCheckboxesControl’ (space delimiter) and
                            ‘Uif-VerticalCheckboxesControl’ (HTML break delimiter)</para>
                    </listitem>
                    <listitem>
                        <para>Checkbox group controls allow multiple values to be selected.
                            Therefore the backing property must be a List type</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">RadioGroup</emphasis> component is similar
                            to the checkbox group, with the exception of only allowing one value to
                            be selected</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">Select</emphasis> component is a multi-value
                            control that presents the options as a dropdown (arrow in the text box
                            that can be clicked to see the options)</para>
                    </listitem>
                    <listitem>
                        <para>Select controls are created using the bean ‘Uif-DropdownControl’ for
                            allowing a single value to be selected or the bean
                            ‘Uif-MultiSelectControl’ for allowing multiple values to be
                            selected</para>
                    </listitem>
                    <listitem>
                        <para>The select control supports the <emphasis role="bold">size</emphasis>
                            property which controls the number of options that are visible without
                            clicking the arrow</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">KIMGroup</emphasis> control is a special
                            text control that is configured for inputting KIM group names</para>
                    </listitem>
                    <listitem>
                        <para>The <emphasis role="bold">KIMUser</emphasis> control is a special text
                            control that is configured for inputting KIM users. It adds things such
                            as a quickfinder and field query</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>    
    </section>
    <section>
        <title>Disabling Controls and Tabbing </title>
        <para>Besides the specific properties offered by the various controls, all control
            components inherit a couple of properties from
            org.kuali.rice.krad.uif.control.ControlBase. The first of these is the <emphasis
                role="bold">tabIndex</emphasis> property. This property is an int type that used to
            populate the taxIndex attribute on the corresponding control element tag. This is of
            course used by the browser to set the tabbing order between the form controls. </para>
        <para>By default, the framework sets all tab indexes to 0. This means the tabbing will
            follow the natural order of the page (the order the controls are laid out on the page).
            However, if needed a specific tab order can be created by setting the tab index property
            for each control.</para>
        <para>The other property supported on all controls is the <emphasis role="bold"
                >disabled</emphasis> property with type Boolean. The value given for this property
            will be set as the attribute value for the disabled attribute of the corresponding
            control element. This is then indicates to the browser that the user should not be
            allowed to interact with the control.</para>
        <para>Similar to other properties, we can statically set the value to ‘true’ or ‘false’ in
            the XML, or use an expression to conditionally disable the control:</para>
        <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”fruitName”&gt;
    &lt;property name=”control”&gt;
        &lt;bean parent=”Uif-TextControl” p:disabled=”@{foodGroup ne ‘Fruit’}”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
        <para>In this example, we are disabling the text control for ‘Fruit Name’ if the food group
            field is not ‘Fruit’.</para>
        <para>The following is an example text control that is in the disabled state:</para>
        <figure>
            <title>Disabled State Control</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/disabledStateControl.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <tip>
            <title>Disabled or Read Only</title>
            <para>An important UX issue is whether to disabled a control, or make the control read only. 
                Both display the current value and prevent the user from changing it. Generally, disabled 
                is used to temporarily disallow interaction based on a condition. It might be the result 
                of a refreshed component based on a change to data. While read only is often used to display 
                a state that cannot be changed based on the current data (for example user permissions or 
                a state that the user cannot modify).</para>
        </tip>
        <note>
            <title>Disabled Reason</title>
            <para>Control base also currently has a property name controlReason. This is not currently being 
                used by the framework but the intention is when a control’s state is changed to disabled, a 
                reason can be given using this property. The user will then be able to hover over the control 
                to see the disabled reason as a tooltip (Tooltips are an upcoming enhancement as well).</para>
        </note>
        <section>
            <title>Recap</title>
            <para>
                <itemizedlist>
                    <listitem>
                        <para>All controls have the <emphasis role="bold">tabIndex</emphasis>
                            property which can be used to implement a custom tab order (Note this is
                            not recommended though, if not set the framework will set the tab
                            indexes based on the natural order of the page)</para>
                    </listitem>
                    <listitem>
                        <para>Controls also support the <emphasis role="bold">disabled</emphasis>
                            property. This is a boolean that will disable the control so that input
                            is not allowed (the control is still rendered). Like most properties,
                            the disabled property can contain an expression to conditionally disable
                            the control</para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>    
    </section>
    <section>
        <title>Hooking up Lookups and Inquiries </title>
        <para>The input field component also provides a couple of widgets we can configure that will
            help the user with data input. The first of these is the fieldLookup property which is a
            nested widget component. This widget component is called a Quickfinder. Quickfinder is a
            term that was adopted in the KNS framework to represent the icon next to a control that
            can be used to bring up a lookup screen, search for a value, and return that value to
            the field. In KRAD, the quickfinder widget holds all the configuration for rendering the
            icon along with the lookup request it makes.</para>
        <para>All the options for quickfinder are covered in Chapter 8, but we will go over the
            essential ones here. To understand these widget properties we need to know a little bit
            about the lookup API. Essentially this is a request based API where communication is
            done via request parameters, of which the following are required:</para>
        <para><emphasis role="bold">dataObjectClassName</emphasis> – Lookup views (a special ‘type’
            of view) are associated with a data object class. This is the class for the data object
            the search will be performed on. After the bean container is loading, an indexing
            process is performed that maps data object classes to configured lookup views (see ‘View
            Type Indexing’ in Chapter 13). Therefore instead of passing in the unique view id to
            specify the view we want, we can pass in the data object class name.</para>
        <para><emphasis role="bold">fieldConversions</emphasis> – The purpose of using the lookup is
            to search for a particular value and return that value to the form being completed. In
            order for the lookup framework to return the field back to us, we must specify the name
            of the field on the data object class whose value we need, and the name of the field on
            the calling view. Furthermore, we can choose to have the lookup return additional fields
            that populate other form fields or informational properties (see ‘Field Queries and
            Informational Properties’). These pairs of fields are known as ‘field
            conversions’.</para>
        <para>The fieldConversions property is a Map. Each entry represents a field that will be
            returned back from the lookup, with the entry key being the field name on the data
            object class, and the entry value being the field name on the calling view. It is
            helpful to think of this as a from-to mapping. Pulling from the data object field (map
            key) to the calling view field (map value).</para>
        <para>To configure a quickfinder on an input field we have two options. First we can create
            an inner bean with parent of ‘Uif-QuickFinder’ for the input field’s fieldLookup
            property:</para>
        <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”document.number”&gt;
    &lt;property name=”fieldLookup”&gt;
        &lt;bean parent=”Uif-QuickFinder” p:dataObjectClassName=” edu.sampleu.travel.bo.TravelAccount” p:fieldConversions=”number:document.number”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
        <para>In this example we have configured a quickfinder that will invoke the lookup view for
            Travel Account. After the user performs a search and selects a row (using the provided
            return value links), the corresponding number property value for the selected row will
            be returned and set in the document.number property for our view (the field for which
            the quickfinder is configured). Notice in this example we are using the map shorthand
            configuration for the fieldConversions property.</para>
        <para>An alternative configuration is to use set the dataObjectClassName and
            fieldConversions properties directly using nested notation. Note this only works if the
            bean we are inheriting from (or one of its parents) has configured the parent property,
            else a NullPointerException will be thrown:</para>
        <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”document.number” p:fieldLookup.dataObjectClassName=”edu.sampleu.travel.bo.TravelAccount” p:fieldLookup.fieldConversions=”number:document.number”/&gt;</programlisting>
        <note>
            <title>Initializing Nested Components</title>
            <para>It is a common practice in the UIF for base beans to initialize and nested components. 
                This allows child beans to simply configure the needed properties on the nested component 
                without having to initialize the component itself. For example, the ‘Uif-InputField’ has the 
                following property tag:</para>
            <programlisting>
&lt;property name="fieldLookup"&gt;
    &lt;bean parent="Uif-QuickFinder"/&gt;
&lt;/property&gt;</programlisting>
            <para>If this was not provided, child beans would need to populate the fieldLookup property using a 
                nested bean instead of using the directed nested property notation.</para>
        </note>
        <para>Below we see the quickfinder icon (to the right of the text control) and the 
            corresponding lookup view that is presented when the user click the icon:</para>
        <figure>
            <title>Quickfinder Hook</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/quickfinderHook.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <figure>
            <title>Quickfinder Hook Example</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/quickfinderHookExample.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Another widget provided by input field and data field components is the Inquiry
            component. The inquiry is used to display additional information about the current field
            value, generally the associated database record. </para>
        <para>There are two different flavors of the inquiry, the ‘standard’ inquiry and the
            ‘direct’ inquiry. The former refers to an inquiry for a field that is read only (user is
            not allowed to change value). This inquiry is configured with the <emphasis role="bold"
                >fieldInquiry</emphasis> property on data field. A direct inquiry refers to an
            inquiry of a field that is editable (has a control for changing the value). This
            inquired is configured with the <emphasis role="bold">fieldDirectInquiry</emphasis>
            property and is available on input fields only.</para>
        <para>Both inquiries point to the Inquiry widget component. This widget holds the
            configuration for invoking the inquiry view once the inquiry is triggered (a link for
            the standard and an icon for the direct). Inquiry views are similar to lookup views.
            They are associated with a data object class and can be requested by passing the data
            object class name. However, for inquiries we need to pass a value from the calling view
            to the inquiry view, instead of the other way around (as is the case for lookup views).
            These are the values that will be used to retrieve the data for the inquiry view.</para>
        <para>This configuration is done using the <emphasis role="bold"
                >inquiryParameters</emphasis> property on the Inquiry widget. Like the Lookup’s
            fieldConversions property, this holds a map where each entry is a mapping of fields
            between the two views. The entry key is the name of the field in the calling view from
            which the value will be pulled, and the entry key is the name of the field in the
            inquiry data object class for which the value will be populated. Again we can think of
            this as a from-to mapping.</para>
        <para>To configure the standard inquiry we use a bean with parent of ‘Uif-Inquiry’. For the
            direct inquiry, we use a bean with parent of ‘Uif-DirectInquiry’. </para>
        <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”document.number”&gt;
    &lt;property name=”fieldInquiry”&gt;
        &lt;bean parent=”Uif-Inquiry” p:dataObjectClassName=” edu.sampleu.travel.bo.TravelAccount” p:inquiryParameters=”document.number:number”/&gt;
    &lt;/property&gt;
    &lt;property name=”fieldDirectInquiry”&gt;
        &lt;bean parent=”Uif-DirectInquiry” p:dataObjectClassName=” edu.sampleu.travel.bo.TravelAccount” p:inquiryParameters=”document.number:number”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
        </programlisting>
        <para>We also have the option of using the nested property notation instead of using inner
            beans.</para>
        <para>Below shows an example inquiry (standard inquiry for read only field), followed by an
            example direct inquiry</para>
        <figure>
            <title>Standard Inquiry, Read Only</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/standardInquiryReadOnly.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <section><title>Automatic Lookups and Inquiries</title><para>For many instances where a
                lookup or inquiry is desired, there is an underlying relationship in the model. In
                Chapter 3, we learned how to represent one to one relationships in code (with nested
                data objects) and then provide configuration to OJB using a reference descriptor. In
                Chapter 4, we learned about the data dictionary and the ability to declare
                relationship definitions for our data object entry. These sources of metadata are
                then consumed by the UIF to automatically configured lookups and inquiries for our
                fields!</para><para>For each data or input field, the framework will attempt to find
                a model relationship if two conditions are met: one, we have not manually configured
                the lookup and inquiry, and two the render flag for both is not set to false.
                Setting the render flag to false on the fieldLookup or fieldInquiry indicates to the
                framework we do not want them rendered regardless of the existence of a
                relationship.</para><para>The basic strategy for determining the existence of a
                relationship is as follows:</para><orderedlist>
                <listitem>
                    <para>Determine a parent data object class for the fields property</para>
                </listitem>
                <listitem>
                    <para>Query OJB metadata to get class descriptor for the data object class, get
                        any reference descriptors the property participates in</para>
                </listitem>
                <listitem>
                    <para>Query data dictionary metadata to get data object entry for the data
                        object class, get any relationship definitions the field participates
                        in</para>
                </listitem>
                <listitem>
                    <para>Of all the relationships found in steps 2 and 3, filter out those where
                        the target class does not support the function (lookup or inquiry). For
                        example if the target data object class is TravelAccount, but there is no
                        lookup view associated with that data object class we do not consider that
                        relationship.</para>
                </listitem>
                <listitem>
                    <para>Of the relationships remaining from step 4, choose the relationship which
                        has the lowest cardinality of foreign keys</para>
                </listitem>
                <listitem>
                    <para>If a relationship was not found and the property name is nested, split the
                        property name using the first part of the path as the parent property and
                        the remaining as the property name. Repeat the process looking for a
                        relationship. Note this is similar to the process of finding a back data
                        dictionary entry.</para>
                </listitem>
            </orderedlist>
            <para>This is a complicated process and not all details are important as a user of KRAD.
                However, the first step is critical to understand and deserves more explanation. The
                determination of the parent data object class drives the metadata picked up by the
                framework and therefore where the relationships will be found. Recall the three
                parts to the fields binding path: the object path, binding prefix, and binding name
                (property name). The framework will use the object path and prefix as the path to
                the parent object (everything except the property name). Then it will get the type
                for the property from the model which is used as the data object class.</para>
            <note>
                    <title>Data Object Metadata</title>
                           <para>Many areas of the UIF (including the above widgets) use metadata from the
                                OJB repository and Data Dictionary together. They use a service
                                named DataObjectMetaDataService which is as a façade for both
                                sources of metadata.</para>
            </note>
            <para>A couple of things should be noted about the automatic lookups and inquiries.
            First, if no relationship is found, the render flag on the widget will be set to false.
            Second, recall for the lookup and inquiry we need to configure field mappings
            (fieldConversions and inquiryParameters). The framework builds these mappings from the
            fields that participate in the relationship.</para> 
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>The input field component provides the quickfinder widget to allow the
                        user to search for a value to enter. This is configured using the
                        fieldLookup property</para>
                </listitem>
                <listitem>
                    <para>The quickfinder can be configured by creating an inner bean with parent
                        ‘Uif-Quickfinder’ or setting options using the nested notation
                        (fieldLookup.property)</para>
                </listitem>
                <listitem>
                    <para>The basic options for a quickfinder are:</para>
                    <itemizedlist>
                            <listitem>
                                <para>dataObjectClassName – The full class name for the data object
                                    whose lookup view should be rendered</para>
                            </listitem>
                            <listitem>
                                <para>fieldConversions – A mapping of properties on the lookup data
                                    object to properties in the calling view. When a result row is
                                    selected from the lookup, the values for the configured lookup
                                    data object fields will be returned to their associated view
                                    properties</para>
                            </listitem>
                            <listitem>
                                <para>lookupParameters – A mapping of properties from the calling
                                    view to search fields for the data object. When the quickfinder
                                    is selected the values for the configured view properties will
                                    be pulled and populated into the search fields</para>
                            </listitem>
                        </itemizedlist>
                </listitem>
                <listitem>
                    <para>The input field also provides the Inquiry widget. This allows the user to
                        see detail associated with the current value. This comes in two flavors, a
                        simple inquiry (presented as a link) for read only state, and a direct
                        inquiry (used by clicking an icon) to inquiry on the current value of a
                        control</para>
                </listitem>
                <listitem>
                    <para>The inquiry widget is configured using the input field’s <emphasis
                            role="bold">fieldInquiry</emphasis> and <emphasis role="bold"
                            >fieldDirectInquiry</emphasis> properties</para>
                </listitem>
                <listitem>
                    <para>The inquiry can be configured by creating an inner bean with parent
                        ‘Uif-Inquiry’ or ‘Uif-DirectInquiry’. We can also use nested notation to set
                        properties (fieldInquiry.property or fieldDirectInquiry.property)</para>
                </listitem>
                <listitem>
                    <para>The basic options for an inquiry are:</para>
                    <itemizedlist>
                            <listitem>
                                <para>dataObjectClassName – Full class name for the data object
                                    whose inquiry view should be rendered</para>
                            </listitem>
                            <listitem>
                                <para>inquiryParameters – A mapping of properties from the calling
                                    view to properties on the inquiry data object. When the inquiry
                                    is selected the values for the view properties will be pulled
                                    and sent with the inquiry as request parameters for the
                                    corresponding inquiry properties. This generally becomes the
                                    critiera for the record selection (and is generally the primary
                                    keys for the data object)</para>
                            </listitem>
                        </itemizedlist>
                </listitem>
                <listitem>
                    <para>If a quickfinder or inquiry is not explicity configured, the framework
                        will attempt to hook these up automatically. This is done using the
                        DataObjectMetaDataService which will finder relationships for the
                        property</para>
                </listitem>
                <listitem>
                    <para>We can turn off automatic quickfinders or inquiries by setting the render
                        property to false</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Input Field Messages </title>
        <para>For views that are not used often (such as a student page) or complex or unclear
            fields it is helpful to provide instructional text within the field. These messages
            provide additional information that helps clarify the intended use.</para>
        <para>The input field component has two types of standard messages that can be configured.
            The first of these is known as instructional text. Instructional text is used to
            indicate more information about filling out a field or how to complete a task using the
            UI elements. An example of this is “Complete this field only if applying for a one year
            loan”. Instructional text is specified for an input field using the instructionalText
            property:</para>
        <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”oneYearTerm” p:instructionalText=”Complete this field only if applying for a one year loan”/&gt;</programlisting>
        <para>The instructional text appears by default above the control and has a style class
            named ‘uif-instructionalMessage’ applied. If the label placement is top, the
            instructional text will appear between the label and the control. </para>
        <para>Another type of message that can be configured on the input field is called constraint
            text. Constraint text gives the user information about the required format of the data
            that must be entered, or other information necessary for entering the data correctly. A
            constraint message can be configured using the constraintText property as shown
            here:</para>
        <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”oneYearTerm” p:constraintText=”Must be formatted as 3 digits”/&gt;</programlisting>
        <para>The constraint text appears by default under the control and has a style class named
            ‘uif-constraintMessage’ applied.</para>
        <para>Below shows an input field with instructional and constraint text.</para>
        <figure>
            <title>Input Field with Contratint Text</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/inputFieldConstraintText.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Recall from Chapter 4 these messages can also be configured on the dictionary
            attribute definition. If an attribute definition is found for the field, the
            instructional and constraint messages will be copied (unless overridden).</para>
        <section>
            <title>Recap</title>
                <itemizedlist>
                    <listitem>
                    <para>Input field provides message properties that can be specified to help
                        clarify the purpose of a form field</para>
                </listitem>
                <listitem>
                    <para>The first type of message is known as instructional text and is configured
                        with the <emphasis role="bold">instructionalText</emphasis> property</para>
                </listitem>
                <listitem>
                    <para>Instructional text is meant to give information about how to complete a
                        field or a task</para>
                </listitem>
                <listitem>
                    <para>By default the instructional text appears above the input field control
                        and has a style class of ‘uif-instructionalMessage’</para>
                </listitem>
                <listitem>
                    <para>The other type of message is known as constraint text and is configured
                        with the <emphasis role="bold">constraintText</emphasis> property</para>
                </listitem>
                <listitem>
                    <para>Constraint text gives information about the format or other constraints
                        for an inputted value</para>
                </listitem>
                <listitem>
                    <para>By default the constraint text appears below the input field control and
                        has a style class of ‘uif-constraintMessage’</para>
                </listitem>
                <listitem>
                    <para>These messages can also be configured on the data dictionary attribute
                        definition and inherited by the input field</para>
                </listitem>
                </itemizedlist>
        </section>
    </section>
    <section>
        <title>Field Queries and Informational Properties </title>
        <para>Next let’s take a look at some of the features available for providing the user
            dynamic information based on the inputted field data. The information provided can vary
            based on what is relevant for a particular field. Generally though, it is similar
            information as provided by the inquiry view, except we pick a couple of important fields
            that inserted directly into the page field (without the user having to take an action
            and bring up a lightbox or separate page).</para>
        <para>To display dynamic information, first we need to setup placeholders or the properties
            that will hold the information. These must be valid properties on the model (however for
            display a custom message the form is a great place to create ‘dummy’ properties). To
            specify information properties we configure the informationalDisplayPropertyNames
            property on DataField. This property is a List type with each entry giving the name for
            a property to display.</para>
        <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:label=”Book Id” p:informationalDisplayPropertyNames=”bookTitle,bookCopyright”/&gt;</programlisting>
        <para>In this example we have an input field for the book id property, and we want to
            display the values for the bookTitle and bookCopyright property with the field. </para>
        <para>Informational display properties by default are rendered under the field control (or
            if read only under the displayed value, also if constraint text is present they will
            display below it). They are always displayed read only. The value for each property is
            placed with a span that receives a style class of ‘uif-informationalMessage’. Therefore,
            we can configure this style to change how the properties are displayed. The default
            style uses the CSS display block style, making each property value appear on a new
            line.</para>
        <para> Below gives a picture of this with two informational properties being
            displayed.</para>
        <figure>
            <title>Two Informational Properties Example</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="../images/KRAD_Guide/informationalProperties.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <section>
            <title>Field Attribute Query</title>
            <para>Each time the field is rendered, the information display property values will be
                displayed. This is a useful, however by itself is not ‘dynamic’. That is, if the
                user then changes the value the information properties will not change to reflect
                the update. To make this happen, we need to associate a piece of functionality
                called attribute query with our field.</para>
            <para>An attribute query is represented by the class
                org.kuali.rice.krad.uif.field.AttributeQuery. This is not a component, just a class
                that configures behavior that can be added to the input field component. Basically
                this class provides properties for configuring a query to retrieve these information
                properties. It has similar concepts to the lookup (quickfinder widget) with a more
                targeted purpose. There are two mechanisms for configuring a query. The first
                involves configured the necessary properties to allow the framework to automatically
                perform a query. This involves the following attribute query properties:</para>
            <para><emphasis role="bold">dataObjectClassName</emphasis> – Name of the data object
                class the query will go against. The class given must be mapped to the database
                (with ORM metadata) to support the automatic lookup. This functions the same as the
                dataObjectClassName for the lookup view (or quickfinder widget).</para>
            <para><emphasis role="bold">queryFieldMapping</emphasis> – A map type that holds the
                mappings of properties from the calling view to properties on the data object class.
                Each entry represents one property mapping. The map key is the property name in the
                calling view, and the map value is the property name on the data object class. This
                will usually include the property name of the field for which the query is
                configured (since we want to query based on the value the user has inputted). We
                might need to pass in additional properties from the view to complete the query.
                This property functions similar to the inquiryParameters on the inquiry
                widget.</para>
            <para>Note this mapping is used to build criteria for the query. The values for the
                calling view properties are retrieved and used to restrict the retrieved data object
                records based on the mapped data object fields. For example, suppose we have the
                following query field mapping: “document.rentedBookId:bookId” and the value of the
                document.rentedBookId on our view is ‘3’. When the query is performed the following
                clause will be created “where bookId = ‘3’” (note the actual SQL is not constructed
                by KRAD, but created by the OJB criteria object).</para>
            <para><emphasis role="bold">returnFieldMapping</emphasis> – A map type that holds the
                mappings of properties from the data object class to the calling view. Each entry
                represents one property mapping. The map key is the property name on the data object
                class, and the map value is the property name on the calling view. We can use this
                property to map properties on the data object class back to configured information
                display properties of the field. However, it is not limited to that. We can also map
                properties of the data object class back to properties that are separate fields
                (thus filling in the control value for those corresponding fields).</para>
            <para><emphasis role="bold">additionalCriteria</emphasis> – A map that holds additional
                criteria for the query. The criteria specified will be added to the constructed
                criteria based on query field mapping. The map key is the name of the property on
                the data object class the criteria should apply to, and the map value is the value
                for the criteria. All map entries are joined using the AND clause. Note, the map
                value does support query characters as provided by the lookup framework (‘!’ – not,
                ‘&gt;’ – greater than, ‘&lt;’ – less than, ‘*’ – wildcard, and so on). In addition
                for the map values, we can use expressions (‘@{}’).</para>
            <para>To hook up an attribute query with an input field we use the <emphasis role="bold"
                    >fieldAttributeQuery</emphasis> property. We can then create an instance of the
                attribute query class by creating a bean with parent of
                ‘Uif-AttributeQueryConfig’:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”rentedBookId” p:label=”Book Id” p:informationalDisplayPropertyNames=”rentedBookTitle,rentedBookCopyright”&gt;
    &lt;property name=”fieldAttribueQuery”&gt;
        &lt;bean parent="Uif-AttributeQueryConfig" p:dataObjectClassName="edu.sampleu.bookstore.bo.Book" p:queryFieldMapping="rentedBookId:bookId" p:returnFieldMapping="bookTitle:rentedBookTitle, bookCopyright:rentedBookCopyright"/&gt;
    &lt;/property&gt;
&lt;/bean&gt;
            </programlisting>
            <para>In this example we have an input field for the rentedBookId property. We then
                setup a query that will go against the Book data object, passing the value for
                rentedBookId as criteria for the bookId property. From the resulting record, the
                bookTitle and bookCopyright property values will be copied to the rentedBookTitle
                and rendedBookCopyright properties. These are configured as informational display
                properties, therefore the updated values will display under the control for
                rentedBookId.</para>
            <para>Note the framework takes care of trigger the query (with the ‘onblur’ event),
                performing the query, and updating the mapping return fields all client side
                (without a page post). It is expected the field attribute query will return only one
                result. If more than one record is retrieved, the first record of the hit list will
                be used. In the case of no matching records, a message will be rendered stating
                ‘{field label} not found’, where {field label} is the configured label. This message
                can be disabled by setting fieldAttributeQuery.renderNotFoundMessage to false. In
                addition, attribute query contains a property named returnMessageText that can be
                used to configure a message that will display with the results, or a custom message
                in the case no results are found.</para>
            <para>The attribute query class also allows us to hook up a custom query that will be
                invoked to retrieve the additional information. In this case, the developer writes
                the actual code to perform the query (call another service or whatever) and return
                the results. The framework will then take care of triggering the query and handling
                the results (updating the values).</para>
            <para>There is a great deal of flexibility for invoking a custom query method. Let’s
                start with the way that requires the least amount of configuration. First, we need
                to know a little bit about the framework code, in particular one service. The UIF
                invokes a service of type org.kuali.rice.krad.uif.service.ViewHelperService to
                perform building of the view and many other UI related functions. An implementation
                of this service (ViewHelperServiceImpl) carries out this processing. The framework
                allows us to extend this service and declare that one or more views should use the
                custom view helper. This is our gateway for code based customizations. So let’s do
                it! The following sets up a custom view helper service:</para>
            <programlisting>
                package edu.myedu.sample;
public class CustomViewHelperServiceImpl extends ViewHelperServiceImpl {
}</programlisting>
            <para>Next we configure our view to use the custom view helper service. This is done by
                setting the viewHelperServiceClassName property on the view component (the View
                component is covered in complete detail in Chapter 9):</para>
            <programlisting>
&lt;bean id="MyView" parent="Uif-FormView"&gt;
    ...
    &lt;property name="viewHelperServiceClassName" value="edu.myedu.sample.CustomViewHelperServiceImpl"/&gt;
&lt;/bean&gt;
            </programlisting>
            <para>Now we have a place to put our custom query method. The signature of this method
                depends on the query being performed, but there are a few guidelines:<orderedlist>
                    <listitem>
                        <para>The method parameters must correspond to fields on the view (for
                            example, think of the queryFieldMapping which is configured for the
                            automatic query, essentially we will be pulling fields from the view the
                            same way, except passing them as arguments to the method).</para>
                    </listitem>
                    <listitem>
                        <para>The method must return a data object instance for which the return
                            properties can be retrieved, or a list of data objects (in the case of
                            backing a field suggest), or an AttributeQueryResult. The
                            AttributeQueryResult is an object that gets returned back to the client
                            and read to process the results. If the method returns the data object,
                            the framework will build the result object from that. However the result
                            object can be built directly for custom needs.</para>
                    </listitem>
                </orderedlist></para>
        </section>     
    </section>
    <section>
        <title>Other Data and Input Field Properties </title>
        <para></para>
    </section>
    <section>
        <title>Action and Action Field </title>
        <para></para>
    </section>
    <section>
        <title>Space and Space Field </title>
        <para></para>
    </section>
    <section>
        <title>Errors Field </title>
        <para></para>
    </section>
    <section>
        <title>Generic Field </title>
        <para></para>
    </section>
    <section>
        <title>Iframe </title>
        <para></para>
    </section>
    <section>
        <title>Image and Image Field </title>
        <para></para>
    </section>
    <section>
        <title>Link and Link Field </title>
        <para></para>
    </section>
    <section>
        <title>Message Field</title>
        <para></para>
    </section>
</chapter>
