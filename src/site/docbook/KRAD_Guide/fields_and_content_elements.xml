<?xml version='1.0' encoding='UTF-8'?> 
<!--

    Copyright 2005-2012 The Kuali Foundation

    Licensed under the Educational Community License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

    http://www.opensource.org/licenses/ecl2.php

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

-->
<chapter xml:id="fields_and_content_elements" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns="http://docbook.org/ns/docbook"  version="5.0">    
    <title>Fields and Content Elements </title>
    <para>Throughout the next few chapters, we will be taking a detailed look at the component types and the individual components available out of 
        the box with KRAD. We will start small and work our way up to the entire view. By the end of this section, you will be armed with the 
        knowledge you can use to create a wide variety of rich web interfaces!</para>
    <para>In this chapter, we will look at the Content Element and Field component types. These form the palette from which we can paint our page. 
         Content elements are components that will generate an HTML element tag. Their properties are generally used to populate an available 
         attribute of the HMTL tag.  Therefore, if you are familiar with the base set of HTML tag learning these components should be no problem!</para>
    <para>The Field component type is a wrapper. It is associated with the HTML span tag that allows us to enclose one or more elements and treat 
        them as one unit for layout purposes. The field also allows us to declare a label which will be presented with the field block. For 
        convenience, KRAD includes field components that have present elements included. This allows for easily bundling in a group and applying a 
        layout to the set of fields. If a span is not needed, the elements can be directly configured in a group and rendered using the configured
        layout manager.</para>
    <para>So to learn more about what we can do with elements and fields, let’s take a look at each component we have in these types.
    </para>
    <section>
        <title>Field Labels </title>
        <para>One commonly used content element we have is the Label component. As you might have
            guessed, this component will render an HTML Label element. To create a new label
            component, we create a new bean with parent=”Uif-Label”:</para>
        <para>One commonly used content element we have is the Label component. As you might have
            guessed, this component will render an HTML Label element. To create a new label
            component, we create a new bean with parent=”Uif-Label”:</para>
        <programlisting>&lt;bean parent=”Uif-Label” ... &gt;</programlisting>
        <para>The label component is one of the simplest to use since there are few properties which
            it accepts. However, there is one required property – the label text! This is the actual
            text that will appear on the screen as the label. To specify this we can use the
            labelText property:</para>
        <programlisting>&lt;bean parent=”Uif-Label” p:labelText=”Book Title”/&gt;</programlisting>
        <para>In most cases, this is all we need to do! The resulting HTML will look like the
            following:</para>
        <programlisting>&lt;label id="66_label”&gt;Field Label&lt;/label&gt;</programlisting>
        <para>Wait, where did the id come from? Recall that all components extend ComponentBase
            which provides several properties for us, including the id property. If not specified,
            the framework will generate an id for us automatically and use for the element id
            attribute. We can specify a different in either of the following two ways:</para>
        <programlisting>&lt;bean id=”mylabel” parent=”Uif-Label” p:labelText=”Book Title”/&gt;</programlisting>
        <programlisting>&lt;bean parent=”Uif-Label” p:id=”mylabel” p:labelText=”Book Title”/&gt;</programlisting>
        <para>In addition to the id property provided by ComponentBase, there are many others we
            might want to use. Some that might be useful for the label component include title,
            style, and styleClasses.</para>
        <para>When generating a label, it is a best practice (for accessibility reasons) to also
            specify the for attribute. The value for this attribute is the id of the element for
            which the label applies. On the label component, we can configure this value using the
            labelForComponentId property:</para>
        <programlisting>&lt;bean parent=”Uif-Label” p:labelText=”Book Title” p:labelForComponentId=”bookTitle”/&gt;</programlisting>
        <para>However, this is usually not necessary. Instead of creating the label component
            directly, we can let the field component create one for us. The field component provides
            some assistance to us for configuring the label and associating it with a component. To
            understand this, first let’s look at the generic FieldBase class from which all fields
            extend:</para>
        <programlisting>
public class FieldBase extends ComponentBase implements Field {
    private Label fieldLabel;
} </programlisting>
        <para>We see the field base encapsulates a label component. Thus when creating a field
            component we can set the label component properties using the spring nested syntax (dot
            notation)</para>
        <programlisting>&lt;bean parent=”Uif-DataField” p:fieldLabel.labelText=”My Data Field” ... &gt;</programlisting>
        <para>We see the field base encapsulates a label component. Thus when creating a field
            component we can set the label component properties using the spring nested syntax (dot
            notation)</para>
        <programlisting>&lt;bean parent=”Uif-DataField” p:fieldLabel.labelText=”My Data Field” ... &gt;</programlisting>
        <para>Since the label is bundled within the field which is a wrapper for another component,
            the labelForComponentId property will be automatically set (to the id of that wrapped
            component).</para>
        <para>The Field component also provides a more convenient way of setting the label text.
            Instead of using the nested notation of ‘fieldLabel.labelText’, we can simply set the
            ‘label’ property:</para>
        <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” ... &gt;</programlisting>
        <para>The given value will then be set on the label property of the nested label
            component.</para>
        <section>
            <title>Other Label Options</title>
            <para>In addition to the properties described previously, the label component offers the
                following properties:</para>
            <para><emphasis role="bold">renderColon</emphasis> – This indicates whether a colon
                should be rendered after the label text. For example label text of ‘Foo’ will result
                in ‘Foo:’ being rendered.</para>
            <para><emphasis role="bold">requiredMessage</emphasis> – This is a message component
                that will be rendered with the label to indicate the element associated with the
                label (generally a control) is required. By default, the message text is configured
                to be ‘*’ but can be changed on a global or case by case basis:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:label.requiredMessage=”required”/&gt;</programlisting>
            <para>Like all components, the required message will be displayed if its render property
                is true. Therefore we can set the required message to not display as follows:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:label.requiredMessage.render=”false”/&gt;</programlisting>
            <para>However, we typically want to display the required message when the component the label is 
                associated with is required. This is again where our Field component provides value. The 
                field will look at the required property (on all components) of the wrapped component, 
                and if set to true will then set the render property to true for the label’s required message. 
                Likewise if the component’s required property is false, the render property on the required 
                message will be set to false. Therefore these two properties are synced.</para>
            <note>
                <title>Automatic Setting of Properties?</title>
                <para>In this section we have mentioned a few cases where the field component will
                    automatically set values for us based on a condition. Where does this happen?
                    Well in code of course! Besides simply holding the property values for us, the
                    component class can also perform logic which are invoked during the view
                    lifecycle. Therefore if we wanted to change the component behavior, we would
                    need to create a new class and then override the base bean definition as
                    described </para>
            </note>
            <para><emphasis role="bold">requiredMessagePlacement</emphasis> – Along with the
                required message the label component also provides a required message placement
                option. This indicates where the required message should be rendered in relation to
                the label text. The type for this property is
                org.kuali.rice.krad.uif.UifConstants.Position which is an enum for the four possible
                positions (LEFT, TOP, RIGHT, BOTTOM). However in the case of the required message,
                only the LEFT and RIGHT positions are supported.</para>
        </section>
        <section>
            <title>Other Field Label Options</title>
            <para>The field also provides some additional properties that related to the label.
                These are:</para>
            <para><emphasis role="bold">labelPlacement </emphasis>– Similar to the
                requiredMessagePlacement of the label component this property is of type Position.
                It indicates where the label should be placed in relation to the other field content
                (the wrapped component(s)). The LEFT, TOP, or RIGHT position may be
                specified:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:labelPlacement=”LEFT”/&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:labelPlacement=”TOP”/&gt;</programlisting>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:labelPlacement=”RIGHT”/&gt;</programlisting>
            <para>These three configurations are shown in the figure below. </para>
            <figure>
                <title>labelPlacement Options</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/labelPlacement.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para><emphasis role="bold">shortLabel</emphasis> – On the field component we can also
                configure an alternate ‘short’ label. When necessary the short label can be pulled
                instead of the standard ‘long’ label. For example, the table layout manager in KRAD
                will use the short label for the table headers.</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:label=”My Data Field” p:shortLabel=”My Fld”/&gt;</programlisting>
        </section>
        <section>
            <title>Base Beans</title>
            <para>With the various configuration options such as what to render and where, it can
                overwhelming. We certainly do not want to think through each setting for every field
                we create. To help with this, base beans are provided sensible defaults based on the
                label placement. These beans exist for the data field and input field (two most
                commonly used fields). </para>
            <para>Uif-DataField – Default which sets label placement to left, render colon as true,
                and required message placement to right</para>
            <para>Uif-DataField-LabelTop – Sets label placement as top, render colon as false, and
                required message placement to right</para>
            <para>Uif-DataField-LabelRight – Sets label placement to right, render colon as false,
                and required message placement to left</para>
            <para>Similar beans exist for the Uif-InputField. To use one of the label
                configurations, we simply change our parent bean:</para>
            <programlisting>&lt;bean parent=”Uif-DataField-LabelTop” p:labelText=”My Data Field” /&gt;</programlisting>
        </section>
        <section>
            <title>Recap</title>
            <itemizedlist>
                <listitem>
                    <para>The link content element component renders an html label tag</para>
                </listitem>
                <listitem>
                    <para>The text for the label is specified using the <emphasis role="bold"
                        >labelText</emphasis> property</para>
                </listitem>
                <listitem>
                    <para>The <emphasis role="bold">labelForComponentId</emphasis> property on label
                        specifies the component id the label is associated with</para>
                </listitem>
                <listitem>
                    <para>Generally we don’t need to create label components ourselves, but instead
                        configuring them through a field component</para>
                </listitem>
                <listitem>
                    <para>Labels can also include a required message that indicates the field
                        associated with the label is has required input</para>
                </listitem>
                <listitem>
                    <para>The field component will automatically set the for property on the label
                        for us along with setting the required message field component’s render flag
                        to true if the field is required</para>
                </listitem>
                <listitem>
                    <para>On the label component we can specify whether a colon should be added with
                        the <emphasis role="bold">renderColon</emphasis> Boolean</para>
                </listitem>
                <listitem>
                    <para>On the label component we can also specify whether the required message
                        appears to the left or right of the label using the <emphasis role="bold"
                            >requiredMessagePlacement</emphasis> property</para>
                </listitem>
                <listitem>
                    <para>The field component allows us to specify where the label is placed in
                        relation to the field contents. The options are left, top, or right</para>
                </listitem>
                <listitem>
                    <para>The field component allows us to specify a short label that can be used
                        instead of the ‘long’ label by some layout managers (for example the table
                        layout manager)</para>
                </listitem>
                <listitem>
                    <para>Base beans are provided for data and input fields that have different
                        configurations for label. The render colon and requirement message placement
                        properties are set based on the label placement</para>
                </listitem>
            </itemizedlist>
        </section>        
    </section>
    <section>
        <title>Data Fields and Input Fields </title>
        <para>Two fields that are used often in enterprise applications are the DataField and
            InputField. Generally enterprise applications have a large amount of data input and
            output. This IO is performed using an HTML Form. The properties that back the form
            (provide and accept the data) are stored on a model. For our purposes now, we can think
            of the model as a simple JavaBean (more information will be given in the section ‘Data
            Binding’. When we need to display one of these properties using KRAD we configure a
            DataField or InputField.</para>
        <section>
            <title>Data Field</title>
            <para>A Data Field is used to display a property value from the model as read-only. When
                we say read-only, this means the value is displayed as static text on the page and
                the user cannot changes its value. To create a data field we specify a new bean with
                parent=”Uif-DataField”:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” ... &gt;</programlisting>
            <para>When configuring a data field for our view, we must associate it with a property
                on the model object. This is accomplished using the propertyName property. For
                example, suppose we had the following model object:</para>
            <programlisting>
public class BookForm {
  private String bookId;
  private String bookTitle;
  // getters/setters
}
            </programlisting>
            <para>To create a data field for the bookId property, our configuration would be as
                follows:</para>
            <para>&lt;bean parent=”Uif-DataField” p:propertyName=”bookId” p:label=”Book”/&gt;</para>
            <para>the page. Recall from the previous section our data field includes a label element
                and by default is configured to be placed to the left of the field content.
                Therefore the result of this will appear as in the figure below.</para>
            <figure>
                <title>Data Field Label</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="images/dataFieldLabel.png"/>
                    </imageobject>
                </mediaobject>
            </figure>                
            <para>The given property name can be a nested path. For an example of this, suppose now
                our model is the following:</para>
            <programlisting>
public class BookForm {
  private Book book;
  
  // getters/setters
}

public class Book {
  private String bookId;
  private String bookTitle;
}
            </programlisting>
            <para>To display the bookId now, our property name should be “book.bookId”. This is the
                same as doing getBook().getBookId(). More complex situations will be covered in the
                section ‘Data Binding’.</para>            
        </section>
        <section>
            <title>Input Field</title>
            <para>An Input Field extends from the Data Field and gives edit capability. This means
                the user can change the value for the associated property and submit back using the
                HTML form. Values are edited using an HTML control which is represented in KRAD with
                a Control content element. We will learn all about the various types of controls
                later on in this chapter. </para>
            <para>To create a new input field we specify a new bean with
                parent=”Uif-InputField”:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” ... &gt;</programlisting>
            <para>Now since input field is also a data field, we must specify the property it is
                associated with using the propertyName property:</para>
            <programlisting>&lt;bean parent=”Uif-InputField” p:propertyName=”bookId”/&gt;</programlisting>
            <para>Furthermore, since we have an input field and want to allow the user to change the
                value, we need to configure a control component to use. We set the control component
                for the input field using the <emphasis role="bold">control</emphasis>
                property:</para>
            <programlisting>
&lt;bean parent=”Uif-InputField” p:propertyName=”bookId” p:label=”Book Id”&gt;
    &lt;property name=”control”&gt;
    &lt;bean parent=”Uif-TextControl”/&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
            <para>The control component is a new object, not a primitive. Therefore we use a bean or
                ref tag to provide the value. In this example we are using the text control whose
                bean id is ‘Uif-TextControl’. If needed, we could set properties on the text control
                component using the  p namespace or nested property tags.</para>
            <para>In the figure below we see the result of the above input field
                configuration.</para>
            <para>The rendered HTML for our input field will be the following:</para>
            <programlisting>&lt;input id="u66" name="bookId" class="uif-control uif-textControl valid" tabindex="0" type="text" value="" size="30" aria-invalid="false"&gt;</programlisting>
            <para>Where did all these attributes come from? Since we didn’t assign an id, the framework generated 
            one for us and outputted as the element id. Next, the propertyName given for the input field was used 
            as the name attribute on the tag. This is important for binding the data which will be discussed in the 
            section ‘Data Binding’. The ‘Uif-TextControl’ bean that was used for the control property included a 
            default size of ‘30’, and also includes the style classes ‘uif-control’ and ‘uif-textControl’. Finally 
            the framework set a tabindex for us (this happens to be the first field on the page) and added aria markup 
            for accessibility. Don’t worry if this all doesn’t make sense now, we’ll see all these properties many more times!</para>
            <note>
                <title>Data and Input Fields</title>
                <para>Whenever this training manual refers to data field, the same will also apply to 
                    input fields (by inheritance). However the reverse is not always true. </para>
            </note>
        </section>
        <section>
            <title>Default Values</title>
            <para>Through configuration of the data field, we can also initialize the backing
                property of the model. The value specified will then be set as the property value
                when the model is initialized. Chapter 12 will cover how the model gets initialized
                along with other concerns of the lifecycle. In terms of default values, it is just
                important to know the model gets created for a new request to a view (such as a
                request from the portal or other application menu), and once created is reused
                throughout the conversation (series of posts on the same view). Generally for
                initial requests we do not need to perform a lot of business logic. That is, usually
                we just want to display the view for the user to begin completing. Being able to set
                default values that will display on the initial view is convenient in that we don’t
                have to override the controller method to do the same in code.</para>
            <para>There are two properties available on data field that allows us to configure a
                default value. The first is the property ‘defaultValue’ which takes the actual value
                to use. For example, suppose we want to set a default value of ‘2012’ for the
                bookYear property. This would be done as follows:</para>
            <programlisting>&lt;bean parent=”Uif-DataField” p:propertyName=”bookYear” p:defaultValue=”2012”/&gt;</programlisting>
            <para>This is equivalent to code:</para>
            <programlisting>bookForm.setBookYear(“2012”);</programlisting>
            <para>The default value given must be convertible to the property type without a custom
                property editor. </para>
            <note>
                <title>Default Type Conversion</title>
                <para>Spring uses PropertyEditor classes when converting a configured value in the XML 
                    to the type for the property being populated. Furthermore, these are used when formatting 
                    the value between the user interface and a custom editor can be specified on the data field. 
                    As of Rice 2.0, any custom editor is not used to apply the default value. This 
                    is being looked at for a potential enhancement in 2.2.</para>
            </note>
            <para>A very powerful feature we will be looking at later on in this training manual is
                the Spring Expression Language (EL). KRAD allows you to use expressions for most
                component properties, including the defaultValue. There are many things you can do
                with EL, but to give you a taste here are a couple:</para>
        </section>
    </section>
    <section>
        <title>Data Binding </title>
        <para></para>
    </section>
    <section>
        <title>Data Dictionary Backing </title>
        <para></para>
    </section>
    <section>
        <title>Types of Controls </title>
        <para></para>
    </section>
    <section>
        <title>Disabling Controls and Tabbing </title>
        <para></para>
    </section>
    <section>
        <title>Hooking up Lookups and Inquiries </title>
        <para></para>
    </section>
    <section>
        <title>Input Field Messages </title>
        <para></para>
    </section>
    <section>
        <title>Field Queries and Informational Properties </title>
        <para></para>
    </section>
    <section>
        <title>Other Data and Input Field Properties </title>
        <para></para>
    </section>
    <section>
        <title>Action and Action Field </title>
        <para></para>
    </section>
    <section>
        <title>Space and Space Field </title>
        <para></para>
    </section>
    <section>
        <title>Errors Field </title>
        <para></para>
    </section>
    <section>
        <title>Generic Field </title>
        <para></para>
    </section>
    <section>
        <title>Iframe </title>
        <para></para>
    </section>
    <section>
        <title>Image and Image Field </title>
        <para></para>
    </section>
    <section>
        <title>Link and Link Field </title>
        <para></para>
    </section>
    <section>
        <title>Message Field</title>
        <para></para>
    </section>
</chapter>
