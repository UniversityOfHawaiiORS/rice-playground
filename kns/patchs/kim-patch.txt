### Eclipse Workspace Patch 1.0
#P rice
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(working copy)
@@ -1,174 +1,339 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-
-public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
-
-    /**
-     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
-        // by default, there are no restrictions, only if this method is
-        // overridden by a subclass that adds restrictions
-        return new MaintenanceDocumentAuthorizations();
-    }
-
-    /**
-     * 
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-
-        // run the super, let the common flags be set
-        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
-
-        // run the fieldAuthorizations
-        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
-        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
-
-        // if there are any field restrictions for this user, then we need to turn off the
-        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
-        // they certainly cant blanket approve it.
-        if (docAuths.hasAnyFieldRestrictions()) {
-            docActionFlags.setCanBlanketApprove(false);
-        }
-
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-
-        // if a user can't initiate a document of this type then they can't copy one, either
-        if (!canCopy(workflowDocument.getDocumentType(), user)) {
-            docActionFlags.setCanCopy(false);
-        }
-        else {
-            docActionFlags.setCanCopy(document.getAllowsCopy() && (!workflowDocument.stateIsInitiated() && !workflowDocument.stateIsEnroute() && !workflowDocument.stateIsException() && !workflowDocument.stateIsSaved()));
-        }
-
-        return docActionFlags;
-    }
-
-    /**
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public Map getEditMode(Document document, Person user) {
-
-        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
-        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
-            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
-        }
-
-        Map editMode = new HashMap();
-        
-        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
-        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
-
-        // default to view-only, as a safety precaution
-        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-
-        // if the document is cancelled, then its view only
-        if (workflowDocument.stateIsCanceled()) {
-            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-        }
-
-        // if the document is being edited, then its full entry, or if the current user is
-        // the system supervisor
-        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-            if (workflowDocument.userIsInitiator(user)) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
-                
-                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
-                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
-                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
-                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
-                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
-                }
-            }
-        }
-
-        // if the document is in routing, then we have some special rules
-        else if (workflowDocument.stateIsEnroute()) {
-
-            // the person who has the approval request in their Actiong List
-            // should be able to modify the document
-            if (workflowDocument.isApprovalRequested()) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
-            }
-        }
-
-        // save the editmode
-        editMode.put(editModeKey, "TRUE");
-        return editMode;
-    }
-
-    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
-        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
-        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
-        
-        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
-            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
-                if (itemDefinition instanceof MaintainableFieldDefinition) {
-                    String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
-                    if (StringUtils.isNotBlank(displayEditMode)) {
-                        editModes.put(displayEditMode, "TRUE");
-                    }
-                }
-                // TODO: what about MaintainableCollectionDefinition?
-            }
-        }
-    }
-    
-    /**
-     * This method returns whether this document is creating a new entry in the maintenible/underlying table
-     * 
-     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
-     * useful in determining which fields are encrypted
-     * 
-     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
-     * there is uncertainity how documents with this action will actually be implemented
-     * 
-     * @param maintDoc
-     * @param user
-     * @return
-     */
-    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
-        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
-        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
-        
-        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
-        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
-        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
-    }
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.kuali.rice.kim.bo.FieldAttributeSecurity;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.service.IdentityManagementService;
+import org.kuali.rice.kim.service.KIMServiceLocator;
+import org.kuali.rice.kim.util.DocumentAttributeSecurityUtils;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
+import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
+
+	private static IdentityManagementService identityManagementService;
+	private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
+
+    /**
+     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
+        // by default, there are no restrictions, only if this method is
+        // overridden by a subclass that adds restrictions
+    	//return new MaintenanceDocumentAuthorizations();
+    	
+    	MaintenanceDocumentAuthorizations auths = new MaintenanceDocumentAuthorizations();
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+    	String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+    	String documentNumber = document.getDocumentNumber();
+    	String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+    	
+    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
+    	Map<String, FieldAttributeSecurity> restrictionFields = DocumentAttributeSecurityUtils.getRestrictionMaintainableFields(objectEntry);
+    	
+    	Set keys = restrictionFields.keySet();    
+    	Iterator keyIter = keys.iterator();
+        while (keyIter.hasNext()) { 
+           String fullFieldName = (String) keyIter.next(); 
+           FieldAttributeSecurity fieldAttributeSecurity = (FieldAttributeSecurity) restrictionFields.get(fullFieldName);
+           String fieldName = fieldAttributeSecurity.getAttributeName();
+           
+           //TODO:Should use ParameterService.getDetailType to get the componentName
+           String componentName = fieldAttributeSecurity.getBusinessObjectClass().getSimpleName();
+           //TODO: Should use ParameterService getNameSpace to get name space
+           String nameSpaceCode = "KFS-SYS";
+           
+           AttributeSecurity maintainableFieldAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getMaintainableFieldAttributeSecurity();
+           AttributeSecurity  businessObjectAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getBusinessObjectAttributeSecurity();
+           
+           AttributeSet permissionDetails = new AttributeSet();
+       	   permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+       	   permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentType);
+       	   permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	   permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+    	   permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, fieldName);
+    	   permissionDetails.put(KimConstants.KIM_ATTRIB_NAMESPACE_CODE, nameSpaceCode);
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null && maintainableFieldAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+    			   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
+    			   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
+				   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+			   }
+		   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+    			   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
+    			   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isMask()){  
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
+				   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+			   }
+		   }
+    	
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+    			   auths.addHiddenAuthField(fullFieldName);	  
+    		   }
+    	   }   
+
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+				   auths.addHiddenAuthField(fullFieldName);	  
+			   }
+		   }
+  
+        }    	
+    	return auths; 
+    }
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+
+        // run the super, let the common flags be set
+        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
+
+        // run the fieldAuthorizations
+        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
+        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
+
+        // if there are any field restrictions for this user, then we need to turn off the
+        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
+        // they certainly cant blanket approve it.
+        if (docAuths.hasAnyFieldRestrictions()) {
+            docActionFlags.setCanBlanketApprove(false);
+        }
+
+        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+
+        // if a user can't initiate a document of this type then they can't copy one, either
+        if (!canCopy(workflowDocument.getDocumentType(), user)) {
+            docActionFlags.setCanCopy(false);
+        }
+        else {
+            docActionFlags.setCanCopy(document.getAllowsCopy() && (!workflowDocument.stateIsInitiated() && !workflowDocument.stateIsEnroute() && !workflowDocument.stateIsException() && !workflowDocument.stateIsSaved()));
+        }
+
+        return docActionFlags;
+    }
+    
+    /**
+     * 
+     * This method is used to get overall document edit permission
+     * 
+     * @param document
+     * @param user
+     * @return
+     */
+    public boolean getEditDocumentPermission(Document document, Person user){
+    	boolean editPerm = false;
+    	//TODO: Should use ParameterService getNameSpace to get name space
+        String nameSpaceCode = "KR-KNS";
+    	
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+    	String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+    	String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+    	
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentType);
+ 	    permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+ 	    
+ 	   if(getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_DOCUMENT, permissionDetails, null)){
+ 		   editPerm = true;
+	   }
+ 	   
+    	return editPerm;
+    }
+
+    /**
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public Map getEditMode(Document document, Person user) {
+
+        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
+        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
+            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
+        }
+
+        Map editMode = new HashMap();
+        
+        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
+        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
+
+        // default to view-only, as a safety precaution
+        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+
+        // if the document is cancelled, then its view only
+        if (workflowDocument.stateIsCanceled()) {
+            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+        }
+
+        // if the document is being edited, then its full entry, or if the current user is
+        // the system supervisor
+        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+            if (workflowDocument.userIsInitiator(user)) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
+                
+                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
+                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
+                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
+                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
+                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
+                }
+            }
+        }
+
+        // if the document is in routing, then we have some special rules
+        else if (workflowDocument.stateIsEnroute()) {
+
+            // the person who has the approval request in their Actiong List
+            // should be able to modify the document
+            if (workflowDocument.isApprovalRequested()) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
+            }
+        }
+
+        // save the editmode
+        editMode.put(editModeKey, "TRUE");
+        return editMode;
+    }
+
+    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
+        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
+        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
+        
+        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
+            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
+                if (itemDefinition instanceof MaintainableFieldDefinition) {
+                    /*String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
+                    if (StringUtils.isNotBlank(displayEditMode)) {
+                        editModes.put(displayEditMode, "TRUE");
+                    }*/
+                }
+                // TODO: what about MaintainableCollectionDefinition?
+            }
+        }
+    }
+    
+    /**
+     * This method returns whether this document is creating a new entry in the maintenible/underlying table
+     * 
+     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
+     * useful in determining which fields are encrypted
+     * 
+     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
+     * there is uncertainity how documents with this action will actually be implemented
+     * 
+     * @param maintDoc
+     * @param user
+     * @return
+     */
+    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
+        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
+        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
+        
+        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
+        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
+        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
+    }
+    
+	/**
+	 * @return the identityManagementService
+	 */
+	public static IdentityManagementService getIdentityManagementService() {
+		
+		if (identityManagementService == null ) {
+			identityManagementService = KIMServiceLocator.getIdentityManagementService();
+		}
+		return identityManagementService;
+	}
+    
+	
+	/**
+	 * @return the maintenanceDocumentDictionaryService
+	 */
+	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+		
+		if (maintenanceDocumentDictionaryService == null ) {
+			maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+		}
+		return maintenanceDocumentDictionaryService;
+	}
+
+    
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/web/ui/FieldBridge.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/ui/FieldBridge.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/web/ui/FieldBridge.java	(working copy)
@@ -83,15 +83,7 @@
         /* setup security of field (sensitive data) if needed, note this will always be true on old maintainables since
          * maintenanceAction is not set
          */
-        String displayEditMode = definition.getDisplayEditMode();
-        if (StringUtils.isNotBlank(displayEditMode)) {
-
-            field.setSecure(true);
-            field.setDisplayEditMode(displayEditMode);
-            field.setDisplayMask(definition.getDisplayMask());
-
-        }
-
+        //field.setAttributeSecurity(definition.getAttributeSecurity());
     }
 
     /**
Index: impl/src/main/java/org/kuali/rice/kns/util/FieldUtils.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/util/FieldUtils.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/util/FieldUtils.java	(working copy)
@@ -35,6 +35,7 @@
 import org.kuali.rice.kns.datadictionary.control.CurrencyControlDefinition;
 import org.kuali.rice.kns.datadictionary.control.KualiUserControlDefinition;
 import org.kuali.rice.kns.datadictionary.control.LinkControlDefinition;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
 import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
 import org.kuali.rice.kns.exception.UnknownBusinessClassAttributeException;
 import org.kuali.rice.kns.inquiry.Inquirable;
@@ -460,26 +461,7 @@
                     element.setPropertyValue(null);
                 }
                 else if (PropertyUtils.isReadable(bo, propertyName)) {
-                    Object obj = ObjectUtils.getNestedValue(bo, element.getPropertyName());
-                    if (obj != null) {
-                        element.setPropertyValue(obj);
-                    }
-
-                    // set encrypted & masked value if user does not have permission to see real value in UI
-                    if (element.isSecure()) {
-                        try {
-                            if (obj != null && obj.toString().endsWith(EncryptionService.HASH_POST_PREFIX)) {
-                                element.setEncryptedValue(obj.toString());
-                            }
-                            else {
-                                element.setEncryptedValue(KNSServiceLocator.getEncryptionService().encrypt(obj) + EncryptionService.ENCRYPTION_POST_PREFIX);
-                            }
-                        }
-                        catch (GeneralSecurityException e) {
-                            throw new RuntimeException("Unable to encrypt secure field " + e.getMessage());
-                        }
-                        element.setDisplayMaskValue(element.getDisplayMask().maskValue(obj));
-                    }
+                	populateReadableField(element, bo);
                 }
             }
             populatedFields.add(element);
@@ -488,6 +470,33 @@
         return populatedFields;
     }
 
+    public static void populateReadableField(Field field, BusinessObject businessObject){
+        Object obj = ObjectUtils.getNestedValue(businessObject, field.getPropertyName());
+        if (obj != null) {
+        	field.setPropertyValue(obj);
+        }
+        populateSecureField(field, obj);
+    }
+
+    public static void populateSecureField(Field field, Object fieldValue){
+        // set encrypted & masked value if user does not have permission to see real value in UI
+        // element.isSecure() => a non-null AttributeSecurity object is set in the field
+        if (field.isSecure()) {
+            try {
+                if (fieldValue != null && fieldValue.toString().endsWith(EncryptionService.HASH_POST_PREFIX)) {
+                	field.setEncryptedValue(fieldValue.toString());
+                }
+                else {
+                	field.setEncryptedValue(KNSServiceLocator.getEncryptionService().encrypt(fieldValue) + EncryptionService.ENCRYPTION_POST_PREFIX);
+                }
+            }
+            catch (GeneralSecurityException e) {
+                throw new RuntimeException("Unable to encrypt secure field " + e.getMessage());
+            }
+            //field.setDisplayMaskValue(field.getAttributeSecurity().getDisplayMaskValue(fieldValue));
+        }
+    }
+
     /**
      * This method indicates whether or not propertyName refers to a nested attribute.
      *
@@ -777,16 +786,33 @@
 
     public static void applyAuthorization(Field field, MaintenanceDocumentAuthorizations auths) {
 
+    	String fieldName = "";
+    	FieldAuthorization fieldAuth = null;
         // only apply this on the newMaintainable
         if (field.getPropertyName().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE)) {
 
             // get just the actual fieldName, with the document.newMaintainableObject, etc etc removed
-            String fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+            fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
 
             // if the field is restricted somehow
             if (auths.hasAuthFieldRestricted(fieldName)) {
-                FieldAuthorization fieldAuth = auths.getAuthFieldAuthorization(fieldName);
-
+                fieldAuth = auths.getAuthFieldAuthorization(fieldName);
+                
+                if(fieldAuth.isPartiallyMasked()){
+                	field.setSecure(true);
+                	MaskFormatter maskFormatter = fieldAuth.getMaskFormatter();
+                	String displayMaskValue = maskFormatter.maskValue(field.getPropertyValue());
+                	field.setDisplayMaskValue(displayMaskValue);
+                	
+                }
+                
+                if(fieldAuth.isMasked()){
+                	field.setSecure(true);
+                	MaskFormatter maskFormatter = fieldAuth.getMaskFormatter();
+                	String displayMaskValue = maskFormatter.maskValue(field.getPropertyValue());
+                	field.setDisplayMaskValue(displayMaskValue);
+                }
+                
                 // if its an editable field, allow decreasing availability to readonly or hidden
                 if (Field.isInputField(field.getFieldType()) || field.getFieldType().equalsIgnoreCase(Field.CHECKBOX)) {
 
@@ -809,22 +835,24 @@
                 if (field.isReadOnly() && fieldAuth.isHidden()) {
                     field.setFieldType(Field.HIDDEN);
                 }
+                
             }
             // special check for old maintainable - need to ensure that fields hidden on the
             // "new" side are also hidden on the old side
         }
         else if (field.getPropertyName().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE)) {
             // get just the actual fieldName, with the document.oldMaintainableObject, etc etc removed
-            String fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+            fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
             // if the field is restricted somehow
             if (auths.hasAuthFieldRestricted(fieldName)) {
-                FieldAuthorization fieldAuth = auths.getAuthFieldAuthorization(fieldName);
+                fieldAuth = auths.getAuthFieldAuthorization(fieldName);
 
                 if (fieldAuth.isHidden()) {
                     field.setFieldType(Field.HIDDEN);
                 }
             }
         }
+      
     }
 
     /**
Index: impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java	(revision 5212)
+++ impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java	(working copy)
@@ -36,6 +36,7 @@
 	public static final String PERMISSION_PARTIALLY_UNMASK_PROPERTY = "Partially Unmask Property";
 	public static final String PERMISSION_VIEW_PROPERTY = "View Property";
 	public static final String PERMISSION_EDIT_PROPERTY = "Edit Property";
+	public static final String PERMISSION_EDIT_DOCUMENT = "Edit Document";
 	public static final String DOCUMENT_STATUS_PERMISSION_TYPE = "DocumentStatusComponentAttributePermissionType";
 	public static final String KIM_ATTRIB_EDIT_MODE = "Edit Mode";
 	public static final String USER_IS_INITIATOR = "userIsInitiator";
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinitionI.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinitionI.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinitionI.java	(working copy)
@@ -1,26 +1,23 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.datadictionary;
-
-import org.kuali.rice.kns.datadictionary.mask.Mask;
-
-public interface FieldDefinitionI {
-    public String getName();
-    public boolean isReadOnlyAfterAdd();
-    public Mask getDisplayMask();
-    public String getDisplayEditMode();
-
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.datadictionary;
+
+
+public interface FieldDefinitionI {
+    public String getName();
+    public boolean isReadOnlyAfterAdd();
+
+}
Index: web/src/main/webapp/WEB-INF/tags/kr/htmlControlAttribute.tag
===================================================================
--- web/src/main/webapp/WEB-INF/tags/kr/htmlControlAttribute.tag	(revision 4907)
+++ web/src/main/webapp/WEB-INF/tags/kr/htmlControlAttribute.tag	(working copy)
@@ -35,7 +35,7 @@
 <%@ attribute name="encryptValue" required="false"
 			  description="when readOnly or hidden field, boolean to indicate whether the value should
 			  be encrypted and display masked. Defaults to false." %>
-<%@ attribute name="displayMask" required="false"
+<%@ attribute name="displayMaskValue" required="false"
 			  description="when a field is not to be displayed in clear text and encrypted as hidden, the
 			  string to display." %>
 <%@ attribute name="styleClass" required="false"
@@ -109,7 +109,7 @@
             %>
             <html:hidden property="encryptedProperties('${fn:replace(property,'.','_')}')" value="true"/>
             <html:hidden write="false" property="${property}" style="${textStyle}"/>
-            ${displayMask}
+            ${displayMaskValue}
          </c:when>
          <c:otherwise>
          <logic:empty name="KualiForm" property="${property}">
Index: impl/src/main/java/org/kuali/rice/kns/web/ui/Field.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/ui/Field.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/web/ui/Field.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.Map;
 
 import org.apache.commons.lang.StringUtils;
+
 import org.kuali.rice.kns.datadictionary.mask.Mask;
 import org.kuali.rice.kns.lookup.HtmlData;
 import org.kuali.rice.kns.util.KNSConstants;
@@ -54,6 +55,8 @@
     public static final String KUALIUSER = "kualiuser";
     public static final String READONLY = "readOnly";
     public static final String EDITABLE = "editable";
+    public static final String MASKED = "masked";
+    public static final String PARTIALLY_MASKED = "partiallyMasked";
     public static final String LOOKUP_HIDDEN = "lookuphidden";
     public static final String LOOKUP_READONLY = "lookupreadonly";
     public static final String WORKFLOW_WORKGROUP = "workflowworkgroup";
@@ -98,8 +101,10 @@
     private boolean isReadOnly;
     private String lookupParameters;
     private int maxLength;
+    
     private String propertyName;
     private String propertyValue;
+   
     private HtmlData inquiryURL;
     private String propertyPrefix;
     private String quickFinderClassNameImpl;
@@ -117,7 +122,6 @@
     private String personNameAttributeName;
     private String defaultValue = KNSConstants.EMPTY_STRING;
     private boolean keyField;
-    private String displayEditMode;
     private Mask displayMask;
     private String displayMaskValue;
     private String encryptedValue;
@@ -529,7 +533,24 @@
 
         return propertyValue;
     }
+    
+    /**
+     * Gets the displayMaskValue attribute.
+     * 
+     * @return Returns the displayMaskValue.
+     */
+    public String getDisplayMaskValue() {
+        return displayMaskValue;
+    }
 
+    /**
+     * Sets the displayMaskValue attribute value.
+     * 
+     * @param displayMaskValue The displayMaskValue to set.
+     */
+    public void setDisplayMaskValue(String displayMaskValue) {
+        this.displayMaskValue = displayMaskValue;
+    }
 
     /**
      * Gets the propertyPrefix attribute.
@@ -1070,26 +1091,7 @@
         this.keyField = keyField;
     }
 
-
     /**
-     * Gets the displayEditMode attribute.
-     * 
-     * @return Returns the displayEditMode.
-     */
-    public String getDisplayEditMode() {
-        return displayEditMode;
-    }
-
-    /**
-     * Sets the displayEditMode attribute value.
-     * 
-     * @param displayEditMode The displayEditMode to set.
-     */
-    public void setDisplayEditMode(String displayEditMode) {
-        this.displayEditMode = displayEditMode;
-    }
-
-    /**
      * Gets the displayMask attribute.
      * 
      * @return Returns the displayMask.
@@ -1097,35 +1099,8 @@
     public Mask getDisplayMask() {
         return displayMask;
     }
-
+    
     /**
-     * Sets the displayMask attribute value.
-     * 
-     * @param displayMask The displayMask to set.
-     */
-    public void setDisplayMask(Mask displayMask) {
-        this.displayMask = displayMask;
-    }
-
-    /**
-     * Gets the displayMaskValue attribute.
-     * 
-     * @return Returns the displayMaskValue.
-     */
-    public String getDisplayMaskValue() {
-        return displayMaskValue;
-    }
-
-    /**
-     * Sets the displayMaskValue attribute value.
-     * 
-     * @param displayMaskValue The displayMaskValue to set.
-     */
-    public void setDisplayMaskValue(String displayMaskValue) {
-        this.displayMaskValue = displayMaskValue;
-    }
-
-    /**
      * Gets the encryptedValue attribute.
      * 
      * @return Returns the encryptedValue.
@@ -1160,7 +1135,7 @@
     public void setSecure(boolean secure) {
         this.secure = secure;
     }
-
+    
     /**
      * Returns the method name of a function present in the page which should be called
      * when the user tabs away from the field.
@@ -1379,7 +1354,7 @@
     public void setFieldDirectInquiryEnabled(boolean fieldDirectInquiryEnabled) {
         this.fieldDirectInquiryEnabled = fieldDirectInquiryEnabled;
     }
-    
+
 	/**
 	 * @return the fieldInactiveValidValues
 	 */
@@ -1393,5 +1368,5 @@
 	public void setFieldInactiveValidValues(List fieldInactiveValidValues) {
 		this.fieldInactiveValidValues = fieldInactiveValidValues;
 	}
-    
+
 }
\ No newline at end of file
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeSecurity.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeSecurity.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeSecurity.java	(working copy)
@@ -147,4 +147,17 @@
 		}
 	}
 
+	public String getDisplayMaskValue(Object value){
+		String displayMaskValue = "";
+        if(isMask())
+        	displayMaskValue = getMaskFormatter().maskValue(value);
+        else if(isPartialMask())
+        	displayMaskValue = getPartialMaskFormatter().maskValue(value);
+        return displayMaskValue;
+	}
+	
+	public boolean shouldBeEncrypted(){
+		return isMask() || isPartialMask();
+	}
+	
 }
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizations.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizations.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizations.java	(working copy)
@@ -1,175 +1,211 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.log4j.Logger;
-import org.kuali.rice.kns.authorization.FieldAuthorization;
-import org.kuali.rice.kns.web.ui.Field;
-
-/**
- * 
- * This class holds all the information needed to describe the authorization related restrictions for a MaintenanceDocument.
- * 
- * IMPORTANT NOTE: This class defaults to fully editable, if not otherwise specified. So if this class is queried for the status of
- * a field, and the field has not been specified in this class, it will return a FieldAuthorization class populated with the
- * fieldName and EDITABLE.
- * 
- * 
- */
-public class MaintenanceDocumentAuthorizations  implements  Serializable {
-
-    private static final Logger LOG = Logger.getLogger(MaintenanceDocumentAuthorizations.class);
-
-    private Map authFields;
-    private List hiddenSections; // not implemented, does nothing yet
-
-    public MaintenanceDocumentAuthorizations() {
-        authFields = new HashMap();
-        hiddenSections = new ArrayList();
-    }
-
-    /**
-     * 
-     * Returns a collection of all the fields that have non-default authorization restrictions.
-     * 
-     * @return Collection of field names that are restricted
-     * 
-     */
-    public Collection getAuthFieldNames() {
-        return authFields.keySet();
-    }
-
-    /**
-     * 
-     * This method is a convenience method to determine whether there are any restricted fields at all in this
-     * MaintDocAuthorization.
-     * 
-     * If any fields are listed as restricted, this will return true, otherwise it will return false.
-     * 
-     * @return true if any fields restricted, false otherwise
-     * 
-     */
-    public boolean hasAnyFieldRestrictions() {
-
-        boolean anyRestricted = false;
-
-        // walk through each field listed here
-        for (Iterator iter = authFields.keySet().iterator(); iter.hasNext();) {
-            String fieldName = (String) iter.next();
-            FieldAuthorization fieldAuth = getAuthFieldAuthorization(fieldName);
-
-            // if a field is restricted, then we know there are some restricted, so we're done
-            if (fieldAuth.isRestricted()) {
-                return true;
-            }
-        }
-        return anyRestricted;
-    }
-
-    /**
-     * 
-     * This method is a quick way to lookup whether the field has a definition in this authorization. If it isnt defined with some
-     * authorization flag, this returns false.
-     * 
-     * @param fieldName
-     * @return boolean
-     */
-    public boolean hasAuthFieldRestricted(String fieldName) {
-        if (authFields.containsKey(fieldName)) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * 
-     * This method adds a new authorization field instance.
-     * 
-     * @param fieldName
-     * @param authorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE;
-     * 
-     */
-    public void addAuthField(String fieldName, String authorizationFlag) {
-        authFields.put(fieldName, authorizationFlag);
-    }
-
-    /**
-     * This method adds the fieldName specified as Editable.
-     * 
-     * @param fieldName
-     */
-    public void addEditableAuthField(String fieldName) {
-        addAuthField(fieldName, Field.EDITABLE);
-    }
-
-    /**
-     * This method adds the fieldName specified as Read-Only.
-     * 
-     * @param fieldName
-     */
-    public void addReadonlyAuthField(String fieldName) {
-        addAuthField(fieldName, Field.READONLY);
-    }
-
-    /**
-     * This method adds the fieldName specified as Hidden.
-     * 
-     * @param fieldName
-     */
-    public void addHiddenAuthField(String fieldName) {
-        addAuthField(fieldName, Field.HIDDEN);
-    }
-
-    /**
-     * 
-     * Returns a collection of all the sections that have non-default authorization restrictions.
-     * 
-     * @return Collection of section names that are restricted
-     * 
-     */
-    public List getHiddenSectionNames() {
-        return hiddenSections;
-    }
-
-    /**
-     * 
-     * This method returns the authorization setting for the given field name. If the field name is not restricted in any way, a
-     * default full-editable value is returned.
-     * 
-     * @param fieldName - name of field to get authorization restrictions for.
-     * @return a populated FieldAuthorization class for this field
-     * 
-     */
-    public FieldAuthorization getAuthFieldAuthorization(String fieldName) {
-        if (authFields.containsKey(fieldName)) {
-            return new FieldAuthorization(fieldName, (String) authFields.get(fieldName));
-        }
-        else {
-            return new FieldAuthorization(fieldName, Field.EDITABLE);
-        }
-    }
-
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.log4j.Logger;
+import org.kuali.rice.kns.authorization.FieldAuthorization;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+import org.kuali.rice.kns.web.ui.Field;
+
+/**
+ * 
+ * This class holds all the information needed to describe the authorization related restrictions for a MaintenanceDocument.
+ * 
+ * IMPORTANT NOTE: This class defaults to fully editable, if not otherwise specified. So if this class is queried for the status of
+ * a field, and the field has not been specified in this class, it will return a FieldAuthorization class populated with the
+ * fieldName and EDITABLE.
+ * 
+ * 
+ */
+public class MaintenanceDocumentAuthorizations  implements  Serializable {
+
+    private static final Logger LOG = Logger.getLogger(MaintenanceDocumentAuthorizations.class);
+
+    private Map authFields;
+    private Map fieldFormatters;
+    private List hiddenSections; // not implemented, does nothing yet
+
+    public MaintenanceDocumentAuthorizations() {
+        authFields = new HashMap();
+        hiddenSections = new ArrayList();
+    }
+
+    /**
+     * 
+     * Returns a collection of all the fields that have non-default authorization restrictions.
+     * 
+     * @return Collection of field names that are restricted
+     * 
+     */
+    public Collection getAuthFieldNames() {
+        return authFields.keySet();
+    }
+
+    /**
+     * 
+     * This method is a convenience method to determine whether there are any restricted fields at all in this
+     * MaintDocAuthorization.
+     * 
+     * If any fields are listed as restricted, this will return true, otherwise it will return false.
+     * 
+     * @return true if any fields restricted, false otherwise
+     * 
+     */
+    public boolean hasAnyFieldRestrictions() {
+
+        boolean anyRestricted = false;
+
+        // walk through each field listed here
+        for (Iterator iter = authFields.keySet().iterator(); iter.hasNext();) {
+            String fieldName = (String) iter.next();
+            FieldAuthorization fieldAuth = getAuthFieldAuthorization(fieldName);
+
+            // if a field is restricted, then we know there are some restricted, so we're done
+            if (fieldAuth.isRestricted()) {
+                return true;
+            }
+        }
+        return anyRestricted;
+    }
+
+    /**
+     * 
+     * This method is a quick way to lookup whether the field has a definition in this authorization. If it isnt defined with some
+     * authorization flag, this returns false.
+     * 
+     * @param fieldName
+     * @return boolean
+     */
+    public boolean hasAuthFieldRestricted(String fieldName) {
+        if (authFields.containsKey(fieldName)) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * 
+     * This method adds a new authorization field instance.
+     * 
+     * @param fieldName
+     * @param authorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE;
+     * 
+     */
+    public void addAuthField(String fieldName, String authorizationFlag) {
+        authFields.put(fieldName, authorizationFlag);
+    }
+   
+
+    /**
+     * This method adds the fieldName specified as Editable.
+     * 
+     * @param fieldName
+     */
+    public void addEditableAuthField(String fieldName) {
+        addAuthField(fieldName, Field.EDITABLE);
+    }
+
+    /**
+     * This method adds the fieldName specified as Read-Only.
+     * 
+     * @param fieldName
+     */
+    public void addReadonlyAuthField(String fieldName) {
+        addAuthField(fieldName, Field.READONLY);
+    }
+
+    /**
+     * This method adds the fieldName specified as Hidden.
+     * 
+     * @param fieldName
+     */
+    public void addHiddenAuthField(String fieldName) {
+        addAuthField(fieldName, Field.HIDDEN);
+    }
+    
+
+    /**
+     * This method adds the fieldName specified as masked.
+     * 
+     * @param fieldName
+     */
+    public void addMaskedAuthField(String fieldName, MaskFormatter maskFormatter) {
+        addAuthField(fieldName, Field.MASKED);
+        addFieldFormatter(fieldName, maskFormatter);
+        
+    }
+
+    /**
+     * This method adds the fieldName specified as partially masked.
+     * 
+     * @param fieldName
+     */
+    public void addPartiallyMaskedAuthField(String fieldName, MaskFormatter partialMaskFormatter) {
+        addAuthField(fieldName, Field.PARTIALLY_MASKED);
+        addFieldFormatter(fieldName, partialMaskFormatter);
+    }
+    
+ 
+    /**
+     * 
+     * Returns a collection of all the sections that have non-default authorization restrictions.
+     * 
+     * @return Collection of section names that are restricted
+     * 
+     */
+    public List getHiddenSectionNames() {
+        return hiddenSections;
+    }
+
+    /**
+     * 
+     * This method returns the authorization setting for the given field name. If the field name is not restricted in any way, a
+     * default full-editable value is returned.
+     * 
+     * @param fieldName - name of field to get authorization restrictions for.
+     * @return a populated FieldAuthorization class for this field
+     * 
+     */
+    public FieldAuthorization getAuthFieldAuthorization(String fieldName) {
+    	//fieldName.replaceAll("(\\[[0-9]*\\])", "");
+    	if (authFields.containsKey(fieldName)) {
+    		FieldAuthorization fieldAuth = new FieldAuthorization(fieldName, (String) authFields.get(fieldName));
+    		if(fieldFormatters.containsKey(fieldName)){
+    			fieldAuth.setMaskFormatter((MaskFormatter) fieldFormatters.get(fieldName));
+    		}
+    		return fieldAuth;
+        }
+        else {
+            return new FieldAuthorization(fieldName, Field.EDITABLE);
+        }
+    }
+    
+    private void addFieldFormatter(String fieldName, MaskFormatter maskFormatter) {
+    	fieldFormatters.put(fieldName, maskFormatter);
+    }
+    
+}
Index: impl/src/main/java/org/kuali/rice/kim/util/DocumentAttributeSecurityUtils.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/DocumentAttributeSecurityUtils.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kim/util/DocumentAttributeSecurityUtils.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.kim.bo.FieldAttributeSecurity;
 import org.kuali.rice.kns.datadictionary.AttributeDefinition;
+import org.kuali.rice.kns.datadictionary.BusinessObjectEntry;
 import org.kuali.rice.kns.datadictionary.MaintainableCollectionDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
@@ -39,16 +40,15 @@
  */
 public class DocumentAttributeSecurityUtils {
 
-	public static Map<String, FieldAttributeSecurity> getRestrictionMaintainableFields(
-			MaintenanceDocumentEntry objectEntry) {
+	public static Map<String, FieldAttributeSecurity> getRestrictionMaintainableFields(MaintenanceDocumentEntry objectEntry) {
 		List<MaintainableSectionDefinition> maintainableSectionDefinitions = objectEntry
 				.getMaintainableSections();
 		Map<String, FieldAttributeSecurity> fieldAttributeSecurities = new HashMap<String, FieldAttributeSecurity>();
 		for (MaintainableSectionDefinition maintainableSectionDefinition : maintainableSectionDefinitions) {
 			List<MaintainableItemDefinition> maintainableItems = maintainableSectionDefinition
 					.getMaintainableItems();
-			getRestrictionMaintainableFieldList(fieldAttributeSecurities,
-					maintainableItems, null, objectEntry.getDocumentTypeName(), KNSConstants.EMPTY_STRING);
+			fieldAttributeSecurities.putAll(getRestrictionMaintainableFieldList(fieldAttributeSecurities,
+					maintainableItems, objectEntry.getBusinessObjectClass(), objectEntry.getDocumentTypeName(), KNSConstants.EMPTY_STRING));
 		}
 		return fieldAttributeSecurities;
 	}
@@ -56,25 +56,29 @@
 	private static Map<String, FieldAttributeSecurity> getRestrictionMaintainableFieldList(
 			Map<String, FieldAttributeSecurity> returnList, List items, Class boClass,
 			String documentTypeName, String key) {
+		if(boClass==null) return null;
 		for (Object item: items) {
 			if (item instanceof MaintainableFieldDefinition) {
 				MaintainableFieldDefinition maintainableFieldDefinition = (MaintainableFieldDefinition) item;
-				//retrieve attribDef from the DD for the BO (DDS.getDD().getBOE(boClass).getAttributeDefinition(item.getName());
-				AttributeDefinition attributeDefinition = 
-					(KNSServiceLocator.getDataDictionaryService().getDataDictionary().getBusinessObjectEntry(
-							boClass.getName()).getAttributeDefinition(maintainableFieldDefinition.getName()));
-
-				if(maintainableFieldDefinition.getAttributeSecurity()!=null || 
-						(attributeDefinition!=null && attributeDefinition.getAttributeSecurity()!=null)){
-					FieldAttributeSecurity fieldAttributeSecurity = new FieldAttributeSecurity();
-					fieldAttributeSecurity.setMaintainableFieldAttributeSecurity(
-							((MaintainableFieldDefinition) item).getAttributeSecurity());
-					fieldAttributeSecurity.setBusinessObjectAttributeSecurity(attributeDefinition.getAttributeSecurity());
-					fieldAttributeSecurity.setAttributeName(maintainableFieldDefinition.getName());
-					fieldAttributeSecurity.setBusinessObjectClass(boClass);
-					fieldAttributeSecurity.setDocumentTypeName(documentTypeName);
-					returnList.put(
-							(StringUtils.isEmpty(key)?"":key+".")+maintainableFieldDefinition.getName(), fieldAttributeSecurity);
+				BusinessObjectEntry businessObejctEntry = KNSServiceLocator.getDataDictionaryService().getDataDictionary().getBusinessObjectEntry(
+						boClass.getName());
+				if(businessObejctEntry!=null){
+					//retrieve attribDef from the DD for the BO (DDS.getDD().getBOE(boClass).getAttributeDefinition(item.getName());
+					AttributeDefinition attributeDefinition = 
+						businessObejctEntry.getAttributeDefinition(maintainableFieldDefinition.getName());
+	
+					if(maintainableFieldDefinition.getAttributeSecurity()!=null || 
+							(attributeDefinition!=null && attributeDefinition.getAttributeSecurity()!=null)){
+						FieldAttributeSecurity fieldAttributeSecurity = new FieldAttributeSecurity();
+						fieldAttributeSecurity.setMaintainableFieldAttributeSecurity(
+								((MaintainableFieldDefinition) item).getAttributeSecurity());
+						fieldAttributeSecurity.setBusinessObjectAttributeSecurity(attributeDefinition.getAttributeSecurity());
+						fieldAttributeSecurity.setAttributeName(maintainableFieldDefinition.getName());
+						fieldAttributeSecurity.setBusinessObjectClass(boClass);
+						fieldAttributeSecurity.setDocumentTypeName(documentTypeName);
+						returnList.put(
+								(StringUtils.isEmpty(key)?"":key+".")+maintainableFieldDefinition.getName(), fieldAttributeSecurity);
+					}
 				}
 			} else if (item instanceof MaintainableCollectionDefinition) {
 				MaintainableCollectionDefinition maintainableCollectionDefinition = (MaintainableCollectionDefinition) item;
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(revision 5087)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(working copy)
@@ -15,7 +15,10 @@
  */
 package org.kuali.rice.kns.document.authorization;
 
+import java.util.Map;
+
 import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
 import org.kuali.rice.kns.document.MaintenanceDocument;
 
 /**
@@ -35,6 +38,14 @@
      * 
      */
     public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
+    
+    /**
+     * 
+     * @param document
+     * @param user
+     * @return user has permission to edit the document or not
+     */
+    public boolean getEditDocumentPermission(Document document, Person user);
 
 }
 
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinition.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinition.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinition.java	(working copy)
@@ -259,7 +259,6 @@
         this.displayMask = displayMask;
     }
 
-
     public boolean isReadOnlyAfterAdd() {
         return false;
     }
Index: impl/src/main/java/org/kuali/rice/kim/util/InquiryAttributeSecurityUtils.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/InquiryAttributeSecurityUtils.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kim/util/InquiryAttributeSecurityUtils.java	(revision 0)
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2007 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.util;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.bo.FieldAttributeSecurity;
+import org.kuali.rice.kns.datadictionary.AttributeDefinition;
+import org.kuali.rice.kns.datadictionary.BusinessObjectEntry;
+import org.kuali.rice.kns.datadictionary.FieldDefinition;
+import org.kuali.rice.kns.datadictionary.InquiryCollectionDefinition;
+import org.kuali.rice.kns.datadictionary.InquirySectionDefinition;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.util.KNSConstants;
+
+/**
+ * This is a description of what this class does - mpham don't forget to fill
+ * this in.
+ * 
+ * @author Kuali Rice Team (kuali-rice@googlegroups.com)
+ * 
+ */
+public class InquiryAttributeSecurityUtils {
+
+	public static Map<String, FieldAttributeSecurity> getRestrictedInquiryFields(
+			BusinessObjectEntry objectEntry) {
+		List<InquirySectionDefinition> inquirySections = objectEntry
+				.getInquiryDefinition().getInquirySections();
+		Map<String, FieldAttributeSecurity> returnInquiryFieldList = new HashMap<String, FieldAttributeSecurity>();
+		for (InquirySectionDefinition inquirySectionDefinition : inquirySections) {
+			returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(inquirySectionDefinition
+							.getInquiryFields(), objectEntry
+							.getBusinessObjectClass(),
+					KNSConstants.EMPTY_STRING));
+			Map inquiryCollectionDefinition = inquirySectionDefinition
+			.getInquiryCollections();
+			if(inquiryCollectionDefinition != null && !inquiryCollectionDefinition.isEmpty()){
+				returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(inquirySectionDefinition
+						.getInquiryCollections().values(), objectEntry
+						.getBusinessObjectClass(),
+				KNSConstants.EMPTY_STRING));
+			}
+		}
+		return returnInquiryFieldList;
+	}
+
+	public static Map<String, FieldAttributeSecurity> getRestrictedInquiryFieldList(
+			Collection fieldDefinitions, Class boClass, String key) {
+		key = StringUtils.isEmpty(key) ? "" : key + ".";
+		Map<String, FieldAttributeSecurity> returnInquiryFieldList = new HashMap<String, FieldAttributeSecurity>();
+		for (Object fieldDefinition : fieldDefinitions) {
+			if (fieldDefinition instanceof InquiryCollectionDefinition) {
+				InquiryCollectionDefinition collection = (InquiryCollectionDefinition) fieldDefinition;
+				returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(
+						collection.getInquiryCollections(), collection
+								.getBusinessObjectClass(), key
+								+ collection.getAttributeName()));
+				returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(
+						collection.getInquiryFields(), collection
+								.getBusinessObjectClass(), key));
+			} else if (fieldDefinition instanceof FieldDefinition) {
+				FieldDefinition fields = (FieldDefinition) fieldDefinition;
+				AttributeDefinition attributeDefinition = (KNSServiceLocator
+						.getDataDictionaryService().getDataDictionary()
+						.getBusinessObjectEntry(boClass.getName())
+						.getAttributeDefinition(fields.getAttributeName()));
+				if (attributeDefinition != null
+						&& attributeDefinition.getAttributeSecurity() != null) {
+					FieldAttributeSecurity fieldAttributeSecurity = new FieldAttributeSecurity();
+					fieldAttributeSecurity.setAttributeName(fields
+							.getAttributeName());
+					fieldAttributeSecurity.setBusinessObjectClass(boClass);
+					fieldAttributeSecurity
+							.setBusinessObjectAttributeSecurity(attributeDefinition
+									.getAttributeSecurity());
+
+					returnInquiryFieldList.put(key + fields.getAttributeName(),
+							fieldAttributeSecurity);
+				}
+			}
+		}
+		return returnInquiryFieldList;
+	}
+}
Index: web/src/main/webapp/WEB-INF/tags/kr/rowDisplay.tag
===================================================================
--- web/src/main/webapp/WEB-INF/tags/kr/rowDisplay.tag	(revision 5223)
+++ web/src/main/webapp/WEB-INF/tags/kr/rowDisplay.tag	(working copy)
@@ -98,7 +98,7 @@
                 
 			<%-- isFieldSecure determines whether or not the encrypted value should be shown for 
 			non-collections and a similar function for collections --%>
-			<c:set var="isFieldSecure" value="${field.secure && empty KualiForm.editingMode[field.displayEditMode]}" />
+			<c:set var="isFieldSecure" value="${field.secure}" />
 				
 			<%-- textStyle is used to store the style of the field value. i.e. whether or not it 
 			should display as red text. --%>
@@ -168,20 +168,23 @@
 			<c:choose>
 
 				<c:when test="${isFieldSecure and field.fieldType ne field.FILE}">
-					<input type="hidden" name="${field.propertyName}" 
-						value='<c:out value="${field.encryptedValue}"/>' />
+					<!-- hidden -->
+					<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}" 
+						value="${field.encryptedValue}" />
 
 				</c:when>
 
-				<c:when test="${isFieldReadOnly && not isFieldAContainer and field.fieldType ne field.FILE}">
+				<c:when test="${isFieldReadOnly && not isFieldSecure && not isFieldAContainer and field.fieldType ne field.FILE}">
 					<c:choose>
 						<c:when test= "${isInquiry || isLookup}">
-					  		<input type="hidden" name="${field.propertyName}" value='<c:out value="${fieldValue}"/>' />
+							<!-- hidden -->
+					  		<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}" value="${fieldValue}" />
 				  		</c:when>
 				  		<c:otherwise>
 							<c:if test="${not fn:contains(field.propertyName, Constants.MAINTENANCE_OLD_MAINTAINABLE)}">
-								<input type="hidden" name="${field.propertyName}" 
-									   value='<c:out value="${fieldValue}"/>' />
+								<!-- hidden -->
+								<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}" 
+									   value="${fieldValue}" />
 							</c:if>
 						</c:otherwise>
 				  	 </c:choose>
@@ -275,8 +278,9 @@
 			    		     so we'll just render the input parameter, but not display anything.  Of course, inquiries are read only, so there's really no reason
 			    		     to have the input tag for inquiries, but it doesn't cause any harm. --%>
 			    		<%-- prevent the field from being written a 2nd time --%>
-						<input type="hidden" name='${field.propertyName}'
-							value='<c:out value="${isFieldSecure ? field.encryptedValue : fieldValue}"/>' />
+						<!-- hidden -->
+						<html:hidden renderHiddenField="${isLookup}" name='${field.propertyName}'
+							value="${isFieldSecure ? field.encryptedValue : fieldValue}" />
 					</c:if>
 				</c:when>
 					
@@ -320,13 +324,14 @@
 							</c:when>
 
 							<c:otherwise>
-
-								<input type="text" id='${field.propertyName}' name='${field.propertyName}'
-									value='<c:out value="${fieldValue}"/>'
+								<!-- ${onblurcall} ? -->
+								<html:text id='${field.propertyName}' name='${field.propertyName}'
+									value='${fieldValue}'
 									size='${field.size}'
 									maxlength='${field.formattedMaxLength}'
-									style="${textStyle}" ${onblurcall} 
-									class="${field.styleClass }"/>
+									style="${textStyle}" 
+									onblur="${onblurcall}" 
+									styleClass="${field.styleClass }"></html:text>
 						    
 								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
 
@@ -353,14 +358,15 @@
 							</c:when>
 									
 							<c:otherwise>
-									
-								<input type="text" name='${field.propertyName}'
+								<!-- ${onblurcall} ? -->
+								<html:text name='${field.propertyName}'
 									id='${field.propertyName}'
-									value='<c:out value="${fieldValue}"/>'
+									value='${fieldValue}'
 									size='${field.size}'
 									maxlength='${field.maxLength}'
-									style="${textStyle}" ${onblurcall} 
-									class="${field.styleClass}"/>
+									style="${textStyle}"
+									onblur="${onblurcall}" 
+									styleClass="${field.styleClass}"/>
 						    
 								<c:if test="${field.datePicker eq true}">
 											
@@ -412,12 +418,14 @@
 
 							<c:otherwise>
 
-								<textarea id='${field.propertyName}' name='${field.propertyName}'
+								<!-- ${onblurcall} ? -->
+								<input type="textarea" id='${field.propertyName}' name='${field.propertyName}'
 									rows='${field.rows}'
 									cols='${field.cols}'
-									style="${textStyle}" ${onblurcall}
+									style="${textStyle}"
+									onblur="${onblurcall}" 
 									maxlength='${field.maxLength}' ><c:out
-									value="${fieldValue}"/></textarea>
+									value="${fieldValue}"/>
 								
 								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
 
@@ -447,10 +455,14 @@
 									
 							<c:otherwise>
 									
-								<input type="checkbox" id='${field.propertyName}' name="${field.propertyName}" 
-									${field.propertyValue eq 'Yes' || field.propertyValue eq 'YES' ? 'checked="checked"' : ''}
-									${onblurcall} />
-								<input type="hidden" name="${field.propertyName}${Constants.CHECKBOX_PRESENT_ON_FORM_ANNOTATION}" value="present"/>
+								<!--${field.propertyValue eq 'Yes' || field.propertyValue eq 'YES' ? 'checked="checked"' : ''}
+									${onblurcall}? -->
+								<html:checkbox id='${field.propertyName}' 
+									name="${field.propertyName}" 
+									onblur="${onblurcall}" 
+									value='${fieldValue}'/>
+								<!-- hidden -->
+								<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}${Constants.CHECKBOX_PRESENT_ON_FORM_ANNOTATION}" value="present"/>
 									
 							</c:otherwise>
 					
@@ -636,13 +648,15 @@
 							</c:when>
 									
 							<c:otherwise>
-								<input type="text" name='${field.propertyName}'
+								<!-- ${onblurcall} ? -->
+								<html:text name='${field.propertyName}'
 									id='${field.propertyName}'
-									value='<c:out value="${fieldValue}"/>'
+									value='${fieldValue}'
 									size='${field.size}'
 									maxlength='${field.maxLength}'
-									style="${textStyle}" ${onblurcall} 
-									class="${field.styleClass}"/>
+									style="${textStyle}" 
+									onblur="${onblurcall}" 
+									styleClass="${field.styleClass}"/>
 								
 								<!--  adding a lookup here because it goes to workflow as opposed to Kuali -->
 								<kul:workflowWorkgroupLookup fieldConversions="workgroupName:${field.propertyName}" />	
@@ -653,68 +667,69 @@
 					</td>
 				
 				</c:when>
-				
-				<c:when test="${field.fieldType eq field.FILE}">
-					<kul:fieldDefaultLabel isLookup="${isLookup}" isRequired="${field.fieldRequired}" isReadOnly="${isFieldReadOnly}" 
-						cellWidth="${dataCellWidth}%" fieldType="${field.fieldType}" fieldLabel="${field.fieldLabel}" fieldName="${field.propertyName}"/>
-								
-					<td class="grid" width="${dataCellWidth}%">
-						<c:choose>
-							<c:when test="${isFieldReadOnly}">
-								<c:if test="${empty fieldValue}" >
-									<c:out value="<%=((String) request.getAttribute("fileName"))%>" />&nbsp;
-								</c:if>
-								<c:if test="${not empty fieldValue}" >
-									<kul:fieldShowReadOnly field="${field}" addHighlighting="${addHighlighting}" />
-								</c:if>
-							</c:when> 
-									
-							<c:otherwise>
-									<c:choose>
-										<c:when test="${empty fieldValue}" >
-											<c:if test="${isMaintenance}" >
-											<input type="file" name='${field.propertyName}'
-												id='${field.propertyName}' 
-												size='${field.size}'
-												class="${field.styleClass}"/>
-											</c:if>
-										</c:when>
-										<c:otherwise>
-										<div id="replaceDiv" style="display:block;">
-											<html:image property="methodToCall.downloadAttachment" src="${ConfigProperties.kr.externalizable.images.url}clip.gif" alt="download attachment" style="padding:5px" onclick="excludeSubmitRestriction=true"/>
-											<c:out value="${fieldValue}"/>
-	                                    	&nbsp;&nbsp;
-	                                    		                                    	<input type="hidden" name='methodToCall' />
-    										<script type="text/javascript">
-												function replaceAttachment() {
-													excludeSubmitRestriction=true;
-													showHide('replaceFileDiv','replaceDiv');
-													document.forms[0].methodToCall.value='replaceAttachment';
-													submitForm();
-												}
-											</script>
-	                                    	<html:link linkName="replaceAttachment" onclick="javascript: replaceAttachment();" href="" anchor="" property="methodToCall.replaceAttachment">replace</html:link>
-	                                    </div>
-                                    	<div id="replaceFileDiv" valign="middle" style="display:none;">
-				                			<input type="file" name='${field.propertyName}'
-												id='${field.propertyName}' 
-												size='${field.size}'
-												class="${field.styleClass}"/>  
-										</div>
-										</c:otherwise>
-									</c:choose>
-									
-								 	
-								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
-							
-							</c:otherwise>
-					
-						</c:choose>
-						</div>
-					</td>
-				    
-				</c:when>
-									
+				
+				<c:when test="${field.fieldType eq field.FILE}">
+					<kul:fieldDefaultLabel isLookup="${isLookup}" isRequired="${field.fieldRequired}" isReadOnly="${isFieldReadOnly}" 
+						cellWidth="${dataCellWidth}%" fieldType="${field.fieldType}" fieldLabel="${field.fieldLabel}" fieldName="${field.propertyName}"/>
+								
+					<td class="grid" width="${dataCellWidth}%">
+						<c:choose>
+							<c:when test="${isFieldReadOnly}">
+								<c:if test="${empty fieldValue}" >
+									<c:out value="<%=((String) request.getAttribute("fileName"))%>" />&nbsp;
+								</c:if>
+								<c:if test="${not empty fieldValue}" >
+									<kul:fieldShowReadOnly field="${field}" addHighlighting="${addHighlighting}" />
+								</c:if>
+							</c:when> 
+									
+							<c:otherwise>
+									<c:choose>
+										<c:when test="${empty fieldValue}" >
+											<c:if test="${isMaintenance}" >
+											<input type="file" name='${field.propertyName}'
+												id='${field.propertyName}' 
+												size='${field.size}'
+												class="${field.styleClass}"/>
+											</c:if>
+										</c:when>
+										<c:otherwise>
+										<div id="replaceDiv" style="display:block;">
+											<html:image property="methodToCall.downloadAttachment" src="${ConfigProperties.kr.externalizable.images.url}clip.gif" alt="download attachment" style="padding:5px" onclick="excludeSubmitRestriction=true"/>
+											<c:out value="${fieldValue}"/>
+	                                    	&nbsp;&nbsp;
+                           					<!-- hidden -->
+	                                    	<html:hidden renderHiddenField="${isLookup}" name='methodToCall' />
+    										<script type="text/javascript">
+												function replaceAttachment() {
+													excludeSubmitRestriction=true;
+													showHide('replaceFileDiv','replaceDiv');
+													document.forms[0].methodToCall.value='replaceAttachment';
+													submitForm();
+												}
+											</script>
+	                                    	<html:link linkName="replaceAttachment" onclick="javascript: replaceAttachment();" href="" anchor="" property="methodToCall.replaceAttachment">replace</html:link>
+	                                    </div>
+                                    	<div id="replaceFileDiv" valign="middle" style="display:none;">
+				                			<input type="file" name='${field.propertyName}'
+												id='${field.propertyName}' 
+												size='${field.size}'
+												class="${field.styleClass}"/>  
+										</div>
+										</c:otherwise>
+									</c:choose>
+									
+								 	
+								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
+							
+							</c:otherwise>
+					
+						</c:choose>
+						</div>
+					</td>
+				    
+				</c:when>
+									
 				<c:when test="${field.fieldType eq field.LOOKUP_HIDDEN || field.fieldType eq field.LOOKUP_READONLY}">
 			    
 					<kul:fieldDefaultLabel isLookup="${isLookup}" isRequired="${field.fieldRequired}" 
@@ -722,8 +737,8 @@
 						fieldLabel="${field.fieldLabel}" />
 								
 					<td class="grid" width="${dataCellWidth}%">
-								
-						<input type="hidden" name='${field.propertyName}' value='<c:out value="${fieldValue}"/>' />
+						<!-- hidden -->
+						<html:hidden renderHiddenField="${isLookup}" name='${field.propertyName}' value="${fieldValue}" />
 					
 						<c:if test="${field.fieldType eq field.LOOKUP_READONLY}">
 					
Index: impl/src/main/java/org/kuali/rice/kns/authorization/FieldAuthorization.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/authorization/FieldAuthorization.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/authorization/FieldAuthorization.java	(working copy)
@@ -1,278 +1,317 @@
-/*
- * Copyright 2006-2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.authorization;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.kns.web.ui.Field;
-
-/**
- * This class represents the authorization restrictions (or lack of) for a given field.
- * 
- * 
- */
-public class FieldAuthorization {
-
-    private String fieldName;
-    private boolean editable;
-    private boolean viewable;
-
-    /**
-     * Constructs a FieldAuthorization.java.
-     */
-    public FieldAuthorization() {
-        editable = true;
-        viewable = true;
-    }
-
-    /**
-     * 
-     * Constructs a FieldAuthorization.java.
-     * 
-     * @param fieldName - name of field to represent
-     * @param canEdit - true if the field is editable in this context, false otherwise
-     * @param canView - true if thie field is viewable in this context, false otherwise
-     * 
-     */
-    public FieldAuthorization(String fieldName, boolean canEdit, boolean canView) {
-        this.fieldName = fieldName;
-        setEditable(canEdit); // using setters here to run impossible combinations check
-        setViewable(canView);
-    }
-
-    /**
-     * 
-     * Constructs a FieldAuthorization.java.
-     * 
-     * @param fieldName - name of the field to represent
-     * @param fieldAuthorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE
-     * 
-     */
-    public FieldAuthorization(String fieldName, String fieldAuthorizationFlag) {
-
-        // if an invalid flag is passed in, the choke on it
-        if (!fieldAuthorizationFlag.equals(Field.EDITABLE) && !fieldAuthorizationFlag.equals(Field.READONLY) && !fieldAuthorizationFlag.equals(Field.HIDDEN)) {
-            throw new IllegalArgumentException("The only allowable values are Field.HIDDEN, Field.READONLY, and Field.EDITABLE");
-        }
-
-        this.fieldName = fieldName;
-
-        if (fieldAuthorizationFlag.equals(Field.EDITABLE)) {
-            this.editable = true;
-            this.viewable = true;
-        }
-
-        if (fieldAuthorizationFlag.equals(Field.READONLY)) {
-            this.editable = false;
-            this.viewable = true;
-        }
-
-        if (fieldAuthorizationFlag.equals(Field.HIDDEN)) {
-            this.editable = false;
-            this.viewable = false;
-        }
-
-    }
-
-    /**
-     * 
-     * This method returns the correct flag from the Kuali Field object, that corresponds to the particular combination of editable
-     * and viewable set on this object.
-     * 
-     * @return Field.HIDDEN, Field.READONLY, or Field.EDITABLE
-     * 
-     */
-    public String getKualiFieldDisplayFlag() {
-
-        if (!editable && !viewable) {
-            return Field.HIDDEN;
-        }
-        if (!editable && viewable) {
-            return Field.READONLY;
-        }
-        else {
-            return Field.EDITABLE;
-        }
-
-    }
-
-    /**
-     * 
-     * This method returns true if the FieldAuthorization is some kind of restriction, and returns false if it is an editable field.
-     * 
-     * @return boolean
-     * 
-     */
-    public boolean isRestricted() {
-        if (!editable || !viewable) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * 
-     * This method returns true if this authorization prohibits Viewing and Editing, resulting in a hidden field.
-     * 
-     * @return boolean
-     * 
-     */
-    public boolean isHidden() {
-        if (!editable && !viewable) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * 
-     * This method returns true if this authorization prohibits Editing but not Viewing, resulting in a ReadOnly field.
-     * 
-     * @return boolean
-     * 
-     */
-    public boolean isReadOnly() {
-        if (!editable && viewable) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * Gets the editable attribute.
-     * 
-     * @return Returns the editable.
-     */
-    public boolean isEditable() {
-        return editable;
-    }
-
-    /**
-     * Sets the editable attribute value.
-     * 
-     * Note that if editable is being set to true, and the internal value of viewable is false, viewable will be flipped to true, to
-     * avoid impossible combinations of flags.
-     * 
-     * @param editable The editable to set.
-     */
-    public void setEditable(boolean editable) {
-        if (editable && !this.viewable) {
-            this.viewable = true;
-        }
-        this.editable = editable;
-    }
-
-    /**
-     * Gets the fieldName attribute.
-     * 
-     * @return Returns the fieldName.
-     */
-    public String getFieldName() {
-        return fieldName;
-    }
-
-    /**
-     * Sets the fieldName attribute value.
-     * 
-     * @param fieldName The fieldName to set.
-     */
-    public void setFieldName(String fieldName) {
-        this.fieldName = fieldName;
-    }
-
-    /**
-     * Gets the viewable attribute.
-     * 
-     * @return Returns the viewable.
-     */
-    public boolean isViewable() {
-        return viewable;
-    }
-
-    /**
-     * Sets the viewable attribute value.
-     * 
-     * Note that if viewable is being set to false, and the internal value of editable is true, then editable will be silently
-     * flipped to false. This is done to avoid impossible combinations of authorization flags.
-     * 
-     * @param viewable The viewable to set.
-     */
-    public void setViewable(boolean viewable) {
-        if (!viewable && this.editable) {
-            this.editable = false;
-        }
-        this.viewable = viewable;
-    }
-
-    /**
-     * @see java.lang.Object#toString()
-     */
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append(this.fieldName);
-        sb.append(" [");
-        if (this.editable) {
-            sb.append("editable");
-        }
-        else {
-            sb.append("not editable");
-        }
-        sb.append(",");
-        if (this.viewable) {
-            sb.append("viewable");
-        }
-        else {
-            sb.append("not viewable");
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    public boolean equals(Object obj) {
-        boolean equal = false;
-
-        if (obj != null) {
-            if (this.getClass().equals(obj.getClass())) {
-                FieldAuthorization other = (FieldAuthorization) obj;
-
-                if (StringUtils.equals(this.fieldName, other.getFieldName())) {
-                    if (this.editable == other.isEditable() && this.viewable == other.isViewable()) {
-                        equal = true;
-                    }
-                }
-            }
-        }
-
-        return equal;
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    public int hashCode() {
-        return toString().hashCode();
-    }
-
-
-}
+/*
+ * Copyright 2006-2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.authorization;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kns.web.ui.Field;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+
+/**
+ * This class represents the authorization restrictions (or lack of) for a given field.
+ * 
+ * 
+ */
+public class FieldAuthorization {
+
+    private String fieldName;
+    private boolean editable;
+    private boolean viewable;
+    private boolean masked;
+    private boolean partiallyMasked;
+    private MaskFormatter maskFormatter;
+    /**
+     * Constructs a FieldAuthorization.java.
+     */
+    public FieldAuthorization() {
+        editable = true;
+        viewable = true;
+    }
+
+    /**
+     * 
+     * Constructs a FieldAuthorization.java.
+     * 
+     * @param fieldName - name of field to represent
+     * @param canEdit - true if the field is editable in this context, false otherwise
+     * @param canView - true if thie field is viewable in this context, false otherwise
+     * 
+     */
+    public FieldAuthorization(String fieldName, boolean canEdit, boolean canView) {
+        this.fieldName = fieldName;
+        setEditable(canEdit); // using setters here to run impossible combinations check
+        setViewable(canView);
+    }
+    
+    /**
+     * 
+     * Constructs a FieldAuthorization.java.
+     * 
+     * @param fieldName - name of the field to represent
+     * @param fieldAuthorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE
+     */
+    public FieldAuthorization(String fieldName, String fieldAuthorizationFlag) {
+        // if an invalid flag is passed in, the choke on it
+        if (!fieldAuthorizationFlag.equals(Field.EDITABLE) && !fieldAuthorizationFlag.equals(Field.READONLY) 
+        		&& !fieldAuthorizationFlag.equals(Field.HIDDEN) && !fieldAuthorizationFlag.equals(Field.MASKED)
+        		&& !fieldAuthorizationFlag.equals(Field.PARTIALLY_MASKED)) {
+            throw new IllegalArgumentException("The only allowable values are " +
+            		"Field.HIDDEN, Field.READONLY, Field.EDITABLE, Field.MASKED and Field.PARTIALLY_MASKED");
+        }
+
+        this.fieldName = fieldName;
+
+        if (fieldAuthorizationFlag.equals(Field.EDITABLE)) {
+            this.editable = true;
+            this.viewable = true;
+        } else if (fieldAuthorizationFlag.equals(Field.READONLY)) {
+            this.editable = false;
+            this.viewable = true;
+        } else if (fieldAuthorizationFlag.equals(Field.HIDDEN)) {
+            this.editable = false;
+            this.viewable = false;
+        } else if(fieldAuthorizationFlag.equals(Field.MASKED)){
+			this.masked = true;
+			this.viewable = true;
+			this.editable = false;
+		} else if(fieldAuthorizationFlag.equals(Field.PARTIALLY_MASKED)){
+			this.partiallyMasked = true;
+			this.viewable = true;
+			this.editable = false;
+		}
+    }
+
+    /**
+     * 
+     * This method returns the correct flag from the Kuali Field object, that corresponds to the particular combination of editable
+     * and viewable set on this object.
+     * 
+     * @return Field.HIDDEN, Field.READONLY, or Field.EDITABLE
+     * 
+     */
+    public String getKualiFieldDisplayFlag() {
+
+        if (!editable && !viewable) {
+            return Field.HIDDEN;
+        }
+        if (!editable && viewable) {
+            return Field.READONLY;
+        }
+        else {
+            return Field.EDITABLE;
+        }
+
+    }
+
+    /**
+     * 
+     * This method returns true if the FieldAuthorization is some kind of restriction, and returns false if it is an editable field.
+     * 
+     * @return boolean
+     * 
+     */
+    public boolean isRestricted() {
+        if (!editable || !viewable) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * 
+     * This method returns true if this authorization prohibits Viewing and Editing, resulting in a hidden field.
+     * 
+     * @return boolean
+     * 
+     */
+    public boolean isHidden() {
+        if (!editable && !viewable) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * 
+     * This method returns true if this authorization prohibits Editing but not Viewing, resulting in a ReadOnly field.
+     * 
+     * @return boolean
+     * 
+     */
+    public boolean isReadOnly() {
+        if (!editable && viewable) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * Gets the editable attribute.
+     * 
+     * @return Returns the editable.
+     */
+    public boolean isEditable() {
+        return editable;
+    }
+
+    /**
+     * Sets the editable attribute value.
+     * 
+     * Note that if editable is being set to true, and the internal value of viewable is false, viewable will be flipped to true, to
+     * avoid impossible combinations of flags.
+     * 
+     * @param editable The editable to set.
+     */
+    public void setEditable(boolean editable) {
+        if (editable && !this.viewable) {
+            this.viewable = true;
+        }
+        this.editable = editable;
+    }
+
+    /**
+     * Gets the fieldName attribute.
+     * 
+     * @return Returns the fieldName.
+     */
+    public String getFieldName() {
+        return fieldName;
+    }
+
+    /**
+     * Sets the fieldName attribute value.
+     * 
+     * @param fieldName The fieldName to set.
+     */
+    public void setFieldName(String fieldName) {
+        this.fieldName = fieldName;
+    }
+
+    /**
+     * Gets the viewable attribute.
+     * 
+     * @return Returns the viewable.
+     */
+    public boolean isViewable() {
+        return viewable;
+    }
+
+    /**
+     * Sets the viewable attribute value.
+     * 
+     * Note that if viewable is being set to false, and the internal value of editable is true, then editable will be silently
+     * flipped to false. This is done to avoid impossible combinations of authorization flags.
+     * 
+     * @param viewable The viewable to set.
+     */
+    public void setViewable(boolean viewable) {
+        if (!viewable && this.editable) {
+            this.editable = false;
+        }
+        this.viewable = viewable;
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(this.fieldName);
+        sb.append(" [");
+        if (this.editable) {
+            sb.append("editable");
+        }
+        else {
+            sb.append("not editable");
+        }
+        sb.append(",");
+        if (this.viewable) {
+            sb.append("viewable");
+        }
+        else {
+            sb.append("not viewable");
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals(Object obj) {
+        boolean equal = false;
+
+        if (obj != null) {
+            if (this.getClass().equals(obj.getClass())) {
+                FieldAuthorization other = (FieldAuthorization) obj;
+
+                if (StringUtils.equals(this.fieldName, other.getFieldName())) {
+                    if (this.editable == other.isEditable() && this.viewable == other.isViewable()) {
+                        equal = true;
+                    }
+                }
+            }
+        }
+
+        return equal;
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode() {
+        return toString().hashCode();
+    }
+
+	/**
+	 * @return the masked
+	 */
+	public boolean isMasked() {
+		return this.masked;
+	}
+
+	/**
+	 * @return the partiallyMasked
+	 */
+	public boolean isPartiallyMasked() {
+		return this.partiallyMasked;
+	}
+
+	public boolean shouldBeEncrypted(){
+		return isMasked() || isPartiallyMasked();
+	}
+
+	/**
+	 * @return the maskFormatter
+	 */
+	public MaskFormatter getMaskFormatter() {
+		return this.maskFormatter;
+	}
+
+	/**
+	 * @param maskFormatter the maskFormatter to set
+	 */
+	public void setMaskFormatter(MaskFormatter maskFormatter) {
+		this.maskFormatter = maskFormatter;
+	}
+	
+	
+}
Index: impl/src/main/java/org/kuali/rice/kns/maintenance/KualiMaintainableImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/maintenance/KualiMaintainableImpl.java	(revision 5223)
+++ impl/src/main/java/org/kuali/rice/kns/maintenance/KualiMaintainableImpl.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.commons.beanutils.PropertyUtils;
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.core.service.EncryptionService;
+import org.kuali.rice.kns.authorization.FieldAuthorization;
 import org.kuali.rice.kns.bo.BusinessObject;
 import org.kuali.rice.kns.bo.BusinessObjectRelationship;
 import org.kuali.rice.kns.bo.DocumentHeader;
@@ -38,11 +39,10 @@
 import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
-import org.kuali.rice.kns.document.Document;
 import org.kuali.rice.kns.document.MaintenanceDocument;
 import org.kuali.rice.kns.document.MaintenanceLock;
-import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
-import org.kuali.rice.kns.exception.KualiException;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
 import org.kuali.rice.kns.lookup.LookupUtils;
 import org.kuali.rice.kns.service.BusinessObjectDictionaryService;
 import org.kuali.rice.kns.service.BusinessObjectMetaDataService;
@@ -51,7 +51,6 @@
 import org.kuali.rice.kns.service.KNSServiceLocator;
 import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
 import org.kuali.rice.kns.service.PersistenceStructureService;
-import org.kuali.rice.kim.service.PersonService;
 import org.kuali.rice.kns.util.FieldUtils;
 import org.kuali.rice.kns.util.GlobalVariables;
 import org.kuali.rice.kns.util.InactiveRecordsHidingUtils;
@@ -190,6 +189,7 @@
         return cachedValues;
     }
 
+
     /**
      * Special hidden parameters are set on the maintenance jsp starting with a prefix that tells us which fields have been
      * encrypted. This field finds the those parameters in the map, whose value gives us the property name that has an encrypted
@@ -198,7 +198,7 @@
      * @param fieldValues - possibly with encrypted values
      * @return Map fieldValues - with no encrypted values
      */
-    private Map decryptEncryptedData(Map fieldValues, Document maintenanceDocument) {
+    private Map decryptEncryptedData(Map fieldValues, MaintenanceDocument maintenanceDocument) {
     	try {
 	        for (Iterator iter = fieldValues.keySet().iterator(); iter.hasNext();) {
 	                String fieldName = (String) iter.next();
@@ -228,24 +228,30 @@
         return fieldValues;
     }
 
-    private boolean shouldFieldBeEncrypted(Document maintenanceDocument, String fieldName){
-    	DocumentAuthorizer authorizer = KNSServiceLocator.getDocumentAuthorizationService().getDocumentAuthorizer(maintenanceDocument);
-    	Map editMap = authorizer.getEditMode(maintenanceDocument, GlobalVariables.getUserSession().getPerson());
-    	String displayEditMode = getDisplayEditMode(maintenanceDocument, fieldName);
-    	// Non-blank displayEditMode implies that this field should be encrypted, if the user does not have appropriate permissions
+    private boolean shouldFieldBeEncrypted(MaintenanceDocument maintenanceDocument, String fieldName){
+    	MaintenanceDocumentAuthorizer authorizer = (MaintenanceDocumentAuthorizer)
+    		KNSServiceLocator.getDocumentAuthorizationService().getDocumentAuthorizer(maintenanceDocument);
+    	MaintenanceDocumentAuthorizations auths = 
+    		authorizer.getFieldAuthorizations(maintenanceDocument, GlobalVariables.getUserSession().getPerson());
+    	// If the user does not have appropriate permissions, a non-blank displayEditMode implies that this field should be encrypted
     	// If the logged in user has the permission to view or edit this field, 
-    	// editMap will have an entry corresponding to displayEditMode, in which case, the field value received will not be encrypted 
-    	if(StringUtils.isNotBlank(displayEditMode) && (editMap==null || !editMap.containsKey(displayEditMode)))
-    		return true;
+    	// editMap will have an entry corresponding to displayEditMode, in which case, the field value received will not be encrypted
+    	// The corresponding value in editMap actually does not matter;
+    	// just the presence of the displayEditMode inside that map is enough.
+    	// Note: this "if" stmt is same as "${field.secure && empty KualiForm.editingMode[field.displayEditMode]}" of rowDisplay.jsp
+    	if(auths!=null && auths.hasAuthFieldRestricted(fieldName)){
+    		FieldAuthorization fieldAuth = auths.getAuthFieldAuthorization(fieldName);
+    		return fieldAuth.shouldBeEncrypted();
+    	}
     	return false;
     }
     
-    private String getDisplayEditMode(Document maintenanceDocument, String fieldName){
+    /*private String getDisplayEditMode(Document maintenanceDocument, String fieldName){
     	String docTypeName = maintenanceDocument.getDocumentHeader().getWorkflowDocument().getDocumentType();
     	MaintainableFieldDefinition fieldDefinition =
     		KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableField(docTypeName, fieldName);
     	return fieldDefinition==null?null:fieldDefinition.getDisplayEditMode();
-	}
+	}*/
     
     /**
      * Calls method to get all the core sections for the business object defined in the data dictionary. Then determines if the bo
@@ -1091,4 +1097,4 @@
     }
 
 	
-}
+}
