### Eclipse Workspace Patch 1.0
#P rice
Index: impl/src/main/java/org/kuali/rice/kns/util/FieldUtils.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/util/FieldUtils.java	(revision 5311)
+++ impl/src/main/java/org/kuali/rice/kns/util/FieldUtils.java	(working copy)
@@ -35,6 +35,7 @@
 import org.kuali.rice.kns.datadictionary.control.CurrencyControlDefinition;
 import org.kuali.rice.kns.datadictionary.control.KualiUserControlDefinition;
 import org.kuali.rice.kns.datadictionary.control.LinkControlDefinition;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
 import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
 import org.kuali.rice.kns.exception.UnknownBusinessClassAttributeException;
 import org.kuali.rice.kns.inquiry.Inquirable;
@@ -460,26 +461,7 @@
                     element.setPropertyValue(null);
                 }
                 else if (PropertyUtils.isReadable(bo, propertyName)) {
-                    Object obj = ObjectUtils.getNestedValue(bo, element.getPropertyName());
-                    if (obj != null) {
-                        element.setPropertyValue(obj);
-                    }
-
-                    // set encrypted & masked value if user does not have permission to see real value in UI
-                    if (element.isSecure()) {
-                        try {
-                            if (obj != null && obj.toString().endsWith(EncryptionService.HASH_POST_PREFIX)) {
-                                element.setEncryptedValue(obj.toString());
-                            }
-                            else {
-                                element.setEncryptedValue(KNSServiceLocator.getEncryptionService().encrypt(obj) + EncryptionService.ENCRYPTION_POST_PREFIX);
-                            }
-                        }
-                        catch (GeneralSecurityException e) {
-                            throw new RuntimeException("Unable to encrypt secure field " + e.getMessage());
-                        }
-                        element.setDisplayMaskValue(element.getDisplayMask().maskValue(obj));
-                    }
+                	populateReadableField(element, bo);
                 }
             }
             populatedFields.add(element);
@@ -488,6 +470,33 @@
         return populatedFields;
     }
 
+    public static void populateReadableField(Field field, BusinessObject businessObject){
+        Object obj = ObjectUtils.getNestedValue(businessObject, field.getPropertyName());
+        if (obj != null) {
+        	field.setPropertyValue(obj);
+        }
+        populateSecureField(field, obj);
+    }
+
+    public static void populateSecureField(Field field, Object fieldValue){
+        // set encrypted & masked value if user does not have permission to see real value in UI
+        // element.isSecure() => a non-null AttributeSecurity object is set in the field
+        if (field.isSecure()) {
+            try {
+                if (fieldValue != null && fieldValue.toString().endsWith(EncryptionService.HASH_POST_PREFIX)) {
+                	field.setEncryptedValue(fieldValue.toString());
+                }
+                else {
+                	field.setEncryptedValue(KNSServiceLocator.getEncryptionService().encrypt(fieldValue) + EncryptionService.ENCRYPTION_POST_PREFIX);
+                }
+            }
+            catch (GeneralSecurityException e) {
+                throw new RuntimeException("Unable to encrypt secure field " + e.getMessage());
+            }
+            //field.setDisplayMaskValue(field.getAttributeSecurity().getDisplayMaskValue(fieldValue));
+        }
+    }
+
     /**
      * This method indicates whether or not propertyName refers to a nested attribute.
      *
@@ -777,16 +786,33 @@
 
     public static void applyAuthorization(Field field, MaintenanceDocumentAuthorizations auths) {
 
+    	String fieldName = "";
+    	FieldAuthorization fieldAuth = null;
         // only apply this on the newMaintainable
         if (field.getPropertyName().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE)) {
 
             // get just the actual fieldName, with the document.newMaintainableObject, etc etc removed
-            String fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+            fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
 
             // if the field is restricted somehow
             if (auths.hasAuthFieldRestricted(fieldName)) {
-                FieldAuthorization fieldAuth = auths.getAuthFieldAuthorization(fieldName);
-
+                fieldAuth = auths.getAuthFieldAuthorization(fieldName);
+                
+                if(fieldAuth.isPartiallyMasked()){
+                	field.setSecure(true);
+                	MaskFormatter maskFormatter = fieldAuth.getMaskFormatter();
+                	String displayMaskValue = maskFormatter.maskValue(field.getPropertyValue());
+                	field.setDisplayMaskValue(displayMaskValue);
+                	
+                }
+                
+                if(fieldAuth.isMasked()){
+                	field.setSecure(true);
+                	MaskFormatter maskFormatter = fieldAuth.getMaskFormatter();
+                	String displayMaskValue = maskFormatter.maskValue(field.getPropertyValue());
+                	field.setDisplayMaskValue(displayMaskValue);
+                }
+                
                 // if its an editable field, allow decreasing availability to readonly or hidden
                 if (Field.isInputField(field.getFieldType()) || field.getFieldType().equalsIgnoreCase(Field.CHECKBOX)) {
 
@@ -809,22 +835,24 @@
                 if (field.isReadOnly() && fieldAuth.isHidden()) {
                     field.setFieldType(Field.HIDDEN);
                 }
+                
             }
             // special check for old maintainable - need to ensure that fields hidden on the
             // "new" side are also hidden on the old side
         }
         else if (field.getPropertyName().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE)) {
             // get just the actual fieldName, with the document.oldMaintainableObject, etc etc removed
-            String fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+            fieldName = field.getPropertyName().substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
             // if the field is restricted somehow
             if (auths.hasAuthFieldRestricted(fieldName)) {
-                FieldAuthorization fieldAuth = auths.getAuthFieldAuthorization(fieldName);
+                fieldAuth = auths.getAuthFieldAuthorization(fieldName);
 
                 if (fieldAuth.isHidden()) {
                     field.setFieldType(Field.HIDDEN);
                 }
             }
         }
+      
     }
 
     /**
@@ -1018,13 +1046,12 @@
     
     public static List createAndPopulateFieldsForLookup(List<String> lookupFieldAttributeList, List<String> readOnlyFieldsList, Class businessObjectClass) throws InstantiationException, IllegalAccessException {
         List<Field> fields = new ArrayList<Field>();
-        for( String attributeName : lookupFieldAttributeList )
-        {
+        for (Iterator iter = lookupFieldAttributeList.iterator(); iter.hasNext();) {
+            String attributeName = (String) iter.next();
             Field field = FieldUtils.getPropertyField(businessObjectClass, attributeName, true);
 
             BusinessObject newBusinessObjectInstance;
-            if (ExternalizableBusinessObjectUtils.isExternalizableBusinessObjectInterface(businessObjectClass)) 
-            {
+            if (ExternalizableBusinessObjectUtils.isExternalizableBusinessObjectInterface(businessObjectClass)) {
             	ModuleService moduleService = KNSServiceLocator.getKualiModuleService().getResponsibleModuleService(businessObjectClass);
             	newBusinessObjectInstance = (BusinessObject) moduleService.createNewObjectFromExternalizableClass(businessObjectClass);
             }
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinitionI.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinitionI.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinitionI.java	(working copy)
@@ -1,26 +1,23 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.datadictionary;
-
-import org.kuali.rice.kns.datadictionary.mask.Mask;
-
-public interface FieldDefinitionI {
-    public String getName();
-    public boolean isReadOnlyAfterAdd();
-    public Mask getDisplayMask();
-    public String getDisplayEditMode();
-
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.datadictionary;
+
+
+public interface FieldDefinitionI {
+    public String getName();
+    public boolean isReadOnlyAfterAdd();
+
+}
Index: impl/src/main/java/org/kuali/rice/kns/lookup/AbstractLookupableHelperServiceImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/lookup/AbstractLookupableHelperServiceImpl.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/lookup/AbstractLookupableHelperServiceImpl.java	(working copy)
@@ -1,1137 +1,1146 @@
-/*
- * Copyright 2006-2007 The Kuali Foundation.
- *
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.opensource.org/licenses/ecl1.php
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.lookup;
-
-import java.security.GeneralSecurityException;
-import java.sql.Date;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.core.service.EncryptionService;
-import org.kuali.rice.kns.bo.BusinessObject;
-import org.kuali.rice.kns.bo.PersistableBusinessObject;
-import org.kuali.rice.kns.datadictionary.mask.Mask;
-import org.kuali.rice.kns.exception.ValidationException;
-import org.kuali.rice.kns.inquiry.Inquirable;
-import org.kuali.rice.kns.lookup.HtmlData.AnchorHtmlData;
-import org.kuali.rice.kns.lookup.HtmlData.InputHtmlData;
-import org.kuali.rice.kns.service.AuthorizationService;
-import org.kuali.rice.kns.service.BusinessObjectDictionaryService;
-import org.kuali.rice.kns.service.BusinessObjectMetaDataService;
-import org.kuali.rice.kns.service.BusinessObjectService;
-import org.kuali.rice.kns.service.DataDictionaryService;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.KualiConfigurationService;
-import org.kuali.rice.kns.service.LookupService;
-import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
-import org.kuali.rice.kns.service.PersistenceStructureService;
-import org.kuali.rice.kns.service.SequenceAccessorService;
-import org.kuali.rice.kim.service.KIMServiceLocator;
-import org.kuali.rice.kim.service.PersonService;
-import org.kuali.rice.kns.util.FieldUtils;
-import org.kuali.rice.kns.util.GlobalVariables;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.util.ObjectUtils;
-import org.kuali.rice.kns.util.RiceKeyConstants;
-import org.kuali.rice.kns.util.UrlFactory;
-import org.kuali.rice.kns.util.cache.CopiedObject;
-import org.kuali.rice.kns.web.comparator.CellComparatorHelper;
-import org.kuali.rice.kns.web.format.BooleanFormatter;
-import org.kuali.rice.kns.web.format.CollectionFormatter;
-import org.kuali.rice.kns.web.format.DateFormatter;
-import org.kuali.rice.kns.web.format.Formatter;
-import org.kuali.rice.kns.web.struts.form.LookupForm;
-import org.kuali.rice.kns.web.struts.form.MultipleValueLookupForm;
-import org.kuali.rice.kns.web.ui.Column;
-import org.kuali.rice.kns.web.ui.ResultRow;
-import org.kuali.rice.kns.web.ui.Row;
-
-/**
- * This class declares many of the common spring injected properties, the get/set-ers for them,
- * and some common util methods that require the injected services
- */
-public abstract class AbstractLookupableHelperServiceImpl implements LookupableHelperService {
-
-    protected static final String TITLE_RETURN_URL_PREPENDTEXT_PROPERTY = "title.return.url.value.prependtext";
-    protected static final String TITLE_ACTION_URL_PREPENDTEXT_PROPERTY = "title.action.url.value.prependtext";
-    protected static final String ACTION_URLS_CHILDREN_SEPARATOR = "&nbsp;|&nbsp;";
-    protected static final String ACTION_URLS_CHILDREN_STARTER = "&nbsp;[";
-    protected static final String ACTION_URLS_CHILDREN_END = "]";
-    protected static final String ACTION_URLS_SEPARATOR = "&nbsp;&nbsp;";
-    
-    protected static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(AbstractLookupableHelperServiceImpl.class);
-
-    private Class businessObjectClass;
-    private Map parameters;
-    private BusinessObjectDictionaryService businessObjectDictionaryService;
-    private BusinessObjectMetaDataService businessObjectMetaDataService;
-    private DataDictionaryService dataDictionaryService;
-    private PersistenceStructureService persistenceStructureService;
-    private EncryptionService encryptionService;
-    private List<String> readOnlyFieldsList;
-    private String backLocation;
-    private String docFormKey;
-    private Map fieldConversions;
-    private LookupService lookupService;
-    private org.kuali.rice.kim.service.PersonService personService;
-    private List<Row> rows;
-    private String referencesToRefresh;
-    private SequenceAccessorService sequenceAccessorService;
-    private BusinessObjectService businessObjectService;
-    private LookupResultsService lookupResultsService;
-    private String docNum;
-
-    /**
-	 * @return the docNum
-	 */
-	public String getDocNum() {
-		return this.docNum;
-	}
-
-	/**
-	 * @param docNum the docNum to set
-	 */
-	public void setDocNum(String docNum) {
-		this.docNum = docNum;
-	}
-
-	public AbstractLookupableHelperServiceImpl() {
-        rows = null;
-    }
-
-    /**
-     * This implementation always returns false.
-     *
-     * @see org.kuali.core.lookup.LookupableHelperService#checkForAdditionalFields(java.util.Map)
-     */
-    public boolean checkForAdditionalFields(Map fieldValues) {
-        return false;
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#getBusinessObjectClass()
-     */
-    public Class getBusinessObjectClass() {
-        return businessObjectClass;
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#setBusinessObjectClass(java.lang.Class)
-     */
-    public void setBusinessObjectClass(Class businessObjectClass) {
-        this.businessObjectClass = businessObjectClass;
-        setRows();
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#getParameters()
-     */
-    public Map getParameters() {
-        return parameters;
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#setParameters(java.util.Map)
-     */
-    public void setParameters(Map parameters) {
-        this.parameters = parameters;
-    }
-
-    /**
-     * Gets the dataDictionaryService attribute.
-     * @return Returns the dataDictionaryService.
-     */
-    public DataDictionaryService getDataDictionaryService() {
-        return dataDictionaryService != null ? dataDictionaryService : KNSServiceLocator.getDataDictionaryService();
-    }
-
-    /**
-     * Sets the dataDictionaryService attribute value.
-     * @param dataDictionaryService The dataDictionaryService to set.
-     */
-    public void setDataDictionaryService(DataDictionaryService dataDictionaryService) {
-        this.dataDictionaryService = dataDictionaryService;
-    }
-
-    /**
-     * Gets the businessObjectDictionaryService attribute.
-     * @return Returns the businessObjectDictionaryService.
-     */
-    public BusinessObjectDictionaryService getBusinessObjectDictionaryService() {
-        return businessObjectDictionaryService != null ? businessObjectDictionaryService : KNSServiceLocator.getBusinessObjectDictionaryService();
-    }
-
-    /**
-     * Sets the businessObjectDictionaryService attribute value.
-     * @param businessObjectDictionaryService The businessObjectDictionaryService to set.
-     */
-    public void setBusinessObjectDictionaryService(BusinessObjectDictionaryService businessObjectDictionaryService) {
-        this.businessObjectDictionaryService = businessObjectDictionaryService;
-    }
-
-    /**
-     * Gets the businessObjectMetaDataService attribute.
-     * @return Returns the businessObjectMetaDataService.
-     */
-    public BusinessObjectMetaDataService getBusinessObjectMetaDataService() {
-        return businessObjectMetaDataService != null ? businessObjectMetaDataService : KNSServiceLocator.getBusinessObjectMetaDataService();
-    }
-
-    /**
-     * Sets the businessObjectMetaDataService attribute value.
-     * @param businessObjectMetaDataService The businessObjectMetaDataService to set.
-     */
-    public void setBusinessObjectMetaDataService(BusinessObjectMetaDataService businessObjectMetaDataService) {
-        this.businessObjectMetaDataService = businessObjectMetaDataService;
-    }
-
-    /**
-     * Gets the persistenceStructureService attribute.
-     * @return Returns the persistenceStructureService.
-     */
-    protected PersistenceStructureService getPersistenceStructureService() {
-        return persistenceStructureService != null ? persistenceStructureService : KNSServiceLocator.getPersistenceStructureService();
-    }
-
-    /**
-     * Sets the persistenceStructureService attribute value.
-     * @param persistenceStructureService The persistenceStructureService to set.
-     */
-    public void setPersistenceStructureService(PersistenceStructureService persistenceStructureService) {
-        this.persistenceStructureService = persistenceStructureService;
-    }
-
-    /**
-     * Gets the encryptionService attribute. 
-     * @return Returns the encryptionService.
-     */
-    protected EncryptionService getEncryptionService() {
-        return encryptionService != null ? encryptionService : KNSServiceLocator.getEncryptionService();
-    }
-
-    /**
-     * Sets the encryptionService attribute value.
-     * @param encryptionService The encryptionService to set.
-     */
-    public void setEncryptionService(EncryptionService encryptionService) {
-        this.encryptionService = encryptionService;
-    }
-
-    private MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService;
-
-    public MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
-	if ( maintenanceDocumentDictionaryService == null ) {
-	    maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-	}
-	return maintenanceDocumentDictionaryService;
-    }
-
-    private Inquirable kualiInquirable;
-
-    public Inquirable getKualiInquirable() {
-	if ( kualiInquirable == null ) {
-	    kualiInquirable = KNSServiceLocator.getKualiInquirable();
-	}
-	return kualiInquirable;
-    }
-
-    public void setMaintenanceDocumentDictionaryService(MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService) {
-        this.maintenanceDocumentDictionaryService = maintenanceDocumentDictionaryService;
-    }
-
-    public void setKualiInquirable(Inquirable kualiInquirable) {
-        this.kualiInquirable = kualiInquirable;
-    }
-
-    private KualiConfigurationService kualiConfigurationService;
-
-    public KualiConfigurationService getKualiConfigurationService() {
-	if ( kualiConfigurationService == null ) {
-	    kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
-	}
-        return kualiConfigurationService;
-    }
-
-    public void setKualiConfigurationService(KualiConfigurationService kualiConfigurationService) {
-        this.kualiConfigurationService = kualiConfigurationService;
-    }
-
-    AuthorizationService authorizationService;
-
-    public AuthorizationService getAuthorizationService() {
-	if ( authorizationService == null ) {
-	    authorizationService = KNSServiceLocator.getAuthorizationService();
-	}
-        return this.authorizationService;
-    }
-
-    public void setAuthorizationService(AuthorizationService authorizationService) {
-        this.authorizationService = authorizationService;
-    }
-
-    /**
-     * Determines if underlying lookup bo has associated maintenance document that allows new or copy maintenance actions.
-     *
-     * @return true if bo has maint doc that allows new or copy actions
-     */
-    public boolean allowsMaintenanceNewOrCopyAction() {
-        boolean allowsNewOrCopy = false;
-
-        String maintDocTypeName = getMaintenanceDocumentTypeName();
-        if (StringUtils.isNotBlank(maintDocTypeName)) {
-            allowsNewOrCopy = getMaintenanceDocumentDictionaryService().getAllowsNewOrCopy(maintDocTypeName);
-        }
-
-        return allowsNewOrCopy;
-    }
-
-    /**
-     * Build a maintenance url.
-     *
-     * @param bo - business object representing the record for maint.
-     * @param methodToCall - maintenance action
-     * @return
-     */
-    final public String getMaintenanceUrl(BusinessObject businessObject, HtmlData htmlData, List pkNames) {
-    	htmlData.setTitle(getActionUrlTitleText(businessObject, htmlData.getDisplayText(), pkNames));
-		return htmlData.constructCompleteHtmlTag();
-    }
-
-    /**
-     * This method is called by performLookup method to generate action urls. 
-     * It calls the method getCustomActionUrls to get html data, calls getMaintenanceUrl to get the actual html tag, 
-     * and returns a formatted/concatenated string of action urls.
-     * 
-     * @see org.kuali.core.lookup.LookupableHelperService#getActionUrls(org.kuali.core.bo.BusinessObject)
-     */
-    final public String getActionUrls(BusinessObject businessObject, List pkNames) {
-        StringBuffer actions = new StringBuffer();
-        List<HtmlData> htmlDataList = getCustomActionUrls(businessObject, pkNames);
-        for(HtmlData htmlData: htmlDataList){
-        	actions.append(getMaintenanceUrl(businessObject, htmlData, pkNames));
-            if(htmlData.getChildUrlDataList()!=null){
-            	if(htmlData.getChildUrlDataList().size()>0){
-                    actions.append(ACTION_URLS_CHILDREN_STARTER);
-            		for(HtmlData childURLData: htmlData.getChildUrlDataList()){
-	                	actions.append(getMaintenanceUrl(businessObject, childURLData, pkNames));
-	                    actions.append(ACTION_URLS_CHILDREN_SEPARATOR);
-	            	}
-            		if(actions.toString().endsWith(ACTION_URLS_CHILDREN_SEPARATOR))
-            			actions.delete(actions.length()-ACTION_URLS_CHILDREN_SEPARATOR.length(), actions.length());
-                    actions.append(ACTION_URLS_CHILDREN_END);
-            	}
-            }
-        	actions.append(ACTION_URLS_SEPARATOR);
-        }
-        if(actions.toString().endsWith(ACTION_URLS_SEPARATOR))
-        	actions.delete(actions.length()-ACTION_URLS_SEPARATOR.length(), actions.length());
-        return actions.toString();
-    }
-
-    /**
-     * Child classes should override this method if they want to return some other action urls.
-     * 
-     * @returns This default implementation returns links to edit and copy maintenance action for 
-     * the current maintenance record if the business object class has an associated maintenance document. 
-     * Also checks value of allowsNewOrCopy in maintenance document xml before rendering the copy link.
-     * 
-     * @see org.kuali.rice.kns.lookup.LookupableHelperService#getCustomActionUrls(org.kuali.rice.kns.bo.BusinessObject, java.util.List, java.util.List pkNames)
-     */
-    public List<HtmlData> getCustomActionUrls(BusinessObject businessObject, List pkNames){
-    	List<HtmlData> htmlDataList = new ArrayList<HtmlData>();
-        if (StringUtils.isNotBlank(getMaintenanceDocumentTypeName())) {
-        	htmlDataList.add(getUrlData(businessObject, KNSConstants.MAINTENANCE_EDIT_METHOD_TO_CALL, pkNames));
-        }
-        if (allowsMaintenanceNewOrCopyAction()) {
-        	htmlDataList.add(getUrlData(businessObject, KNSConstants.MAINTENANCE_COPY_METHOD_TO_CALL, pkNames));
-        }
-        return htmlDataList;
-    }
-
-    /**
-     * 
-     * This method constructs an AnchorHtmlData. 
-     * This method can be overriden by child classes if they want to construct the html data in a different way.
-     * Foe example, if they want different type of html tag, like input/image.
-     * 
-     * @param businessObject
-     * @param methodToCall
-     * @param displayText
-     * @param pkNames
-     * @return
-     */
-    protected AnchorHtmlData getUrlData(BusinessObject businessObject, String methodToCall, String displayText, List pkNames){
-
-    	String href = getActionUrlHref(businessObject, methodToCall, pkNames);
-    	//String title = StringUtils.isBlank(href)?"":getActionUrlTitleText(businessObject, displayText, pkNames);
-    	AnchorHtmlData anchorHtmlData = new AnchorHtmlData(href, methodToCall, displayText);
-    	return anchorHtmlData;
-    }
-
-    /**
-     * 
-     * This method calls its overloaded method with displayText as methodToCall
-     * 
-     * @param businessObject
-     * @param methodToCall
-     * @param pkNames
-     * @return
-     */
-    protected AnchorHtmlData getUrlData(BusinessObject businessObject, String methodToCall, List pkNames){
-      	return getUrlData(businessObject, methodToCall, methodToCall, pkNames);
-    }
-
-    /**
-     * 
-     * A utility method that returns an empty list of action urls.
-     * 
-     * @return
-     */
-    protected List<HtmlData> getEmptyActionUrls(){
-    	return new ArrayList<HtmlData>();
-    }
-
-    protected HtmlData getEmptyAnchorHtmlData(){
-    	return new AnchorHtmlData();
-    }
-    
-    /**
-     * 
-     * This method generates and returns href for the given parameters. 
-     * This method can be overridden by child classes if they have to generate href differently. 
-     * For example, refer to IntendedIncumbentLookupableHelperServiceImpl
-     * 
-     * @param businessObject
-     * @param methodToCall
-     * @param pkNames
-     * @return
-     */
-    protected String getActionUrlHref(BusinessObject businessObject, String methodToCall, List pkNames){
-        Properties parameters = new Properties();
-        parameters.put(KNSConstants.DISPATCH_REQUEST_PARAMETER, methodToCall);
-        parameters.put(KNSConstants.BUSINESS_OBJECT_CLASS_ATTRIBUTE, this.businessObjectClass.getName());
-
-        for (Iterator iter = pkNames.iterator(); iter.hasNext();) {
-            String fieldNm = (String) iter.next();
-
-            Object fieldVal = ObjectUtils.getPropertyValue(businessObject, fieldNm);
-            if (fieldVal == null) {
-                fieldVal = KNSConstants.EMPTY_STRING;
-            }
-            if (fieldVal instanceof java.sql.Date) {
-                String formattedString = "";
-                if (Formatter.findFormatter(fieldVal.getClass()) != null) {
-                    Formatter formatter = Formatter.getFormatter(fieldVal.getClass());
-                    formattedString = (String) formatter.format(fieldVal);
-                    fieldVal = formattedString;
-                }
-            }
-
-            // Encrypt value if it is a secure field
-            String displayWorkgroup = getDataDictionaryService().getAttributeDisplayWorkgroup(businessObject.getClass(), fieldNm);
-            if (StringUtils.isNotBlank(displayWorkgroup)) {
-                try {
-                    fieldVal = getEncryptionService().encrypt(fieldVal);
-                }
-                catch (GeneralSecurityException e) {
-                    LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
-                    throw new RuntimeException(e);
-                }
-
-            }
-
-            parameters.put(fieldNm, fieldVal.toString());
-        }
-
-        return UrlFactory.parameterizeUrl(KNSConstants.MAINTENANCE_ACTION, parameters);
-    }
-
-    /**
-     * 
-     * This method generates and returns title text for action urls.
-     * Child classes can override this if they want to generate the title text differently.
-     * For example, refer to BatchJobStatusLookupableHelperServiceImpl
-     * 
-     * @param businessObject
-     * @param displayText
-     * @param pkNames
-     * @return
-     */
-    protected String getActionUrlTitleText(BusinessObject businessObject, String displayText, List pkNames){
-        String prependTitleText = displayText+" "
-    		+getDataDictionaryService().getDataDictionary().getBusinessObjectEntry(getBusinessObjectClass().getName()).getObjectLabel()
-    		+" "
-    		+KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_ACTION_URL_PREPENDTEXT_PROPERTY);
-        return HtmlData.getTitleText(prependTitleText, businessObject, pkNames);
-    }
-
-    /**
-     * Returns the maintenance document type associated with the business object class or null if one does not
-     * exist.
-     * @return String representing the maintenance document type name
-     */
-    protected String getMaintenanceDocumentTypeName() {
-        MaintenanceDocumentDictionaryService dd = getMaintenanceDocumentDictionaryService();
-        String maintDocTypeName = dd.getDocumentTypeName(getBusinessObjectClass());
-        return maintDocTypeName;
-    }
-
-    /**
-     * Gets the readOnlyFieldsList attribute.
-     *
-     * @return Returns the readOnlyFieldsList.
-     */
-    public List<String> getReadOnlyFieldsList() {
-        return readOnlyFieldsList;
-    }
-
-
-    /**
-     * Sets the readOnlyFieldsList attribute value.
-     *
-     * @param readOnlyFieldsList The readOnlyFieldsList to set.
-     */
-    public void setReadOnlyFieldsList(List<String> readOnlyFieldsList) {
-        this.readOnlyFieldsList = readOnlyFieldsList;
-    }
-
-    private HashMap<String,Boolean> noLookupResultFieldInquiryCache = new HashMap<String, Boolean>();
-    private HashMap<Class,Class> inquirableClassCache = new HashMap<Class, Class>();
-    private HashMap<String,Boolean> forceLookupResultFieldInquiryCache = new HashMap<String, Boolean>();
-    /**
-     * Returns the inquiry url for a field if one exist.
-     *
-     * @param bo the business object instance to build the urls for
-     * @param propertyName the property which links to an inquirable
-     * @return String url to inquiry
-     */
-    public HtmlData getInquiryUrl(BusinessObject bo, String propertyName) {
-        HtmlData inquiryUrl = new AnchorHtmlData();
-
-        String cacheKey = bo.getClass().getName()+"."+propertyName;
-        Boolean noLookupResultFieldInquiry = noLookupResultFieldInquiryCache.get( cacheKey );
-        if ( noLookupResultFieldInquiry == null ) {
-            noLookupResultFieldInquiry = getBusinessObjectDictionaryService().noLookupResultFieldInquiry(bo.getClass(), propertyName);
-            if ( noLookupResultFieldInquiry == null ) {
-        	noLookupResultFieldInquiry = Boolean.TRUE;
-            }
-            noLookupResultFieldInquiryCache.put(cacheKey, noLookupResultFieldInquiry);
-        }
-        if ( !noLookupResultFieldInquiry ) {
-
-            Class<Inquirable> inquirableClass = inquirableClassCache.get( bo.getClass() );
-            if ( !inquirableClassCache.containsKey( bo.getClass() ) ) {
-        	inquirableClass = getBusinessObjectDictionaryService().getInquirableClass(bo.getClass());
-        	inquirableClassCache.put(bo.getClass(), inquirableClass);
-            }
-            Inquirable inq = null;
-            try {
-                if ( inquirableClass != null ) {
-                    inq = inquirableClass.newInstance();
-                } else {
-                    inq = getKualiInquirable();
-                    if ( LOG.isDebugEnabled() ) {
-                        LOG.debug( "Default Inquirable Class: " + inq.getClass() );
-                    }
-                }
-                Boolean forceLookupResultFieldInquiry = forceLookupResultFieldInquiryCache.get( cacheKey );
-                if ( forceLookupResultFieldInquiry == null ) {
-                    forceLookupResultFieldInquiry = getBusinessObjectDictionaryService().forceLookupResultFieldInquiry(bo.getClass(), propertyName);
-                    if ( forceLookupResultFieldInquiry == null ) {
-                	forceLookupResultFieldInquiry = Boolean.FALSE;
-                    }
-                    forceLookupResultFieldInquiryCache.put(cacheKey, forceLookupResultFieldInquiry);
-                }
-                inquiryUrl = inq.getInquiryUrl(bo, propertyName, forceLookupResultFieldInquiry);
-            } catch ( Exception ex ) {
-                LOG.error("unable to create inquirable to get inquiry URL", ex );
-            }
-        }
-
-        return inquiryUrl;
-    }
-
-    private CopiedObject<ArrayList<Column>> resultColumns = null;
-
-    /**
-     * Constructs the list of columns for the search results. All properties for the column objects come from the DataDictionary.
-     */
-    public List<Column> getColumns() {
-        if ( resultColumns == null ) {
-            ArrayList<Column> columns = new ArrayList<Column>();
-            for (String attributeName : getBusinessObjectDictionaryService().getLookupResultFieldNames(getBusinessObjectClass())) {
-                Column column = new Column();
-                column.setPropertyName(attributeName);
-                String columnTitle = getDataDictionaryService().getAttributeLabel(getBusinessObjectClass(), attributeName);
-                Boolean useShortLabel = getBusinessObjectDictionaryService().getLookupResultFieldUseShortLabel(businessObjectClass, attributeName);
-                if(useShortLabel != null && useShortLabel){
-                	columnTitle = getDataDictionaryService().getAttributeShortLabel(getBusinessObjectClass(), attributeName);
-                }
-                if (StringUtils.isBlank(columnTitle)) {
-                    columnTitle = getDataDictionaryService().getCollectionLabel(getBusinessObjectClass(), attributeName);
-                }
-                column.setColumnTitle(columnTitle);
-                column.setMaxLength(getColumnMaxLength(attributeName));
-
-                Class formatterClass = getDataDictionaryService().getAttributeFormatter(getBusinessObjectClass(), attributeName);
-                if (formatterClass != null) {
-                    try {
-                        column.setFormatter((Formatter) formatterClass.newInstance());
-                    }
-                    catch (InstantiationException e) {
-                        LOG.error("Unable to get new instance of formatter class: " + formatterClass.getName());
-                        throw new RuntimeException("Unable to get new instance of formatter class: " + formatterClass.getName());
-                    }
-                    catch (IllegalAccessException e) {
-                        LOG.error("Unable to get new instance of formatter class: " + formatterClass.getName());
-                        throw new RuntimeException("Unable to get new instance of formatter class: " + formatterClass.getName());
-                    }
-                }
-
-                columns.add(column);
-            }
-            resultColumns = ObjectUtils.deepCopyForCaching(columns);
-            return columns;
-	    }
-        return resultColumns.getContent();
-    }
-
-    private static Integer RESULTS_DEFAULT_MAX_COLUMN_LENGTH = null;
-    
-    protected int getColumnMaxLength(String attributeName) {
-    	Integer fieldDefinedMaxLength = getBusinessObjectDictionaryService().getLookupResultFieldMaxLength(getBusinessObjectClass(), attributeName);
-    	if (fieldDefinedMaxLength == null) {
-    		if ( RESULTS_DEFAULT_MAX_COLUMN_LENGTH == null ) {
-    			try {
-    				RESULTS_DEFAULT_MAX_COLUMN_LENGTH = Integer.valueOf( getKualiConfigurationService().getParameterValue(KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE, KNSConstants.RESULTS_DEFAULT_MAX_COLUMN_LENGTH) );
-    			} catch ( NumberFormatException ex ) {
-    				LOG.error("Lookup field max length parameter not found and unable to parse default set in system parameters (RESULTS_DEFAULT_MAX_COLUMN_LENGTH).");
-    			}
-    		}
-            return RESULTS_DEFAULT_MAX_COLUMN_LENGTH.intValue();
-	}
-        return fieldDefinedMaxLength.intValue();
-    }
-
-    /**
-     * @return Returns the backLocation.
-     */
-    public String getBackLocation() {
-        return backLocation;
-    }
-
-    /**
-     * @param backLocation The backLocation to set.
-     */
-    public void setBackLocation(String backLocation) {
-        this.backLocation = backLocation;
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#getReturnLocation()
-     */
-    public String getReturnLocation() {
-        return backLocation;
-    }
-
-    /**
-     * This method is for lookupable implementations
-     * 
-     * @see org.kuali.rice.kns.lookup.LookupableHelperService#getReturnUrl(org.kuali.rice.kns.bo.BusinessObject, java.util.Map, java.lang.String, java.util.List)
-     */
-    final public HtmlData getReturnUrl(BusinessObject businessObject, Map fieldConversions, String lookupImpl, List returnKeys){
-    	String href = getReturnHref(businessObject, fieldConversions, lookupImpl, returnKeys);
-    	String returnUrlAnchorLabel = 
-        	KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_RETURN_URL_PREPENDTEXT_PROPERTY);
-        AnchorHtmlData anchor = new AnchorHtmlData(href, HtmlData.getTitleText(returnUrlAnchorLabel, businessObject, returnKeys));
-        anchor.setDisplayText(returnUrlAnchorLabel);
-        return anchor;
-    }
-
-    /**
-     * 
-     * This method is for lookupable implementations
-     * 
-     * @param businessObject
-     * @param fieldConversions
-     * @param lookupImpl
-     * @param returnKeys
-     * @return
-     */
-    final protected String getReturnHref(BusinessObject businessObject, Map fieldConversions, String lookupImpl, List returnKeys) {
-        return UrlFactory.parameterizeUrl(backLocation, getParameters(
-        		businessObject, fieldConversions, lookupImpl, returnKeys));
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#getReturnUrl(org.kuali.core.bo.BusinessObject, java.util.Map, java.lang.String)
-     */
-    public HtmlData getReturnUrl(BusinessObject businessObject, LookupForm lookupForm, List returnKeys) {
-    	Properties parameters = getParameters(
-        		businessObject, lookupForm.getFieldConversions(), lookupForm.getLookupableImplServiceName(), returnKeys);
-    	if(StringUtils.isEmpty(lookupForm.getHtmlDataType()) || HtmlData.ANCHOR_HTML_DATA_TYPE.equals(lookupForm.getHtmlDataType()))
-    		return getReturnAnchorHtmlData(businessObject, parameters, lookupForm, returnKeys);
-    	else 
-    		return getReturnInputHtmlData(businessObject, parameters, lookupForm, returnKeys);
-    }
-
-    protected HtmlData getReturnInputHtmlData(BusinessObject businessObject, Properties parameters, LookupForm lookupForm, List returnKeys){
-    	String returnUrlAnchorLabel = 
-        	KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_RETURN_URL_PREPENDTEXT_PROPERTY);
-    	String name = KNSConstants.MULTIPLE_VALUE_LOOKUP_SELECTED_OBJ_ID_PARAM_PREFIX+lookupForm.getLookupObjectId();
-        InputHtmlData input = new InputHtmlData(name, InputHtmlData.CHECKBOX_INPUT_TYPE);
-        input.setTitle(HtmlData.getTitleText(returnUrlAnchorLabel, businessObject, returnKeys));
-    	if(((MultipleValueLookupForm)lookupForm).getCompositeObjectIdMap()==null || 
-    			((MultipleValueLookupForm)lookupForm).getCompositeObjectIdMap().get(
-    			((PersistableBusinessObject)businessObject).getObjectId())==null){
-    		input.setChecked("");
-    	} else{
-    		input.setChecked(InputHtmlData.CHECKBOX_CHECKED_VALUE);
-    	}
-    	input.setValue(InputHtmlData.CHECKBOX_CHECKED_VALUE);
-        return input;
-    }
-    
-    protected HtmlData getReturnAnchorHtmlData(BusinessObject businessObject, Properties parameters, LookupForm lookupForm, List returnKeys){
-    	String returnUrlAnchorLabel = 
-        	KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_RETURN_URL_PREPENDTEXT_PROPERTY);
-        AnchorHtmlData anchor = new AnchorHtmlData(
-        		getReturnHref(parameters, lookupForm, returnKeys), 
-        		HtmlData.getTitleText(returnUrlAnchorLabel, businessObject, returnKeys));
-        anchor.setDisplayText(returnUrlAnchorLabel);
-        return anchor;
-    }
-
-    protected String getReturnHref(Properties parameters, LookupForm lookupForm, List returnKeys) {
-        String href = UrlFactory.parameterizeUrl(backLocation, parameters);
-    	return addToReturnHref(href, lookupForm);
-    }
-
-    protected String addToReturnHref(String href, LookupForm lookupForm){
-    	String lookupAnchor = "";
-        if (StringUtils.isNotEmpty(lookupForm.getAnchor())) {
-        	lookupAnchor = lookupForm.getAnchor();
-        }
-    	href += "&anchor="+lookupAnchor+"&docNum="+(StringUtils.isEmpty(getDocNum())?"":getDocNum());
-    	return href;
-    }
-    
-    protected Properties getParameters(BusinessObject bo, Map fieldConversions, String lookupImpl, List returnKeys) {
-        Properties parameters = new Properties();
-        parameters.put(KNSConstants.DISPATCH_REQUEST_PARAMETER, KNSConstants.RETURN_METHOD_TO_CALL);
-        parameters.put(KNSConstants.DOC_FORM_KEY, getDocFormKey());
-        parameters.put(KNSConstants.REFRESH_CALLER, lookupImpl);
-        if(getDocNum() != null){
-        	parameters.put(KNSConstants.DOC_NUM, getDocNum());
-        }
-
-        if (getReferencesToRefresh() != null) {
-            parameters.put(KNSConstants.REFERENCES_TO_REFRESH, getReferencesToRefresh());
-        }
-
-        Iterator returnKeysIt = getReturnKeys().iterator();
-        while (returnKeysIt.hasNext()) {
-            String fieldNm = (String) returnKeysIt.next();
-
-            Object fieldVal = ObjectUtils.getPropertyValue(bo, fieldNm);
-            if (fieldVal == null) {
-                fieldVal = KNSConstants.EMPTY_STRING;
-            }
-
-            // Encrypt value if it is a secure field
-            String displayWorkgroup = getDataDictionaryService().getAttributeDisplayWorkgroup(bo.getClass(), fieldNm);
-
-            if (fieldConversions.containsKey(fieldNm)) {
-                fieldNm = (String) fieldConversions.get(fieldNm);
-            }
-
-            if (StringUtils.isNotBlank(displayWorkgroup) && !KIMServiceLocator.getIdentityManagementService().isMemberOfGroup(GlobalVariables.getUserSession().getPerson().getPrincipalId(), org.kuali.rice.kim.util.KimConstants.TEMP_GROUP_NAMESPACE, displayWorkgroup )) {
-                try {
-                    fieldVal = getEncryptionService().encrypt(fieldVal);
-                }
-                catch (GeneralSecurityException e) {
-                    LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
-                    throw new RuntimeException(e);
-                }
-
-            }
-
-            //need to format date in url
-            if (fieldVal instanceof Date) {
-            	DateFormatter dateFormatter = new DateFormatter();
-            	fieldVal = dateFormatter.format(fieldVal);
-            }
-
-            parameters.put(fieldNm, fieldVal.toString());
-        }
-
-        return parameters;
-    }
-
-    /**
-     * @return a List of the names of fields which are marked in data dictionary as return fields.
-     */
-    public List getReturnKeys() {
-        List returnKeys;
-        if (fieldConversions != null && !fieldConversions.isEmpty()) {
-            returnKeys = new ArrayList(fieldConversions.keySet());
-        }
-        else {
-            returnKeys = getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(getBusinessObjectClass());
-        }
-
-        return returnKeys;
-    }
-
-    /**
-     * Gets the docFormKey attribute.
-     * @return Returns the docFormKey.
-     */
-    public String getDocFormKey() {
-        return docFormKey;
-    }
-
-    /**
-     * Sets the docFormKey attribute value.
-     * @param docFormKey The docFormKey to set.
-     */
-    public void setDocFormKey(String docFormKey) {
-        this.docFormKey = docFormKey;
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#setFieldConversions(java.util.Map)
-     */
-    public void setFieldConversions(Map fieldConversions) {
-        this.fieldConversions = fieldConversions;
-    }
-
-    /**
-     * Gets the lookupService attribute.
-     * @return Returns the lookupService.
-     */
-    protected LookupService getLookupService() {
-        return lookupService != null ? lookupService : KNSServiceLocator.getLookupService();
-    }
-
-    /**
-     * Sets the lookupService attribute value.
-     * @param lookupService The lookupService to set.
-     */
-    public void setLookupService(LookupService lookupService) {
-        this.lookupService = lookupService;
-    }
-
-    /**
-     * Uses the DD to determine which is the default sort order.
-     *
-     * @return property names that will be used to sort on by default
-     */
-    public List getDefaultSortColumns() {
-        return getBusinessObjectDictionaryService().getLookupDefaultSortFieldNames(getBusinessObjectClass());
-    }
-
-    /**
-     * Checks that any required search fields have value.
-     *
-     * @see org.kuali.core.lookup.LookupableHelperService#validateSearchParameters(java.util.Map)
-     */
-    public void validateSearchParameters(Map fieldValues) {
-        List<String> lookupFieldAttributeList = null;
-        if(getBusinessObjectMetaDataService().isLookupable(getBusinessObjectClass())) {
-            lookupFieldAttributeList = getBusinessObjectMetaDataService().getLookupableFieldNames(getBusinessObjectClass());
-        }
-        if (lookupFieldAttributeList == null) {
-            throw new RuntimeException("Lookup not defined for business object " + getBusinessObjectClass());
-        }
-        for (Iterator iter = lookupFieldAttributeList.iterator(); iter.hasNext();) {
-            String attributeName = (String) iter.next();
-            if (fieldValues.containsKey(attributeName)) {
-                // get label of attribute for message
-                String attributeLabel = getDataDictionaryService().getAttributeLabel(getBusinessObjectClass(), attributeName);
-
-                String attributeValue = (String) fieldValues.get(attributeName);
-
-                boolean isSecureField = !StringUtils.isBlank(getDataDictionaryService().getAttributeDisplayWorkgroup(getBusinessObjectClass(), attributeName));
-
-                // check for required if field does not have value
-                if (StringUtils.isBlank(attributeValue)) {
-                    if ((getBusinessObjectDictionaryService().getLookupAttributeRequired(getBusinessObjectClass(), attributeName)).booleanValue()) {
-                        GlobalVariables.getErrorMap().putError(attributeName, RiceKeyConstants.ERROR_REQUIRED, attributeLabel);
-                    }
-                }
-                else if (isSecureField) {
-                    // following loop would be trivial if Constants.QUERY_CHARACTERS would implement CharSequence but not so
-                    // sure if that makes sense...
-                    for (int i = 0; i < KNSConstants.QUERY_CHARACTERS.length; i++) {
-                        String queryCharacter = KNSConstants.QUERY_CHARACTERS[i];
-
-                        if (attributeValue.contains(queryCharacter)) {
-                            GlobalVariables.getErrorMap().putError(attributeName, RiceKeyConstants.ERROR_SECURE_FIELD, attributeLabel);
-                        }
-                    }
-                }
-            }
-        }
-
-        if (!GlobalVariables.getErrorMap().isEmpty()) {
-            throw new ValidationException("errors in search criteria");
-        }
-    }
-
-    protected org.kuali.rice.kim.service.PersonService getPersonService() {
-        return personService != null ? personService : org.kuali.rice.kim.service.KIMServiceLocator.getPersonService();
-    }
-
-    public void setPersonService(org.kuali.rice.kim.service.PersonService personService) {
-        this.personService = personService;
-    }
-
-    /**
-     * Constructs the list of rows for the search fields. All properties for the field objects come from the DataDictionary.
-     * To be called by setBusinessObject
-     */
-    protected void setRows() {
-        List localRows = new ArrayList();
-        List<String> lookupFieldAttributeList = null;
-        if(getBusinessObjectMetaDataService().isLookupable(getBusinessObjectClass())) {
-            lookupFieldAttributeList = getBusinessObjectMetaDataService().getLookupableFieldNames(getBusinessObjectClass());
-        }
-        if (lookupFieldAttributeList == null) {
-            throw new RuntimeException("Lookup not defined for business object " + getBusinessObjectClass());
-        }
-
-        // construct field object for each search attribute
-        List fields = new ArrayList();
-        try {
-            fields = FieldUtils.createAndPopulateFieldsForLookup(lookupFieldAttributeList, getReadOnlyFieldsList(), getBusinessObjectClass());
-
-        }
-        catch (InstantiationException e) {
-            throw new RuntimeException("Unable to create instance of business object class" + e.getMessage());
-        }
-        catch (IllegalAccessException e) {
-            throw new RuntimeException("Unable to create instance of business object class" + e.getMessage());
-        }
-        this.rows = FieldUtils.wrapFields(fields);
-    }
-
-    public List<Row> getRows() {
-        return rows;
-    }
-
-    public abstract List<? extends BusinessObject> getSearchResults(Map<String, String> fieldValues);
-
-
-    /**
-     * This implementation of this method throws an UnsupportedOperationException, since not every implementation
-     * may actually want to use this operation.  Subclasses desiring other behaviors
-     * will need to override this.
-     *
-     * @see org.kuali.core.lookup.LookupableHelperService#getSearchResultsUnbounded(java.util.Map)
-     */
-    public List<? extends BusinessObject> getSearchResultsUnbounded(Map<String, String> fieldValues) {
-        throw new UnsupportedOperationException("Lookupable helper services do not always support getSearchResultsUnbounded");
-    }
-
-    /**
-     *
-     * This method performs the lookup and returns a collection of lookup items
-     * @param lookupForm
-     * @param kualiLookupable
-     * @param resultTable
-     * @param bounded
-     * @return
-     */
-    public Collection performLookup(LookupForm lookupForm, Collection resultTable, boolean bounded) {
-        setBackLocation((String) lookupForm.getFieldsForLookup().get(KNSConstants.BACK_LOCATION));
-        setDocFormKey((String) lookupForm.getFieldsForLookup().get(KNSConstants.DOC_FORM_KEY));
-        Collection displayList;
-
-        // call search method to get results
-        if (bounded) {
-            displayList = getSearchResults(lookupForm.getFieldsForLookup());
-        }
-        else {
-            displayList = getSearchResultsUnbounded(lookupForm.getFieldsForLookup());
-        }
-
-        HashMap<String,Class> propertyTypes = new HashMap<String, Class>();
-
-        boolean hasReturnableRow = false;
-
-        List returnKeys = getReturnKeys();
-        List pkNames = getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(getBusinessObjectClass());
-        // iterate through result list and wrap rows with return url and action urls
-        for (Iterator iter = displayList.iterator(); iter.hasNext();) {
-            BusinessObject element = (BusinessObject) iter.next();
-        	if(element instanceof PersistableBusinessObject){
-                lookupForm.setLookupObjectId(((PersistableBusinessObject)element).getObjectId());
-            }
-            HtmlData returnUrl = getReturnUrl(element, lookupForm, returnKeys);
-
-            String actionUrls = getActionUrls(element, pkNames);
-
-            List<Column> columns = getColumns();
-            for (Iterator iterator = columns.iterator(); iterator.hasNext();) {
-
-                Column col = (Column) iterator.next();
-                Formatter formatter = col.getFormatter();
-
-                // pick off result column from result list, do formatting
-                String propValue = KNSConstants.EMPTY_STRING;
-                Object prop = ObjectUtils.getPropertyValue(element, col.getPropertyName());
-
-                // set comparator and formatter based on property type
-                Class propClass = propertyTypes.get(col.getPropertyName());
-                if ( propClass == null ) {
-                    try {
-                    	propClass = ObjectUtils.getPropertyType( element, col.getPropertyName(), getPersistenceStructureService() );
-                    	propertyTypes.put( col.getPropertyName(), propClass );
-                    } catch (Exception e) {
-                        throw new RuntimeException("Cannot access PropertyType for property " + "'" + col.getPropertyName() + "' " + " on an instance of '" + element.getClass().getName() + "'.", e);
-                    }
-                }
-
-                // formatters
-                if (prop != null) {
-                    // for Booleans, always use BooleanFormatter
-                    if (prop instanceof Boolean) {
-                        formatter = new BooleanFormatter();
-                    }
-
-                    // for Dates, always use DateFormatter
-                    if (prop instanceof Date) {
-                        formatter = new DateFormatter();
-                    }
-
-                    // for collection, use the list formatter if a formatter hasn't been defined yet
-                    if (prop instanceof Collection && formatter == null) {
-                	formatter = new CollectionFormatter();
-                    }
-
-                    if (formatter != null) {
-                        propValue = (String) formatter.format(prop);
-                    }
-                    else {
-                        propValue = prop.toString();
-                    }
-                }
-
-                // comparator
-                col.setComparator(CellComparatorHelper.getAppropriateComparatorForPropertyClass(propClass));
-                col.setValueComparator(CellComparatorHelper.getAppropriateValueComparatorForPropertyClass(propClass));
-
-                // check security on field and do masking if necessary
-                boolean viewAuthorized = getAuthorizationService().isAuthorizedToViewAttribute(GlobalVariables.getUserSession().getPerson(), element.getClass().getName(), col.getPropertyName());
-                if (!viewAuthorized) {
-                    Mask displayMask = getDataDictionaryService().getAttributeDisplayMask(element.getClass().getName(), col.getPropertyName());
-                    propValue = displayMask.maskValue(propValue);
-                }
-                col.setPropertyValue(propValue);
-
-
-                if (StringUtils.isNotBlank(propValue)) {
-                    col.setColumnAnchor(getInquiryUrl(element, col.getPropertyName()));
-                }
-            }
-
-            ResultRow row = new ResultRow(columns, returnUrl.constructCompleteHtmlTag(), actionUrls);
-
-        	// because of concerns of the BO being cached in session on the ResultRow,
-        	// let's only attach it when needed (currently in the case of export)
-            if (getBusinessObjectDictionaryService().isExportable(getBusinessObjectClass())) {
-            	row.setBusinessObject(element);
-            }
-            
-            boolean rowReturnable = isResultReturnable(element);
-            row.setRowReturnable(rowReturnable);
-            if (rowReturnable) {
-                hasReturnableRow = true;
-            }
-            resultTable.add(row);
-        }
-
-        lookupForm.setHasReturnableRow(hasReturnableRow);
-
-        return displayList;
-    }
-
-
-    protected void setReferencesToRefresh(String referencesToRefresh) {
-        this.referencesToRefresh = referencesToRefresh;
-    }
-
-    public String getReferencesToRefresh() {
-        return referencesToRefresh;
-    }
-
-    protected SequenceAccessorService getSequenceAccessorService() {
-        return sequenceAccessorService != null ? sequenceAccessorService : KNSServiceLocator.getSequenceAccessorService();
-    }
-
-    public void setSequenceAccessorService(SequenceAccessorService sequenceAccessorService) {
-        this.sequenceAccessorService = sequenceAccessorService;
-    }
-    
-    public BusinessObjectService getBusinessObjectService() {
-        return businessObjectService != null ? businessObjectService : KNSServiceLocator.getBusinessObjectService();
-    }
-
-    public void setBusinessObjectService(BusinessObjectService businessObjectService) {
-        this.businessObjectService = businessObjectService;
-    }
-
-    protected LookupResultsService getLookupResultsService() {
-        return lookupResultsService != null ? lookupResultsService : KNSServiceLocator.getLookupResultsService();
-    }
-
-    public void setLookupResultsService(LookupResultsService lookupResultsService) {
-        this.lookupResultsService = lookupResultsService;
-    }
-
-    /**
-     * @return false always, subclasses should override to do something smarter
-     * @see org.kuali.core.lookup.LookupableHelperService#isSearchUsingOnlyPrimaryKeyValues()
-     */
-    public boolean isSearchUsingOnlyPrimaryKeyValues() {
-        // by default, this implementation returns false, as lookups may not necessarily support this
-        return false;
-    }
-
-    /**
-     * Returns "N/A"
-     *
-     * @return "N/A"
-     * @see org.kuali.core.lookup.LookupableHelperService#getPrimaryKeyFieldLabels()
-     */
-    public String getPrimaryKeyFieldLabels() {
-        return KNSConstants.NOT_AVAILABLE_STRING;
-    }
-
-    /**
-     * @see org.kuali.core.lookup.LookupableHelperService#isResultReturnable(org.kuali.core.bo.BusinessObject)
-     */
-    public boolean isResultReturnable(BusinessObject object) {
-        return true;
-    }
-}
+/*
+ * Copyright 2006-2007 The Kuali Foundation.
+ *
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.lookup;
+
+import java.security.GeneralSecurityException;
+import java.sql.Date;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.core.service.EncryptionService;
+import org.kuali.rice.kns.bo.BusinessObject;
+import org.kuali.rice.kns.bo.PersistableBusinessObject;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
+import org.kuali.rice.kns.datadictionary.mask.Mask;
+import org.kuali.rice.kns.exception.ValidationException;
+import org.kuali.rice.kns.inquiry.Inquirable;
+import org.kuali.rice.kns.lookup.HtmlData.AnchorHtmlData;
+import org.kuali.rice.kns.lookup.HtmlData.InputHtmlData;
+import org.kuali.rice.kns.service.AuthorizationService;
+import org.kuali.rice.kns.service.BusinessObjectDictionaryService;
+import org.kuali.rice.kns.service.BusinessObjectMetaDataService;
+import org.kuali.rice.kns.service.BusinessObjectService;
+import org.kuali.rice.kns.service.DataDictionaryService;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.KualiConfigurationService;
+import org.kuali.rice.kns.service.LookupService;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.service.PersistenceStructureService;
+import org.kuali.rice.kns.service.SequenceAccessorService;
+import org.kuali.rice.kim.service.KIMServiceLocator;
+import org.kuali.rice.kim.service.PersonService;
+import org.kuali.rice.kns.util.FieldUtils;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.util.RiceKeyConstants;
+import org.kuali.rice.kns.util.UrlFactory;
+import org.kuali.rice.kns.util.cache.CopiedObject;
+import org.kuali.rice.kns.web.comparator.CellComparatorHelper;
+import org.kuali.rice.kns.web.format.BooleanFormatter;
+import org.kuali.rice.kns.web.format.CollectionFormatter;
+import org.kuali.rice.kns.web.format.DateFormatter;
+import org.kuali.rice.kns.web.format.Formatter;
+import org.kuali.rice.kns.web.struts.form.LookupForm;
+import org.kuali.rice.kns.web.struts.form.MultipleValueLookupForm;
+import org.kuali.rice.kns.web.ui.Column;
+import org.kuali.rice.kns.web.ui.ResultRow;
+import org.kuali.rice.kns.web.ui.Row;
+
+/**
+ * This class declares many of the common spring injected properties, the get/set-ers for them,
+ * and some common util methods that require the injected services
+ */
+public abstract class AbstractLookupableHelperServiceImpl implements LookupableHelperService {
+
+    protected static final String TITLE_RETURN_URL_PREPENDTEXT_PROPERTY = "title.return.url.value.prependtext";
+    protected static final String TITLE_ACTION_URL_PREPENDTEXT_PROPERTY = "title.action.url.value.prependtext";
+    protected static final String ACTION_URLS_CHILDREN_SEPARATOR = "&nbsp;|&nbsp;";
+    protected static final String ACTION_URLS_CHILDREN_STARTER = "&nbsp;[";
+    protected static final String ACTION_URLS_CHILDREN_END = "]";
+    protected static final String ACTION_URLS_SEPARATOR = "&nbsp;&nbsp;";
+    
+    protected static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(AbstractLookupableHelperServiceImpl.class);
+
+    private Class businessObjectClass;
+    private Map parameters;
+    private BusinessObjectDictionaryService businessObjectDictionaryService;
+    private BusinessObjectMetaDataService businessObjectMetaDataService;
+    private DataDictionaryService dataDictionaryService;
+    private PersistenceStructureService persistenceStructureService;
+    private EncryptionService encryptionService;
+    private List<String> readOnlyFieldsList;
+    private String backLocation;
+    private String docFormKey;
+    private Map fieldConversions;
+    private LookupService lookupService;
+    private org.kuali.rice.kim.service.PersonService personService;
+    private List<Row> rows;
+    private String referencesToRefresh;
+    private SequenceAccessorService sequenceAccessorService;
+    private BusinessObjectService businessObjectService;
+    private LookupResultsService lookupResultsService;
+    private String docNum;
+
+    /**
+	 * @return the docNum
+	 */
+	public String getDocNum() {
+		return this.docNum;
+	}
+
+	/**
+	 * @param docNum the docNum to set
+	 */
+	public void setDocNum(String docNum) {
+		this.docNum = docNum;
+	}
+
+	public AbstractLookupableHelperServiceImpl() {
+        rows = null;
+    }
+
+    /**
+     * This implementation always returns false.
+     *
+     * @see org.kuali.core.lookup.LookupableHelperService#checkForAdditionalFields(java.util.Map)
+     */
+    public boolean checkForAdditionalFields(Map fieldValues) {
+        return false;
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#getBusinessObjectClass()
+     */
+    public Class getBusinessObjectClass() {
+        return businessObjectClass;
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#setBusinessObjectClass(java.lang.Class)
+     */
+    public void setBusinessObjectClass(Class businessObjectClass) {
+        this.businessObjectClass = businessObjectClass;
+        setRows();
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#getParameters()
+     */
+    public Map getParameters() {
+        return parameters;
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#setParameters(java.util.Map)
+     */
+    public void setParameters(Map parameters) {
+        this.parameters = parameters;
+    }
+
+    /**
+     * Gets the dataDictionaryService attribute.
+     * @return Returns the dataDictionaryService.
+     */
+    public DataDictionaryService getDataDictionaryService() {
+        return dataDictionaryService != null ? dataDictionaryService : KNSServiceLocator.getDataDictionaryService();
+    }
+
+    /**
+     * Sets the dataDictionaryService attribute value.
+     * @param dataDictionaryService The dataDictionaryService to set.
+     */
+    public void setDataDictionaryService(DataDictionaryService dataDictionaryService) {
+        this.dataDictionaryService = dataDictionaryService;
+    }
+
+    /**
+     * Gets the businessObjectDictionaryService attribute.
+     * @return Returns the businessObjectDictionaryService.
+     */
+    public BusinessObjectDictionaryService getBusinessObjectDictionaryService() {
+        return businessObjectDictionaryService != null ? businessObjectDictionaryService : KNSServiceLocator.getBusinessObjectDictionaryService();
+    }
+
+    /**
+     * Sets the businessObjectDictionaryService attribute value.
+     * @param businessObjectDictionaryService The businessObjectDictionaryService to set.
+     */
+    public void setBusinessObjectDictionaryService(BusinessObjectDictionaryService businessObjectDictionaryService) {
+        this.businessObjectDictionaryService = businessObjectDictionaryService;
+    }
+
+    /**
+     * Gets the businessObjectMetaDataService attribute.
+     * @return Returns the businessObjectMetaDataService.
+     */
+    public BusinessObjectMetaDataService getBusinessObjectMetaDataService() {
+        return businessObjectMetaDataService != null ? businessObjectMetaDataService : KNSServiceLocator.getBusinessObjectMetaDataService();
+    }
+
+    /**
+     * Sets the businessObjectMetaDataService attribute value.
+     * @param businessObjectMetaDataService The businessObjectMetaDataService to set.
+     */
+    public void setBusinessObjectMetaDataService(BusinessObjectMetaDataService businessObjectMetaDataService) {
+        this.businessObjectMetaDataService = businessObjectMetaDataService;
+    }
+
+    /**
+     * Gets the persistenceStructureService attribute.
+     * @return Returns the persistenceStructureService.
+     */
+    protected PersistenceStructureService getPersistenceStructureService() {
+        return persistenceStructureService != null ? persistenceStructureService : KNSServiceLocator.getPersistenceStructureService();
+    }
+
+    /**
+     * Sets the persistenceStructureService attribute value.
+     * @param persistenceStructureService The persistenceStructureService to set.
+     */
+    public void setPersistenceStructureService(PersistenceStructureService persistenceStructureService) {
+        this.persistenceStructureService = persistenceStructureService;
+    }
+
+    /**
+     * Gets the encryptionService attribute. 
+     * @return Returns the encryptionService.
+     */
+    protected EncryptionService getEncryptionService() {
+        return encryptionService != null ? encryptionService : KNSServiceLocator.getEncryptionService();
+    }
+
+    /**
+     * Sets the encryptionService attribute value.
+     * @param encryptionService The encryptionService to set.
+     */
+    public void setEncryptionService(EncryptionService encryptionService) {
+        this.encryptionService = encryptionService;
+    }
+
+    private MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService;
+
+    public MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+	if ( maintenanceDocumentDictionaryService == null ) {
+	    maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+	}
+	return maintenanceDocumentDictionaryService;
+    }
+
+    private Inquirable kualiInquirable;
+
+    public Inquirable getKualiInquirable() {
+	if ( kualiInquirable == null ) {
+	    kualiInquirable = KNSServiceLocator.getKualiInquirable();
+	}
+	return kualiInquirable;
+    }
+
+    public void setMaintenanceDocumentDictionaryService(MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService) {
+        this.maintenanceDocumentDictionaryService = maintenanceDocumentDictionaryService;
+    }
+
+    public void setKualiInquirable(Inquirable kualiInquirable) {
+        this.kualiInquirable = kualiInquirable;
+    }
+
+    private KualiConfigurationService kualiConfigurationService;
+
+    public KualiConfigurationService getKualiConfigurationService() {
+	if ( kualiConfigurationService == null ) {
+	    kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+	}
+        return kualiConfigurationService;
+    }
+
+    public void setKualiConfigurationService(KualiConfigurationService kualiConfigurationService) {
+        this.kualiConfigurationService = kualiConfigurationService;
+    }
+
+    AuthorizationService authorizationService;
+
+    public AuthorizationService getAuthorizationService() {
+	if ( authorizationService == null ) {
+	    authorizationService = KNSServiceLocator.getAuthorizationService();
+	}
+        return this.authorizationService;
+    }
+
+    public void setAuthorizationService(AuthorizationService authorizationService) {
+        this.authorizationService = authorizationService;
+    }
+
+    /**
+     * Determines if underlying lookup bo has associated maintenance document that allows new or copy maintenance actions.
+     *
+     * @return true if bo has maint doc that allows new or copy actions
+     */
+    public boolean allowsMaintenanceNewOrCopyAction() {
+        boolean allowsNewOrCopy = false;
+
+        String maintDocTypeName = getMaintenanceDocumentTypeName();
+        if (StringUtils.isNotBlank(maintDocTypeName)) {
+            allowsNewOrCopy = getMaintenanceDocumentDictionaryService().getAllowsNewOrCopy(maintDocTypeName);
+        }
+
+        return allowsNewOrCopy;
+    }
+
+    /**
+     * Build a maintenance url.
+     *
+     * @param bo - business object representing the record for maint.
+     * @param methodToCall - maintenance action
+     * @return
+     */
+    final public String getMaintenanceUrl(BusinessObject businessObject, HtmlData htmlData, List pkNames) {
+    	htmlData.setTitle(getActionUrlTitleText(businessObject, htmlData.getDisplayText(), pkNames));
+		return htmlData.constructCompleteHtmlTag();
+    }
+
+    /**
+     * This method is called by performLookup method to generate action urls. 
+     * It calls the method getCustomActionUrls to get html data, calls getMaintenanceUrl to get the actual html tag, 
+     * and returns a formatted/concatenated string of action urls.
+     * 
+     * @see org.kuali.core.lookup.LookupableHelperService#getActionUrls(org.kuali.core.bo.BusinessObject)
+     */
+    final public String getActionUrls(BusinessObject businessObject, List pkNames) {
+        StringBuffer actions = new StringBuffer();
+        List<HtmlData> htmlDataList = getCustomActionUrls(businessObject, pkNames);
+        for(HtmlData htmlData: htmlDataList){
+        	actions.append(getMaintenanceUrl(businessObject, htmlData, pkNames));
+            if(htmlData.getChildUrlDataList()!=null){
+            	if(htmlData.getChildUrlDataList().size()>0){
+                    actions.append(ACTION_URLS_CHILDREN_STARTER);
+            		for(HtmlData childURLData: htmlData.getChildUrlDataList()){
+	                	actions.append(getMaintenanceUrl(businessObject, childURLData, pkNames));
+	                    actions.append(ACTION_URLS_CHILDREN_SEPARATOR);
+	            	}
+            		if(actions.toString().endsWith(ACTION_URLS_CHILDREN_SEPARATOR))
+            			actions.delete(actions.length()-ACTION_URLS_CHILDREN_SEPARATOR.length(), actions.length());
+                    actions.append(ACTION_URLS_CHILDREN_END);
+            	}
+            }
+        	actions.append(ACTION_URLS_SEPARATOR);
+        }
+        if(actions.toString().endsWith(ACTION_URLS_SEPARATOR))
+        	actions.delete(actions.length()-ACTION_URLS_SEPARATOR.length(), actions.length());
+        return actions.toString();
+    }
+
+    /**
+     * Child classes should override this method if they want to return some other action urls.
+     * 
+     * @returns This default implementation returns links to edit and copy maintenance action for 
+     * the current maintenance record if the business object class has an associated maintenance document. 
+     * Also checks value of allowsNewOrCopy in maintenance document xml before rendering the copy link.
+     * 
+     * @see org.kuali.rice.kns.lookup.LookupableHelperService#getCustomActionUrls(org.kuali.rice.kns.bo.BusinessObject, java.util.List, java.util.List pkNames)
+     */
+    public List<HtmlData> getCustomActionUrls(BusinessObject businessObject, List pkNames){
+    	List<HtmlData> htmlDataList = new ArrayList<HtmlData>();
+        if (StringUtils.isNotBlank(getMaintenanceDocumentTypeName())) {
+        	htmlDataList.add(getUrlData(businessObject, KNSConstants.MAINTENANCE_EDIT_METHOD_TO_CALL, pkNames));
+        }
+        if (allowsMaintenanceNewOrCopyAction()) {
+        	htmlDataList.add(getUrlData(businessObject, KNSConstants.MAINTENANCE_COPY_METHOD_TO_CALL, pkNames));
+        }
+        return htmlDataList;
+    }
+
+    /**
+     * 
+     * This method constructs an AnchorHtmlData. 
+     * This method can be overriden by child classes if they want to construct the html data in a different way.
+     * Foe example, if they want different type of html tag, like input/image.
+     * 
+     * @param businessObject
+     * @param methodToCall
+     * @param displayText
+     * @param pkNames
+     * @return
+     */
+    protected AnchorHtmlData getUrlData(BusinessObject businessObject, String methodToCall, String displayText, List pkNames){
+
+    	String href = getActionUrlHref(businessObject, methodToCall, pkNames);
+    	//String title = StringUtils.isBlank(href)?"":getActionUrlTitleText(businessObject, displayText, pkNames);
+    	AnchorHtmlData anchorHtmlData = new AnchorHtmlData(href, methodToCall, displayText);
+    	return anchorHtmlData;
+    }
+
+    /**
+     * 
+     * This method calls its overloaded method with displayText as methodToCall
+     * 
+     * @param businessObject
+     * @param methodToCall
+     * @param pkNames
+     * @return
+     */
+    protected AnchorHtmlData getUrlData(BusinessObject businessObject, String methodToCall, List pkNames){
+      	return getUrlData(businessObject, methodToCall, methodToCall, pkNames);
+    }
+
+    /**
+     * 
+     * A utility method that returns an empty list of action urls.
+     * 
+     * @return
+     */
+    protected List<HtmlData> getEmptyActionUrls(){
+    	return new ArrayList<HtmlData>();
+    }
+
+    protected HtmlData getEmptyAnchorHtmlData(){
+    	return new AnchorHtmlData();
+    }
+    
+    /**
+     * 
+     * This method generates and returns href for the given parameters. 
+     * This method can be overridden by child classes if they have to generate href differently. 
+     * For example, refer to IntendedIncumbentLookupableHelperServiceImpl
+     * 
+     * @param businessObject
+     * @param methodToCall
+     * @param pkNames
+     * @return
+     */
+    protected String getActionUrlHref(BusinessObject businessObject, String methodToCall, List pkNames){
+        Properties parameters = new Properties();
+        parameters.put(KNSConstants.DISPATCH_REQUEST_PARAMETER, methodToCall);
+        parameters.put(KNSConstants.BUSINESS_OBJECT_CLASS_ATTRIBUTE, this.businessObjectClass.getName());
+
+        for (Iterator iter = pkNames.iterator(); iter.hasNext();) {
+            String fieldNm = (String) iter.next();
+
+            Object fieldVal = ObjectUtils.getPropertyValue(businessObject, fieldNm);
+            if (fieldVal == null) {
+                fieldVal = KNSConstants.EMPTY_STRING;
+            }
+            if (fieldVal instanceof java.sql.Date) {
+                String formattedString = "";
+                if (Formatter.findFormatter(fieldVal.getClass()) != null) {
+                    Formatter formatter = Formatter.getFormatter(fieldVal.getClass());
+                    formattedString = (String) formatter.format(fieldVal);
+                    fieldVal = formattedString;
+                }
+            }
+
+            // Encrypt value if it is a secure field
+            String displayWorkgroup = getDataDictionaryService().getAttributeDisplayWorkgroup(businessObject.getClass(), fieldNm);
+            if (StringUtils.isNotBlank(displayWorkgroup)) {
+                try {
+                    fieldVal = getEncryptionService().encrypt(fieldVal);
+                }
+                catch (GeneralSecurityException e) {
+                    LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
+                    throw new RuntimeException(e);
+                }
+
+            }
+
+            parameters.put(fieldNm, fieldVal.toString());
+        }
+
+        return UrlFactory.parameterizeUrl(KNSConstants.MAINTENANCE_ACTION, parameters);
+    }
+
+    /**
+     * 
+     * This method generates and returns title text for action urls.
+     * Child classes can override this if they want to generate the title text differently.
+     * For example, refer to BatchJobStatusLookupableHelperServiceImpl
+     * 
+     * @param businessObject
+     * @param displayText
+     * @param pkNames
+     * @return
+     */
+    protected String getActionUrlTitleText(BusinessObject businessObject, String displayText, List pkNames){
+        String prependTitleText = displayText+" "
+    		+getDataDictionaryService().getDataDictionary().getBusinessObjectEntry(getBusinessObjectClass().getName()).getObjectLabel()
+    		+" "
+    		+KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_ACTION_URL_PREPENDTEXT_PROPERTY);
+        return HtmlData.getTitleText(prependTitleText, businessObject, pkNames);
+    }
+
+    /**
+     * Returns the maintenance document type associated with the business object class or null if one does not
+     * exist.
+     * @return String representing the maintenance document type name
+     */
+    protected String getMaintenanceDocumentTypeName() {
+        MaintenanceDocumentDictionaryService dd = getMaintenanceDocumentDictionaryService();
+        String maintDocTypeName = dd.getDocumentTypeName(getBusinessObjectClass());
+        return maintDocTypeName;
+    }
+
+    /**
+     * Gets the readOnlyFieldsList attribute.
+     *
+     * @return Returns the readOnlyFieldsList.
+     */
+    public List<String> getReadOnlyFieldsList() {
+        return readOnlyFieldsList;
+    }
+
+
+    /**
+     * Sets the readOnlyFieldsList attribute value.
+     *
+     * @param readOnlyFieldsList The readOnlyFieldsList to set.
+     */
+    public void setReadOnlyFieldsList(List<String> readOnlyFieldsList) {
+        this.readOnlyFieldsList = readOnlyFieldsList;
+    }
+
+    private HashMap<String,Boolean> noLookupResultFieldInquiryCache = new HashMap<String, Boolean>();
+    private HashMap<Class,Class> inquirableClassCache = new HashMap<Class, Class>();
+    private HashMap<String,Boolean> forceLookupResultFieldInquiryCache = new HashMap<String, Boolean>();
+    /**
+     * Returns the inquiry url for a field if one exist.
+     *
+     * @param bo the business object instance to build the urls for
+     * @param propertyName the property which links to an inquirable
+     * @return String url to inquiry
+     */
+    public HtmlData getInquiryUrl(BusinessObject bo, String propertyName) {
+        HtmlData inquiryUrl = new AnchorHtmlData();
+
+        String cacheKey = bo.getClass().getName()+"."+propertyName;
+        Boolean noLookupResultFieldInquiry = noLookupResultFieldInquiryCache.get( cacheKey );
+        if ( noLookupResultFieldInquiry == null ) {
+            noLookupResultFieldInquiry = getBusinessObjectDictionaryService().noLookupResultFieldInquiry(bo.getClass(), propertyName);
+            if ( noLookupResultFieldInquiry == null ) {
+        	noLookupResultFieldInquiry = Boolean.TRUE;
+            }
+            noLookupResultFieldInquiryCache.put(cacheKey, noLookupResultFieldInquiry);
+        }
+        if ( !noLookupResultFieldInquiry ) {
+
+            Class<Inquirable> inquirableClass = inquirableClassCache.get( bo.getClass() );
+            if ( !inquirableClassCache.containsKey( bo.getClass() ) ) {
+        	inquirableClass = getBusinessObjectDictionaryService().getInquirableClass(bo.getClass());
+        	inquirableClassCache.put(bo.getClass(), inquirableClass);
+            }
+            Inquirable inq = null;
+            try {
+                if ( inquirableClass != null ) {
+                    inq = inquirableClass.newInstance();
+                } else {
+                    inq = getKualiInquirable();
+                    if ( LOG.isDebugEnabled() ) {
+                        LOG.debug( "Default Inquirable Class: " + inq.getClass() );
+                    }
+                }
+                Boolean forceLookupResultFieldInquiry = forceLookupResultFieldInquiryCache.get( cacheKey );
+                if ( forceLookupResultFieldInquiry == null ) {
+                    forceLookupResultFieldInquiry = getBusinessObjectDictionaryService().forceLookupResultFieldInquiry(bo.getClass(), propertyName);
+                    if ( forceLookupResultFieldInquiry == null ) {
+                	forceLookupResultFieldInquiry = Boolean.FALSE;
+                    }
+                    forceLookupResultFieldInquiryCache.put(cacheKey, forceLookupResultFieldInquiry);
+                }
+                inquiryUrl = inq.getInquiryUrl(bo, propertyName, forceLookupResultFieldInquiry);
+            } catch ( Exception ex ) {
+                LOG.error("unable to create inquirable to get inquiry URL", ex );
+            }
+        }
+
+        return inquiryUrl;
+    }
+
+    private CopiedObject<ArrayList<Column>> resultColumns = null;
+
+    /**
+     * Constructs the list of columns for the search results. All properties for the column objects come from the DataDictionary.
+     */
+    public List<Column> getColumns() {
+        if ( resultColumns == null ) {
+            ArrayList<Column> columns = new ArrayList<Column>();
+            for (String attributeName : getBusinessObjectDictionaryService().getLookupResultFieldNames(getBusinessObjectClass())) {
+                Column column = new Column();
+                column.setPropertyName(attributeName);
+                String columnTitle = getDataDictionaryService().getAttributeLabel(getBusinessObjectClass(), attributeName);
+                Boolean useShortLabel = getBusinessObjectDictionaryService().getLookupResultFieldUseShortLabel(businessObjectClass, attributeName);
+                if(useShortLabel != null && useShortLabel){
+                	columnTitle = getDataDictionaryService().getAttributeShortLabel(getBusinessObjectClass(), attributeName);
+                }
+                if (StringUtils.isBlank(columnTitle)) {
+                    columnTitle = getDataDictionaryService().getCollectionLabel(getBusinessObjectClass(), attributeName);
+                }
+                column.setColumnTitle(columnTitle);
+                column.setMaxLength(getColumnMaxLength(attributeName));
+
+                Class formatterClass = getDataDictionaryService().getAttributeFormatter(getBusinessObjectClass(), attributeName);
+                if (formatterClass != null) {
+                    try {
+                        column.setFormatter((Formatter) formatterClass.newInstance());
+                    }
+                    catch (InstantiationException e) {
+                        LOG.error("Unable to get new instance of formatter class: " + formatterClass.getName());
+                        throw new RuntimeException("Unable to get new instance of formatter class: " + formatterClass.getName());
+                    }
+                    catch (IllegalAccessException e) {
+                        LOG.error("Unable to get new instance of formatter class: " + formatterClass.getName());
+                        throw new RuntimeException("Unable to get new instance of formatter class: " + formatterClass.getName());
+                    }
+                }
+
+                columns.add(column);
+            }
+            resultColumns = ObjectUtils.deepCopyForCaching(columns);
+            return columns;
+	    }
+        return resultColumns.getContent();
+    }
+
+    private static Integer RESULTS_DEFAULT_MAX_COLUMN_LENGTH = null;
+    
+    protected int getColumnMaxLength(String attributeName) {
+    	Integer fieldDefinedMaxLength = getBusinessObjectDictionaryService().getLookupResultFieldMaxLength(getBusinessObjectClass(), attributeName);
+    	if (fieldDefinedMaxLength == null) {
+    		if ( RESULTS_DEFAULT_MAX_COLUMN_LENGTH == null ) {
+    			try {
+    				RESULTS_DEFAULT_MAX_COLUMN_LENGTH = Integer.valueOf( getKualiConfigurationService().getParameterValue(KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.LOOKUP_PARM_DETAIL_TYPE, KNSConstants.RESULTS_DEFAULT_MAX_COLUMN_LENGTH) );
+    			} catch ( NumberFormatException ex ) {
+    				LOG.error("Lookup field max length parameter not found and unable to parse default set in system parameters (RESULTS_DEFAULT_MAX_COLUMN_LENGTH).");
+    			}
+    		}
+            return RESULTS_DEFAULT_MAX_COLUMN_LENGTH.intValue();
+	}
+        return fieldDefinedMaxLength.intValue();
+    }
+
+    /**
+     * @return Returns the backLocation.
+     */
+    public String getBackLocation() {
+        return backLocation;
+    }
+
+    /**
+     * @param backLocation The backLocation to set.
+     */
+    public void setBackLocation(String backLocation) {
+        this.backLocation = backLocation;
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#getReturnLocation()
+     */
+    public String getReturnLocation() {
+        return backLocation;
+    }
+
+    /**
+     * This method is for lookupable implementations
+     * 
+     * @see org.kuali.rice.kns.lookup.LookupableHelperService#getReturnUrl(org.kuali.rice.kns.bo.BusinessObject, java.util.Map, java.lang.String, java.util.List)
+     */
+    final public HtmlData getReturnUrl(BusinessObject businessObject, Map fieldConversions, String lookupImpl, List returnKeys){
+    	String href = getReturnHref(businessObject, fieldConversions, lookupImpl, returnKeys);
+    	String returnUrlAnchorLabel = 
+        	KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_RETURN_URL_PREPENDTEXT_PROPERTY);
+        AnchorHtmlData anchor = new AnchorHtmlData(href, HtmlData.getTitleText(returnUrlAnchorLabel, businessObject, returnKeys));
+        anchor.setDisplayText(returnUrlAnchorLabel);
+        return anchor;
+    }
+
+    /**
+     * 
+     * This method is for lookupable implementations
+     * 
+     * @param businessObject
+     * @param fieldConversions
+     * @param lookupImpl
+     * @param returnKeys
+     * @return
+     */
+    final protected String getReturnHref(BusinessObject businessObject, Map fieldConversions, String lookupImpl, List returnKeys) {
+        return UrlFactory.parameterizeUrl(backLocation, getParameters(
+        		businessObject, fieldConversions, lookupImpl, returnKeys));
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#getReturnUrl(org.kuali.core.bo.BusinessObject, java.util.Map, java.lang.String)
+     */
+    public HtmlData getReturnUrl(BusinessObject businessObject, LookupForm lookupForm, List returnKeys) {
+    	Properties parameters = getParameters(
+        		businessObject, lookupForm.getFieldConversions(), lookupForm.getLookupableImplServiceName(), returnKeys);
+    	if(StringUtils.isEmpty(lookupForm.getHtmlDataType()) || HtmlData.ANCHOR_HTML_DATA_TYPE.equals(lookupForm.getHtmlDataType()))
+    		return getReturnAnchorHtmlData(businessObject, parameters, lookupForm, returnKeys);
+    	else 
+    		return getReturnInputHtmlData(businessObject, parameters, lookupForm, returnKeys);
+    }
+
+    protected HtmlData getReturnInputHtmlData(BusinessObject businessObject, Properties parameters, LookupForm lookupForm, List returnKeys){
+    	String returnUrlAnchorLabel = 
+        	KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_RETURN_URL_PREPENDTEXT_PROPERTY);
+    	String name = KNSConstants.MULTIPLE_VALUE_LOOKUP_SELECTED_OBJ_ID_PARAM_PREFIX+lookupForm.getLookupObjectId();
+        InputHtmlData input = new InputHtmlData(name, InputHtmlData.CHECKBOX_INPUT_TYPE);
+        input.setTitle(HtmlData.getTitleText(returnUrlAnchorLabel, businessObject, returnKeys));
+    	if(((MultipleValueLookupForm)lookupForm).getCompositeObjectIdMap()==null || 
+    			((MultipleValueLookupForm)lookupForm).getCompositeObjectIdMap().get(
+    			((PersistableBusinessObject)businessObject).getObjectId())==null){
+    		input.setChecked("");
+    	} else{
+    		input.setChecked(InputHtmlData.CHECKBOX_CHECKED_VALUE);
+    	}
+    	input.setValue(InputHtmlData.CHECKBOX_CHECKED_VALUE);
+        return input;
+    }
+    
+    protected HtmlData getReturnAnchorHtmlData(BusinessObject businessObject, Properties parameters, LookupForm lookupForm, List returnKeys){
+    	String returnUrlAnchorLabel = 
+        	KNSServiceLocator.getKualiConfigurationService().getPropertyString(TITLE_RETURN_URL_PREPENDTEXT_PROPERTY);
+        AnchorHtmlData anchor = new AnchorHtmlData(
+        		getReturnHref(parameters, lookupForm, returnKeys), 
+        		HtmlData.getTitleText(returnUrlAnchorLabel, businessObject, returnKeys));
+        anchor.setDisplayText(returnUrlAnchorLabel);
+        return anchor;
+    }
+
+    protected String getReturnHref(Properties parameters, LookupForm lookupForm, List returnKeys) {
+        String href = UrlFactory.parameterizeUrl(backLocation, parameters);
+    	return addToReturnHref(href, lookupForm);
+    }
+
+    protected String addToReturnHref(String href, LookupForm lookupForm){
+    	String lookupAnchor = "";
+        if (StringUtils.isNotEmpty(lookupForm.getAnchor())) {
+        	lookupAnchor = lookupForm.getAnchor();
+        }
+    	href += "&anchor="+lookupAnchor+"&docNum="+(StringUtils.isEmpty(getDocNum())?"":getDocNum());
+    	return href;
+    }
+    
+    protected Properties getParameters(BusinessObject bo, Map fieldConversions, String lookupImpl, List returnKeys) {
+        Properties parameters = new Properties();
+        parameters.put(KNSConstants.DISPATCH_REQUEST_PARAMETER, KNSConstants.RETURN_METHOD_TO_CALL);
+        parameters.put(KNSConstants.DOC_FORM_KEY, getDocFormKey());
+        parameters.put(KNSConstants.REFRESH_CALLER, lookupImpl);
+        if(getDocNum() != null){
+        	parameters.put(KNSConstants.DOC_NUM, getDocNum());
+        }
+
+        if (getReferencesToRefresh() != null) {
+            parameters.put(KNSConstants.REFERENCES_TO_REFRESH, getReferencesToRefresh());
+        }
+
+        Iterator returnKeysIt = getReturnKeys().iterator();
+        while (returnKeysIt.hasNext()) {
+            String fieldNm = (String) returnKeysIt.next();
+
+            Object fieldVal = ObjectUtils.getPropertyValue(bo, fieldNm);
+            if (fieldVal == null) {
+                fieldVal = KNSConstants.EMPTY_STRING;
+            }
+
+            // Encrypt value if it is a secure field
+            String displayWorkgroup = getDataDictionaryService().getAttributeDisplayWorkgroup(bo.getClass(), fieldNm);
+
+            if (fieldConversions.containsKey(fieldNm)) {
+                fieldNm = (String) fieldConversions.get(fieldNm);
+            }
+
+            if (StringUtils.isNotBlank(displayWorkgroup) && !KIMServiceLocator.getIdentityManagementService().isMemberOfGroup(GlobalVariables.getUserSession().getPerson().getPrincipalId(), org.kuali.rice.kim.util.KimConstants.TEMP_GROUP_NAMESPACE, displayWorkgroup )) {
+                try {
+                    fieldVal = getEncryptionService().encrypt(fieldVal);
+                }
+                catch (GeneralSecurityException e) {
+                    LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
+                    throw new RuntimeException(e);
+                }
+
+            }
+
+            //need to format date in url
+            if (fieldVal instanceof Date) {
+            	DateFormatter dateFormatter = new DateFormatter();
+            	fieldVal = dateFormatter.format(fieldVal);
+            }
+
+            parameters.put(fieldNm, fieldVal.toString());
+        }
+
+        return parameters;
+    }
+
+    /**
+     * @return a List of the names of fields which are marked in data dictionary as return fields.
+     */
+    public List getReturnKeys() {
+        List returnKeys;
+        if (fieldConversions != null && !fieldConversions.isEmpty()) {
+            returnKeys = new ArrayList(fieldConversions.keySet());
+        }
+        else {
+            returnKeys = getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(getBusinessObjectClass());
+        }
+
+        return returnKeys;
+    }
+
+    /**
+     * Gets the docFormKey attribute.
+     * @return Returns the docFormKey.
+     */
+    public String getDocFormKey() {
+        return docFormKey;
+    }
+
+    /**
+     * Sets the docFormKey attribute value.
+     * @param docFormKey The docFormKey to set.
+     */
+    public void setDocFormKey(String docFormKey) {
+        this.docFormKey = docFormKey;
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#setFieldConversions(java.util.Map)
+     */
+    public void setFieldConversions(Map fieldConversions) {
+        this.fieldConversions = fieldConversions;
+    }
+
+    /**
+     * Gets the lookupService attribute.
+     * @return Returns the lookupService.
+     */
+    protected LookupService getLookupService() {
+        return lookupService != null ? lookupService : KNSServiceLocator.getLookupService();
+    }
+
+    /**
+     * Sets the lookupService attribute value.
+     * @param lookupService The lookupService to set.
+     */
+    public void setLookupService(LookupService lookupService) {
+        this.lookupService = lookupService;
+    }
+
+    /**
+     * Uses the DD to determine which is the default sort order.
+     *
+     * @return property names that will be used to sort on by default
+     */
+    public List getDefaultSortColumns() {
+        return getBusinessObjectDictionaryService().getLookupDefaultSortFieldNames(getBusinessObjectClass());
+    }
+
+    /**
+     * Checks that any required search fields have value.
+     *
+     * @see org.kuali.core.lookup.LookupableHelperService#validateSearchParameters(java.util.Map)
+     */
+    public void validateSearchParameters(Map fieldValues) {
+        List<String> lookupFieldAttributeList = null;
+        if(getBusinessObjectMetaDataService().isLookupable(getBusinessObjectClass())) {
+            lookupFieldAttributeList = getBusinessObjectMetaDataService().getLookupableFieldNames(getBusinessObjectClass());
+        }
+        if (lookupFieldAttributeList == null) {
+            throw new RuntimeException("Lookup not defined for business object " + getBusinessObjectClass());
+        }
+        for (Iterator iter = lookupFieldAttributeList.iterator(); iter.hasNext();) {
+            String attributeName = (String) iter.next();
+            if (fieldValues.containsKey(attributeName)) {
+                // get label of attribute for message
+                String attributeLabel = getDataDictionaryService().getAttributeLabel(getBusinessObjectClass(), attributeName);
+
+                String attributeValue = (String) fieldValues.get(attributeName);
+
+                boolean isSecureField = !StringUtils.isBlank(getDataDictionaryService().getAttributeDisplayWorkgroup(getBusinessObjectClass(), attributeName));
+
+                // check for required if field does not have value
+                if (StringUtils.isBlank(attributeValue)) {
+                    if ((getBusinessObjectDictionaryService().getLookupAttributeRequired(getBusinessObjectClass(), attributeName)).booleanValue()) {
+                        GlobalVariables.getErrorMap().putError(attributeName, RiceKeyConstants.ERROR_REQUIRED, attributeLabel);
+                    }
+                }
+                else if (isSecureField) {
+                    // following loop would be trivial if Constants.QUERY_CHARACTERS would implement CharSequence but not so
+                    // sure if that makes sense...
+                    for (int i = 0; i < KNSConstants.QUERY_CHARACTERS.length; i++) {
+                        String queryCharacter = KNSConstants.QUERY_CHARACTERS[i];
+
+                        if (attributeValue.contains(queryCharacter)) {
+                            GlobalVariables.getErrorMap().putError(attributeName, RiceKeyConstants.ERROR_SECURE_FIELD, attributeLabel);
+                        }
+                    }
+                }
+            }
+        }
+
+        if (!GlobalVariables.getErrorMap().isEmpty()) {
+            throw new ValidationException("errors in search criteria");
+        }
+    }
+
+    protected org.kuali.rice.kim.service.PersonService getPersonService() {
+        return personService != null ? personService : org.kuali.rice.kim.service.KIMServiceLocator.getPersonService();
+    }
+
+    public void setPersonService(org.kuali.rice.kim.service.PersonService personService) {
+        this.personService = personService;
+    }
+
+    /**
+     * Constructs the list of rows for the search fields. All properties for the field objects come from the DataDictionary.
+     * To be called by setBusinessObject
+     */
+    protected void setRows() {
+        List localRows = new ArrayList();
+        List<String> lookupFieldAttributeList = null;
+        if(getBusinessObjectMetaDataService().isLookupable(getBusinessObjectClass())) {
+            lookupFieldAttributeList = getBusinessObjectMetaDataService().getLookupableFieldNames(getBusinessObjectClass());
+        }
+        if (lookupFieldAttributeList == null) {
+            throw new RuntimeException("Lookup not defined for business object " + getBusinessObjectClass());
+        }
+
+        // construct field object for each search attribute
+        List fields = new ArrayList();
+        try {
+            fields = FieldUtils.createAndPopulateFieldsForLookup(lookupFieldAttributeList, getReadOnlyFieldsList(), getBusinessObjectClass());
+
+        }
+        catch (InstantiationException e) {
+            throw new RuntimeException("Unable to create instance of business object class" + e.getMessage());
+        }
+        catch (IllegalAccessException e) {
+            throw new RuntimeException("Unable to create instance of business object class" + e.getMessage());
+        }
+        this.rows = FieldUtils.wrapFields(fields);
+    }
+
+    public List<Row> getRows() {
+        return rows;
+    }
+
+    public abstract List<? extends BusinessObject> getSearchResults(Map<String, String> fieldValues);
+
+
+    /**
+     * This implementation of this method throws an UnsupportedOperationException, since not every implementation
+     * may actually want to use this operation.  Subclasses desiring other behaviors
+     * will need to override this.
+     *
+     * @see org.kuali.core.lookup.LookupableHelperService#getSearchResultsUnbounded(java.util.Map)
+     */
+    public List<? extends BusinessObject> getSearchResultsUnbounded(Map<String, String> fieldValues) {
+        throw new UnsupportedOperationException("Lookupable helper services do not always support getSearchResultsUnbounded");
+    }
+
+    /**
+     *
+     * This method performs the lookup and returns a collection of lookup items
+     * @param lookupForm
+     * @param kualiLookupable
+     * @param resultTable
+     * @param bounded
+     * @return
+     */
+    public Collection performLookup(LookupForm lookupForm, Collection resultTable, boolean bounded) {
+        setBackLocation((String) lookupForm.getFieldsForLookup().get(KNSConstants.BACK_LOCATION));
+        setDocFormKey((String) lookupForm.getFieldsForLookup().get(KNSConstants.DOC_FORM_KEY));
+        Collection displayList;
+
+        // call search method to get results
+        if (bounded) {
+            displayList = getSearchResults(lookupForm.getFieldsForLookup());
+        }
+        else {
+            displayList = getSearchResultsUnbounded(lookupForm.getFieldsForLookup());
+        }
+
+        HashMap<String,Class> propertyTypes = new HashMap<String, Class>();
+
+        boolean hasReturnableRow = false;
+
+        List returnKeys = getReturnKeys();
+        List pkNames = getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(getBusinessObjectClass());
+        // iterate through result list and wrap rows with return url and action urls
+        for (Iterator iter = displayList.iterator(); iter.hasNext();) {
+            BusinessObject element = (BusinessObject) iter.next();
+        	if(element instanceof PersistableBusinessObject){
+                lookupForm.setLookupObjectId(((PersistableBusinessObject)element).getObjectId());
+            }
+            HtmlData returnUrl = getReturnUrl(element, lookupForm, returnKeys);
+
+            String actionUrls = getActionUrls(element, pkNames);
+
+            List<Column> columns = getColumns();
+            for (Iterator iterator = columns.iterator(); iterator.hasNext();) {
+
+                Column col = (Column) iterator.next();
+                Formatter formatter = col.getFormatter();
+
+                // pick off result column from result list, do formatting
+                String propValue = KNSConstants.EMPTY_STRING;
+                Object prop = ObjectUtils.getPropertyValue(element, col.getPropertyName());
+
+                // set comparator and formatter based on property type
+                Class propClass = propertyTypes.get(col.getPropertyName());
+                if ( propClass == null ) {
+                    try {
+                    	propClass = ObjectUtils.getPropertyType( element, col.getPropertyName(), getPersistenceStructureService() );
+                    	propertyTypes.put( col.getPropertyName(), propClass );
+                    } catch (Exception e) {
+                        throw new RuntimeException("Cannot access PropertyType for property " + "'" + col.getPropertyName() + "' " + " on an instance of '" + element.getClass().getName() + "'.", e);
+                    }
+                }
+
+                // formatters
+                if (prop != null) {
+                    // for Booleans, always use BooleanFormatter
+                    if (prop instanceof Boolean) {
+                        formatter = new BooleanFormatter();
+                    }
+
+                    // for Dates, always use DateFormatter
+                    if (prop instanceof Date) {
+                        formatter = new DateFormatter();
+                    }
+
+                    // for collection, use the list formatter if a formatter hasn't been defined yet
+                    if (prop instanceof Collection && formatter == null) {
+                	formatter = new CollectionFormatter();
+                    }
+
+                    if (formatter != null) {
+                        propValue = (String) formatter.format(prop);
+                    }
+                    else {
+                        propValue = prop.toString();
+                    }
+                }
+
+                // comparator
+                col.setComparator(CellComparatorHelper.getAppropriateComparatorForPropertyClass(propClass));
+                col.setValueComparator(CellComparatorHelper.getAppropriateValueComparatorForPropertyClass(propClass));
+
+                AttributeSecurity attributeSecurity = getDataDictionaryService().getAttributeSecurity(element.getClass().getName(), col.getPropertyName());
+                if(attributeSecurity != null && attributeSecurity.isPartialMask()){
+                	boolean viewAuthorized = getAuthorizationService().isAuthorizedToPartiallyUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), element.getClass().getSimpleName(), col.getPropertyName());
+                	if(!viewAuthorized){
+                		propValue = attributeSecurity.getMaskFormatter().maskValue(propValue);
+                	}
+                }
+                if(attributeSecurity != null && attributeSecurity.isMask()){
+                	boolean viewAuthorized = getAuthorizationService().isAuthorizedToUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), element.getClass().getSimpleName(), col.getPropertyName());
+                	if(!viewAuthorized){
+                		propValue = attributeSecurity.getMaskFormatter().maskValue(propValue);
+                	}
+                }
+                
+                col.setPropertyValue(propValue);
+
+                if (StringUtils.isNotBlank(propValue)) {
+                    col.setColumnAnchor(getInquiryUrl(element, col.getPropertyName()));
+                    
+                }
+            }
+
+            ResultRow row = new ResultRow(columns, returnUrl.constructCompleteHtmlTag(), actionUrls);
+
+        	// because of concerns of the BO being cached in session on the ResultRow,
+        	// let's only attach it when needed (currently in the case of export)
+            if (getBusinessObjectDictionaryService().isExportable(getBusinessObjectClass())) {
+            	row.setBusinessObject(element);
+            }
+            
+            boolean rowReturnable = isResultReturnable(element);
+            row.setRowReturnable(rowReturnable);
+            if (rowReturnable) {
+                hasReturnableRow = true;
+            }
+            resultTable.add(row);
+        }
+
+        lookupForm.setHasReturnableRow(hasReturnableRow);
+
+        return displayList;
+    }
+
+
+    protected void setReferencesToRefresh(String referencesToRefresh) {
+        this.referencesToRefresh = referencesToRefresh;
+    }
+
+    public String getReferencesToRefresh() {
+        return referencesToRefresh;
+    }
+
+    protected SequenceAccessorService getSequenceAccessorService() {
+        return sequenceAccessorService != null ? sequenceAccessorService : KNSServiceLocator.getSequenceAccessorService();
+    }
+
+    public void setSequenceAccessorService(SequenceAccessorService sequenceAccessorService) {
+        this.sequenceAccessorService = sequenceAccessorService;
+    }
+    
+    public BusinessObjectService getBusinessObjectService() {
+        return businessObjectService != null ? businessObjectService : KNSServiceLocator.getBusinessObjectService();
+    }
+
+    public void setBusinessObjectService(BusinessObjectService businessObjectService) {
+        this.businessObjectService = businessObjectService;
+    }
+
+    protected LookupResultsService getLookupResultsService() {
+        return lookupResultsService != null ? lookupResultsService : KNSServiceLocator.getLookupResultsService();
+    }
+
+    public void setLookupResultsService(LookupResultsService lookupResultsService) {
+        this.lookupResultsService = lookupResultsService;
+    }
+
+    /**
+     * @return false always, subclasses should override to do something smarter
+     * @see org.kuali.core.lookup.LookupableHelperService#isSearchUsingOnlyPrimaryKeyValues()
+     */
+    public boolean isSearchUsingOnlyPrimaryKeyValues() {
+        // by default, this implementation returns false, as lookups may not necessarily support this
+        return false;
+    }
+
+    /**
+     * Returns "N/A"
+     *
+     * @return "N/A"
+     * @see org.kuali.core.lookup.LookupableHelperService#getPrimaryKeyFieldLabels()
+     */
+    public String getPrimaryKeyFieldLabels() {
+        return KNSConstants.NOT_AVAILABLE_STRING;
+    }
+
+    /**
+     * @see org.kuali.core.lookup.LookupableHelperService#isResultReturnable(org.kuali.core.bo.BusinessObject)
+     */
+    public boolean isResultReturnable(BusinessObject object) {
+        return true;
+    }
+}
Index: impl/src/main/resources/org/kuali/rice/kns/config/KNSSpringBeans.xml
===================================================================
--- impl/src/main/resources/org/kuali/rice/kns/config/KNSSpringBeans.xml	(revision 5311)
+++ impl/src/main/resources/org/kuali/rice/kns/config/KNSSpringBeans.xml	(working copy)
@@ -253,7 +253,7 @@
         </bean>
 	  </property>
 	</bean>
-
+	
 	<bean id="workflowInfoService" class="org.kuali.rice.kns.workflow.service.impl.KualiWorkflowInfoImpl" />
 
 	<bean id="xmlObjectSerializerService" class="org.kuali.rice.kns.service.impl.XmlObjectSerializerServiceImpl"></bean>
@@ -941,4 +941,8 @@
     	<property name="moduleConfiguration" ref="knsModuleConfiguration"/>
     	<property name="kualiModuleService" ref="kualiModuleService" />
     </bean>
+    <bean id="DocumentStatusComponentAttributePermissionType" class="org.kuali.rice.kim.service.support.impl.KimPermissionTypeServiceBase" >
+	</bean>
+	<bean id="InitiatorRoleType" class="org.kuali.rice.kim.service.impl.InitiatorRoleTypeServiceImpl" >
+	</bean>
 </beans>
Index: web/src/main/webapp/WEB-INF/tags/kr/htmlControlAttribute.tag
===================================================================
--- web/src/main/webapp/WEB-INF/tags/kr/htmlControlAttribute.tag	(revision 5311)
+++ web/src/main/webapp/WEB-INF/tags/kr/htmlControlAttribute.tag	(working copy)
@@ -35,7 +35,7 @@
 <%@ attribute name="encryptValue" required="false"
 			  description="when readOnly or hidden field, boolean to indicate whether the value should
 			  be encrypted and display masked. Defaults to false." %>
-<%@ attribute name="displayMask" required="false"
+<%@ attribute name="displayMaskValue" required="false"
 			  description="when a field is not to be displayed in clear text and encrypted as hidden, the
 			  string to display." %>
 <%@ attribute name="styleClass" required="false"
@@ -110,7 +110,7 @@
             %>
             <html:hidden property="encryptedProperties('${fn:replace(property,'.','_')}')" value="true"/>
             <html:hidden write="false" property="${property}" style="${textStyle}"/>
-            ${displayMask}
+            ${displayMaskValue}
          </c:when>
          <c:otherwise>
          <logic:empty name="KualiForm" property="${property}">
Index: impl/src/main/java/org/kuali/rice/kns/web/ui/Field.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/ui/Field.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/web/ui/Field.java	(working copy)
@@ -21,6 +21,7 @@
 import java.util.Map;
 
 import org.apache.commons.lang.StringUtils;
+
 import org.kuali.rice.kns.datadictionary.mask.Mask;
 import org.kuali.rice.kns.lookup.HtmlData;
 import org.kuali.rice.kns.util.KNSConstants;
@@ -54,6 +55,8 @@
     public static final String KUALIUSER = "kualiuser";
     public static final String READONLY = "readOnly";
     public static final String EDITABLE = "editable";
+    public static final String MASKED = "masked";
+    public static final String PARTIALLY_MASKED = "partiallyMasked";
     public static final String LOOKUP_HIDDEN = "lookuphidden";
     public static final String LOOKUP_READONLY = "lookupreadonly";
     public static final String WORKFLOW_WORKGROUP = "workflowworkgroup";
@@ -98,8 +101,10 @@
     private boolean isReadOnly;
     private String lookupParameters;
     private int maxLength;
+    
     private String propertyName;
     private String propertyValue;
+   
     private HtmlData inquiryURL;
     private String propertyPrefix;
     private String quickFinderClassNameImpl;
@@ -117,7 +122,6 @@
     private String personNameAttributeName;
     private String defaultValue = KNSConstants.EMPTY_STRING;
     private boolean keyField;
-    private String displayEditMode;
     private Mask displayMask;
     private String displayMaskValue;
     private String encryptedValue;
@@ -529,7 +533,24 @@
 
         return propertyValue;
     }
+    
+    /**
+     * Gets the displayMaskValue attribute.
+     * 
+     * @return Returns the displayMaskValue.
+     */
+    public String getDisplayMaskValue() {
+        return displayMaskValue;
+    }
 
+    /**
+     * Sets the displayMaskValue attribute value.
+     * 
+     * @param displayMaskValue The displayMaskValue to set.
+     */
+    public void setDisplayMaskValue(String displayMaskValue) {
+        this.displayMaskValue = displayMaskValue;
+    }
 
     /**
      * Gets the propertyPrefix attribute.
@@ -1070,26 +1091,7 @@
         this.keyField = keyField;
     }
 
-
     /**
-     * Gets the displayEditMode attribute.
-     * 
-     * @return Returns the displayEditMode.
-     */
-    public String getDisplayEditMode() {
-        return displayEditMode;
-    }
-
-    /**
-     * Sets the displayEditMode attribute value.
-     * 
-     * @param displayEditMode The displayEditMode to set.
-     */
-    public void setDisplayEditMode(String displayEditMode) {
-        this.displayEditMode = displayEditMode;
-    }
-
-    /**
      * Gets the displayMask attribute.
      * 
      * @return Returns the displayMask.
@@ -1097,35 +1099,8 @@
     public Mask getDisplayMask() {
         return displayMask;
     }
-
+    
     /**
-     * Sets the displayMask attribute value.
-     * 
-     * @param displayMask The displayMask to set.
-     */
-    public void setDisplayMask(Mask displayMask) {
-        this.displayMask = displayMask;
-    }
-
-    /**
-     * Gets the displayMaskValue attribute.
-     * 
-     * @return Returns the displayMaskValue.
-     */
-    public String getDisplayMaskValue() {
-        return displayMaskValue;
-    }
-
-    /**
-     * Sets the displayMaskValue attribute value.
-     * 
-     * @param displayMaskValue The displayMaskValue to set.
-     */
-    public void setDisplayMaskValue(String displayMaskValue) {
-        this.displayMaskValue = displayMaskValue;
-    }
-
-    /**
      * Gets the encryptedValue attribute.
      * 
      * @return Returns the encryptedValue.
@@ -1160,7 +1135,7 @@
     public void setSecure(boolean secure) {
         this.secure = secure;
     }
-
+    
     /**
      * Returns the method name of a function present in the page which should be called
      * when the user tabs away from the field.
@@ -1379,7 +1354,7 @@
     public void setFieldDirectInquiryEnabled(boolean fieldDirectInquiryEnabled) {
         this.fieldDirectInquiryEnabled = fieldDirectInquiryEnabled;
     }
-    
+
 	/**
 	 * @return the fieldInactiveValidValues
 	 */
@@ -1393,5 +1368,5 @@
 	public void setFieldInactiveValidValues(List fieldInactiveValidValues) {
 		this.fieldInactiveValidValues = fieldInactiveValidValues;
 	}
-    
+
 }
\ No newline at end of file
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizations.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizations.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizations.java	(working copy)
@@ -1,175 +1,212 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.io.Serializable;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.log4j.Logger;
-import org.kuali.rice.kns.authorization.FieldAuthorization;
-import org.kuali.rice.kns.web.ui.Field;
-
-/**
- * 
- * This class holds all the information needed to describe the authorization related restrictions for a MaintenanceDocument.
- * 
- * IMPORTANT NOTE: This class defaults to fully editable, if not otherwise specified. So if this class is queried for the status of
- * a field, and the field has not been specified in this class, it will return a FieldAuthorization class populated with the
- * fieldName and EDITABLE.
- * 
- * 
- */
-public class MaintenanceDocumentAuthorizations  implements  Serializable {
-
-    private static final Logger LOG = Logger.getLogger(MaintenanceDocumentAuthorizations.class);
-
-    private Map authFields;
-    private List hiddenSections; // not implemented, does nothing yet
-
-    public MaintenanceDocumentAuthorizations() {
-        authFields = new HashMap();
-        hiddenSections = new ArrayList();
-    }
-
-    /**
-     * 
-     * Returns a collection of all the fields that have non-default authorization restrictions.
-     * 
-     * @return Collection of field names that are restricted
-     * 
-     */
-    public Collection getAuthFieldNames() {
-        return authFields.keySet();
-    }
-
-    /**
-     * 
-     * This method is a convenience method to determine whether there are any restricted fields at all in this
-     * MaintDocAuthorization.
-     * 
-     * If any fields are listed as restricted, this will return true, otherwise it will return false.
-     * 
-     * @return true if any fields restricted, false otherwise
-     * 
-     */
-    public boolean hasAnyFieldRestrictions() {
-
-        boolean anyRestricted = false;
-
-        // walk through each field listed here
-        for (Iterator iter = authFields.keySet().iterator(); iter.hasNext();) {
-            String fieldName = (String) iter.next();
-            FieldAuthorization fieldAuth = getAuthFieldAuthorization(fieldName);
-
-            // if a field is restricted, then we know there are some restricted, so we're done
-            if (fieldAuth.isRestricted()) {
-                return true;
-            }
-        }
-        return anyRestricted;
-    }
-
-    /**
-     * 
-     * This method is a quick way to lookup whether the field has a definition in this authorization. If it isnt defined with some
-     * authorization flag, this returns false.
-     * 
-     * @param fieldName
-     * @return boolean
-     */
-    public boolean hasAuthFieldRestricted(String fieldName) {
-        if (authFields.containsKey(fieldName)) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * 
-     * This method adds a new authorization field instance.
-     * 
-     * @param fieldName
-     * @param authorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE;
-     * 
-     */
-    public void addAuthField(String fieldName, String authorizationFlag) {
-        authFields.put(fieldName, authorizationFlag);
-    }
-
-    /**
-     * This method adds the fieldName specified as Editable.
-     * 
-     * @param fieldName
-     */
-    public void addEditableAuthField(String fieldName) {
-        addAuthField(fieldName, Field.EDITABLE);
-    }
-
-    /**
-     * This method adds the fieldName specified as Read-Only.
-     * 
-     * @param fieldName
-     */
-    public void addReadonlyAuthField(String fieldName) {
-        addAuthField(fieldName, Field.READONLY);
-    }
-
-    /**
-     * This method adds the fieldName specified as Hidden.
-     * 
-     * @param fieldName
-     */
-    public void addHiddenAuthField(String fieldName) {
-        addAuthField(fieldName, Field.HIDDEN);
-    }
-
-    /**
-     * 
-     * Returns a collection of all the sections that have non-default authorization restrictions.
-     * 
-     * @return Collection of section names that are restricted
-     * 
-     */
-    public List getHiddenSectionNames() {
-        return hiddenSections;
-    }
-
-    /**
-     * 
-     * This method returns the authorization setting for the given field name. If the field name is not restricted in any way, a
-     * default full-editable value is returned.
-     * 
-     * @param fieldName - name of field to get authorization restrictions for.
-     * @return a populated FieldAuthorization class for this field
-     * 
-     */
-    public FieldAuthorization getAuthFieldAuthorization(String fieldName) {
-        if (authFields.containsKey(fieldName)) {
-            return new FieldAuthorization(fieldName, (String) authFields.get(fieldName));
-        }
-        else {
-            return new FieldAuthorization(fieldName, Field.EDITABLE);
-        }
-    }
-
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.io.Serializable;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.log4j.Logger;
+import org.kuali.rice.kns.authorization.FieldAuthorization;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+import org.kuali.rice.kns.web.ui.Field;
+
+/**
+ * 
+ * This class holds all the information needed to describe the authorization related restrictions for a MaintenanceDocument.
+ * 
+ * IMPORTANT NOTE: This class defaults to fully editable, if not otherwise specified. So if this class is queried for the status of
+ * a field, and the field has not been specified in this class, it will return a FieldAuthorization class populated with the
+ * fieldName and EDITABLE.
+ * 
+ * 
+ */
+public class MaintenanceDocumentAuthorizations  implements  Serializable {
+
+    private static final Logger LOG = Logger.getLogger(MaintenanceDocumentAuthorizations.class);
+
+    private Map authFields;
+    private Map fieldFormatters;
+    private List hiddenSections; // not implemented, does nothing yet
+
+    public MaintenanceDocumentAuthorizations() {
+        authFields = new HashMap();
+        hiddenSections = new ArrayList();
+        fieldFormatters = new HashMap();
+    }
+
+    /**
+     * 
+     * Returns a collection of all the fields that have non-default authorization restrictions.
+     * 
+     * @return Collection of field names that are restricted
+     * 
+     */
+    public Collection getAuthFieldNames() {
+        return authFields.keySet();
+    }
+
+    /**
+     * 
+     * This method is a convenience method to determine whether there are any restricted fields at all in this
+     * MaintDocAuthorization.
+     * 
+     * If any fields are listed as restricted, this will return true, otherwise it will return false.
+     * 
+     * @return true if any fields restricted, false otherwise
+     * 
+     */
+    public boolean hasAnyFieldRestrictions() {
+
+        boolean anyRestricted = false;
+
+        // walk through each field listed here
+        for (Iterator iter = authFields.keySet().iterator(); iter.hasNext();) {
+            String fieldName = (String) iter.next();
+            FieldAuthorization fieldAuth = getAuthFieldAuthorization(fieldName);
+
+            // if a field is restricted, then we know there are some restricted, so we're done
+            if (fieldAuth.isRestricted()) {
+                return true;
+            }
+        }
+        return anyRestricted;
+    }
+
+    /**
+     * 
+     * This method is a quick way to lookup whether the field has a definition in this authorization. If it isnt defined with some
+     * authorization flag, this returns false.
+     * 
+     * @param fieldName
+     * @return boolean
+     */
+    public boolean hasAuthFieldRestricted(String fieldName) {
+        if (authFields.containsKey(fieldName)) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * 
+     * This method adds a new authorization field instance.
+     * 
+     * @param fieldName
+     * @param authorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE;
+     * 
+     */
+    public void addAuthField(String fieldName, String authorizationFlag) {
+        authFields.put(fieldName, authorizationFlag);
+    }
+   
+
+    /**
+     * This method adds the fieldName specified as Editable.
+     * 
+     * @param fieldName
+     */
+    public void addEditableAuthField(String fieldName) {
+        addAuthField(fieldName, Field.EDITABLE);
+    }
+
+    /**
+     * This method adds the fieldName specified as Read-Only.
+     * 
+     * @param fieldName
+     */
+    public void addReadonlyAuthField(String fieldName) {
+        addAuthField(fieldName, Field.READONLY);
+    }
+
+    /**
+     * This method adds the fieldName specified as Hidden.
+     * 
+     * @param fieldName
+     */
+    public void addHiddenAuthField(String fieldName) {
+        addAuthField(fieldName, Field.HIDDEN);
+    }
+    
+
+    /**
+     * This method adds the fieldName specified as masked.
+     * 
+     * @param fieldName
+     */
+    public void addMaskedAuthField(String fieldName, MaskFormatter maskFormatter) {
+        addAuthField(fieldName, Field.MASKED);
+        addFieldFormatter(fieldName, maskFormatter);
+        
+    }
+
+    /**
+     * This method adds the fieldName specified as partially masked.
+     * 
+     * @param fieldName
+     */
+    public void addPartiallyMaskedAuthField(String fieldName, MaskFormatter partialMaskFormatter) {
+        addAuthField(fieldName, Field.PARTIALLY_MASKED);
+        addFieldFormatter(fieldName, partialMaskFormatter);
+    }
+    
+ 
+    /**
+     * 
+     * Returns a collection of all the sections that have non-default authorization restrictions.
+     * 
+     * @return Collection of section names that are restricted
+     * 
+     */
+    public List getHiddenSectionNames() {
+        return hiddenSections;
+    }
+
+    /**
+     * 
+     * This method returns the authorization setting for the given field name. If the field name is not restricted in any way, a
+     * default full-editable value is returned.
+     * 
+     * @param fieldName - name of field to get authorization restrictions for.
+     * @return a populated FieldAuthorization class for this field
+     * 
+     */
+    public FieldAuthorization getAuthFieldAuthorization(String fieldName) {
+    	//fieldName.replaceAll("(\\[[0-9]*\\])", "");
+    	if (authFields.containsKey(fieldName)) {
+    		FieldAuthorization fieldAuth = new FieldAuthorization(fieldName, (String) authFields.get(fieldName));
+    		if(fieldFormatters.containsKey(fieldName)){
+    			fieldAuth.setMaskFormatter((MaskFormatter) fieldFormatters.get(fieldName));
+    		}
+    		return fieldAuth;
+        }
+        else {
+            return new FieldAuthorization(fieldName, Field.EDITABLE);
+        }
+    }
+    
+    private void addFieldFormatter(String fieldName, MaskFormatter maskFormatter) {
+    	fieldFormatters.put(fieldName, maskFormatter);
+    }
+    
+}
Index: impl/src/main/java/org/kuali/rice/kim/util/DocumentAttributeSecurityUtils.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/DocumentAttributeSecurityUtils.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kim/util/DocumentAttributeSecurityUtils.java	(working copy)
@@ -22,6 +22,7 @@
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.kim.bo.FieldAttributeSecurity;
 import org.kuali.rice.kns.datadictionary.AttributeDefinition;
+import org.kuali.rice.kns.datadictionary.BusinessObjectEntry;
 import org.kuali.rice.kns.datadictionary.MaintainableCollectionDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
@@ -39,16 +40,15 @@
  */
 public class DocumentAttributeSecurityUtils {
 
-	public static Map<String, FieldAttributeSecurity> getRestrictionMaintainableFields(
-			MaintenanceDocumentEntry objectEntry) {
+	public static Map<String, FieldAttributeSecurity> getRestrictionMaintainableFields(MaintenanceDocumentEntry objectEntry) {
 		List<MaintainableSectionDefinition> maintainableSectionDefinitions = objectEntry
 				.getMaintainableSections();
 		Map<String, FieldAttributeSecurity> fieldAttributeSecurities = new HashMap<String, FieldAttributeSecurity>();
 		for (MaintainableSectionDefinition maintainableSectionDefinition : maintainableSectionDefinitions) {
 			List<MaintainableItemDefinition> maintainableItems = maintainableSectionDefinition
 					.getMaintainableItems();
-			getRestrictionMaintainableFieldList(fieldAttributeSecurities,
-					maintainableItems, null, objectEntry.getDocumentTypeName(), KNSConstants.EMPTY_STRING);
+			fieldAttributeSecurities.putAll(getRestrictionMaintainableFieldList(fieldAttributeSecurities,
+					maintainableItems, objectEntry.getBusinessObjectClass(), objectEntry.getDocumentTypeName(), KNSConstants.EMPTY_STRING));
 		}
 		return fieldAttributeSecurities;
 	}
@@ -56,25 +56,29 @@
 	private static Map<String, FieldAttributeSecurity> getRestrictionMaintainableFieldList(
 			Map<String, FieldAttributeSecurity> returnList, List items, Class boClass,
 			String documentTypeName, String key) {
+		if(boClass==null) return null;
 		for (Object item: items) {
 			if (item instanceof MaintainableFieldDefinition) {
 				MaintainableFieldDefinition maintainableFieldDefinition = (MaintainableFieldDefinition) item;
-				//retrieve attribDef from the DD for the BO (DDS.getDD().getBOE(boClass).getAttributeDefinition(item.getName());
-				AttributeDefinition attributeDefinition = 
-					(KNSServiceLocator.getDataDictionaryService().getDataDictionary().getBusinessObjectEntry(
-							boClass.getName()).getAttributeDefinition(maintainableFieldDefinition.getName()));
-
-				if(maintainableFieldDefinition.getAttributeSecurity()!=null || 
-						(attributeDefinition!=null && attributeDefinition.getAttributeSecurity()!=null)){
-					FieldAttributeSecurity fieldAttributeSecurity = new FieldAttributeSecurity();
-					fieldAttributeSecurity.setMaintainableFieldAttributeSecurity(
-							((MaintainableFieldDefinition) item).getAttributeSecurity());
-					fieldAttributeSecurity.setBusinessObjectAttributeSecurity(attributeDefinition.getAttributeSecurity());
-					fieldAttributeSecurity.setAttributeName(maintainableFieldDefinition.getName());
-					fieldAttributeSecurity.setBusinessObjectClass(boClass);
-					fieldAttributeSecurity.setDocumentTypeName(documentTypeName);
-					returnList.put(
-							(StringUtils.isEmpty(key)?"":key+".")+maintainableFieldDefinition.getName(), fieldAttributeSecurity);
+				BusinessObjectEntry businessObejctEntry = KNSServiceLocator.getDataDictionaryService().getDataDictionary().getBusinessObjectEntry(
+						boClass.getName());
+				if(businessObejctEntry!=null){
+					//retrieve attribDef from the DD for the BO (DDS.getDD().getBOE(boClass).getAttributeDefinition(item.getName());
+					AttributeDefinition attributeDefinition = 
+						businessObejctEntry.getAttributeDefinition(maintainableFieldDefinition.getName());
+	
+					if(maintainableFieldDefinition.getAttributeSecurity()!=null || 
+							(attributeDefinition!=null && attributeDefinition.getAttributeSecurity()!=null)){
+						FieldAttributeSecurity fieldAttributeSecurity = new FieldAttributeSecurity();
+						fieldAttributeSecurity.setMaintainableFieldAttributeSecurity(
+								((MaintainableFieldDefinition) item).getAttributeSecurity());
+						fieldAttributeSecurity.setBusinessObjectAttributeSecurity(attributeDefinition.getAttributeSecurity());
+						fieldAttributeSecurity.setAttributeName(maintainableFieldDefinition.getName());
+						fieldAttributeSecurity.setBusinessObjectClass(boClass);
+						fieldAttributeSecurity.setDocumentTypeName(documentTypeName);
+						returnList.put(
+								(StringUtils.isEmpty(key)?"":key+".")+maintainableFieldDefinition.getName(), fieldAttributeSecurity);
+					}
 				}
 			} else if (item instanceof MaintainableCollectionDefinition) {
 				MaintainableCollectionDefinition maintainableCollectionDefinition = (MaintainableCollectionDefinition) item;
Index: impl/src/main/java/org/kuali/rice/kns/service/impl/MaintenanceDocumentDictionaryServiceImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/service/impl/MaintenanceDocumentDictionaryServiceImpl.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/service/impl/MaintenanceDocumentDictionaryServiceImpl.java	(working copy)
@@ -541,7 +541,7 @@
             throw new IllegalArgumentException("invalid fieldName parameter.");
         }
         // if required check we have a value for this field
-        if (maintainableFieldDefinition.isRequired() && !maintainableFieldDefinition.isReadOnly() ) {
+        if (maintainableFieldDefinition.isRequired() && !maintainableFieldDefinition.isUnconditionallyReadOnly() ) {
             try {
                 Object obj = ObjectUtils.getNestedValue(businessObject, fieldName);
 
Index: impl/src/main/java/org/kuali/rice/kns/web/ui/SectionBridge.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/ui/SectionBridge.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/web/ui/SectionBridge.java	(working copy)
@@ -27,6 +27,7 @@
 import org.kuali.rice.kns.bo.BusinessObject;
 import org.kuali.rice.kns.bo.Inactivateable;
 import org.kuali.rice.kns.bo.PersistableBusinessObject;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
 import org.kuali.rice.kns.datadictionary.CollectionDefinitionI;
 import org.kuali.rice.kns.datadictionary.FieldDefinition;
 import org.kuali.rice.kns.datadictionary.FieldDefinitionI;
@@ -51,6 +52,7 @@
 import org.kuali.rice.kns.util.KNSConstants;
 import org.kuali.rice.kns.util.MaintenanceUtils;
 import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
 
 public class SectionBridge {
     private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(SectionBridge.class);
@@ -350,24 +352,38 @@
                             }
 
                             Object propertyValue = ObjectUtils.getPropertyValue(lineBusinessObject, fieldDefinition.getName());
+                            
+                            collField.setPropertyValue(propertyValue);
                             // set field value from business object
                             // check if field contains sensitive data and user is authorized to see value
-                            boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(GlobalVariables.getUserSession().getPerson(), lineBusinessObject.getClass().getName(), name);
-                            if (!viewAuthorized) {
+                            //boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(GlobalVariables.getUserSession().getPerson(), lineBusinessObject.getClass().getName(), name);
+                            //if (!viewAuthorized) {
 
                                 // set mask as field value
-                                Mask propertyMask = KNSServiceLocator.getDataDictionaryService().getAttributeDisplayMask(lineBusinessObject.getClass(), name);
-                                if (propertyMask == null) {
-                                    throw new RuntimeException("No mask specified for secure field.");
-                                }
-
-                                collField.setPropertyValue(propertyMask.maskValue(propertyValue));
-                                collField.setDisplayMaskValue(propertyMask.maskValue(propertyValue));
-
+                                //Mask propertyMask = KNSServiceLocator.getDataDictionaryService().getAttributeDisplayMask(lineBusinessObject.getClass(), name);
+                                //if (propertyMask == null) {
+                                //    throw new RuntimeException("No mask specified for secure field.");
+                                //}
+                            AttributeSecurity attributeSecurity = KNSServiceLocator.getDataDictionaryService().getAttributeSecurity(lineBusinessObject.getClass().getName(), name);
+                            if(attributeSecurity != null && attributeSecurity.isPartialMask()){
+                            	boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToPartiallyUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), lineBusinessObject.getClass().getSimpleName(), name);
+                            	if(!viewAuthorized){
+                            		collField.setPropertyValue(attributeSecurity.getPartialMaskFormatter().maskValue(propertyValue));
+                            		collField.setDisplayMaskValue(attributeSecurity.getPartialMaskFormatter().maskValue(propertyValue));
+                            	}
                             }
-                            else {
-                                collField.setPropertyValue(propertyValue);
+                            if(attributeSecurity != null && attributeSecurity.isMask()){
+                            	boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), lineBusinessObject.getClass().getSimpleName(), name);
+                            	if(!viewAuthorized){
+                            		collField.setPropertyValue(attributeSecurity.getMaskFormatter().maskValue(propertyValue));
+                            		collField.setDisplayMaskValue(attributeSecurity.getMaskFormatter().maskValue(propertyValue));
+                            	}	
                             }
+                                
+                            //}
+                            //else {
+                            //    collField.setPropertyValue(propertyValue);
+                            //}
 
                             // the the field as read only (if appropriate)
                             if (fieldDefinition.isReadOnlyAfterAdd()) {
@@ -513,25 +529,25 @@
                                         }
 
                                         Object propertyValue = ObjectUtils.getPropertyValue(lineSubBusinessObject, fieldDefinition.getName());
-                                        // set field value from business object
-                                        // check if field contains sensitive data and user is authorized to see value
-                                        boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(GlobalVariables.getUserSession().getPerson(), lineSubBusinessObject.getClass().getName(), name);
-                                        if (!viewAuthorized) {
-
-                                            // set mask as field value
-                                            Mask propertyMask = KNSServiceLocator.getDataDictionaryService().getAttributeDisplayMask(lineSubBusinessObject.getClass(), name);
-                                            if (propertyMask == null) {
-                                                throw new RuntimeException("No mask specified for secure field.");
-                                            }
-
-                                            subCollField.setPropertyValue(propertyMask.maskValue(propertyValue));
-                                            subCollField.setDisplayMaskValue(propertyMask.maskValue(propertyValue));
-
+                                        
+                                        subCollField.setPropertyValue(propertyValue);
+                                        
+                                        AttributeSecurity attributeSecurity = KNSServiceLocator.getDataDictionaryService().getAttributeSecurity(lineBusinessObject.getClass().getName(), name);
+                                        if(attributeSecurity != null && attributeSecurity.isPartialMask()){
+                                        	boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToPartiallyUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), lineBusinessObject.getClass().getSimpleName(), name);
+                                        	if(!viewAuthorized){
+                                        		subCollField.setPropertyValue(attributeSecurity.getPartialMaskFormatter().maskValue(propertyValue));
+                                        		subCollField.setDisplayMaskValue(attributeSecurity.getPartialMaskFormatter().maskValue(propertyValue));
+                                        	}
                                         }
-                                        else {
-                                            subCollField.setPropertyValue(propertyValue);
+                                        if(attributeSecurity != null && attributeSecurity.isMask()){
+                                        	boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), lineBusinessObject.getClass().getSimpleName(), name);
+                                        	if(!viewAuthorized){
+                                        		subCollField.setPropertyValue(attributeSecurity.getMaskFormatter().maskValue(propertyValue));
+                                        		subCollField.setDisplayMaskValue(attributeSecurity.getMaskFormatter().maskValue(propertyValue));
+                                        	}	
                                         }
-
+                                     
                                         // check if this is a summary field
                                         if (subCollectionDefinition.hasSummaryField(fieldDefinition.getName())) {
                                             summaryFields.put(fieldDefinition.getName(), subCollField);
@@ -754,4 +770,4 @@
         return false;
     }
 }
-
+
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinition.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinition.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/FieldDefinition.java	(working copy)
@@ -45,6 +45,7 @@
     protected String displayEditMode;
     protected Mask displayMask;
 
+
     public FieldDefinition() {
     }
 
@@ -249,7 +250,6 @@
         return displayMask;
     }
 
-
     /**
      * The displayMask element specifies the type of masking to
                     be used to hide the value from un-authorized users.
@@ -260,6 +260,7 @@
     }
 
 
+    
     public boolean isReadOnlyAfterAdd() {
         return false;
     }
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/exporter/AttributesMapBuilder.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/exporter/AttributesMapBuilder.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/exporter/AttributesMapBuilder.java	(working copy)
@@ -92,6 +92,10 @@
             attributeMap.set("displayWorkgroup", attribute.getDisplayWorkgroup());
             attributeMap.set("displayMaskClass",attribute.getDisplayMask().getClass().toString());
         }
+        
+        if(attribute.hasAttributeSecurity()){
+        	attributeMap.set("attributeSecurityClass", attribute.getDisplayMask().getClass().toString());
+        }
 
         attributeMap.set(buildControlMap(attribute));
         attributeMap.set("fullClassName", fullClassName);
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizerBase.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizerBase.java	(working copy)
@@ -1,576 +1,645 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.kuali.rice.core.util.RiceConstants;
-import org.kuali.rice.kew.dto.ActionRequestDTO;
-import org.kuali.rice.kew.dto.UserDTO;
-import org.kuali.rice.kew.dto.ValidActionsDTO;
-import org.kuali.rice.kew.exception.WorkflowException;
-import org.kuali.rice.kew.util.KEWConstants;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
-import org.kuali.rice.kns.exception.PessimisticLockingException;
-import org.kuali.rice.kns.service.AuthorizationService;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.KualiConfigurationService;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.util.ObjectUtils;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowInfo;
-
-
-/**
- * DocumentAuthorizer containing common, reusable document-level authorization code.
- */
-public class DocumentAuthorizerBase implements DocumentAuthorizer {
-    private static Log LOG = LogFactory.getLog(DocumentAuthorizerBase.class);
-    
-    public static final String EDIT_MODE_DEFAULT_TRUE_VALUE = "TRUE";
-    public static final String USER_SESSION_METHOD_TO_CALL_OBJECT_KEY = "METHOD_TO_CALL_KEYS_METHOD_OBJECT_KEY";
-    public static final String USER_SESSION_METHOD_TO_CALL_COMPLETE_OBJECT_KEY = "METHOD_TO_CALL_KEYS_COMPLETE_OBJECT_KEY";
-
-    private static AuthorizationService authorizationService;
-    private static KualiWorkflowInfo kualiWorkflowInfo;
-    private static KualiConfigurationService kualiConfigurationService;
-
-    /**
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public Map getEditMode(Document d, Person u) {
-        Map editModeMap = new HashMap();
-        String editMode = AuthorizationConstants.EditMode.VIEW_ONLY;
-
-        KualiWorkflowDocument workflowDocument = d.getDocumentHeader().getWorkflowDocument();
-        if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-            if (hasInitiateAuthorization(d, u)) {
-                editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
-            }
-        }
-        else if (workflowDocument.stateIsEnroute() && workflowDocument.isApprovalRequested()) {
-            editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
-        }
-
-        editModeMap.put(editMode, EDIT_MODE_DEFAULT_TRUE_VALUE);
-
-        return editModeMap;
-    }
-    
-    /**
-     * Individual document families will need to reimplement this according to their own needs; this version should be good enough
-     * to be usable during initial development.
-     *
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-        LOG.debug("calling DocumentAuthorizerBase.getDocumentActionFlags for document '" + document.getDocumentNumber() + "'. user '" + user.getPrincipalName() + "'");
-
-        DocumentActionFlags flags = new DocumentActionFlags(); // all flags default to false
-
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-        boolean hasInitiateAuthorization = hasInitiateAuthorization(document, user);
-
-        flags.setCanClose(true); // can always close a document
-
-        // if a document is canceled, everything other than close should be set to false
-        // if a document is NOT canceled, then we want to process the rest
-        if (!workflowDocument.stateIsCanceled()) {
-            flags.setCanReload(!workflowDocument.stateIsInitiated());
-
-            flags.setCanBlanketApprove(workflowDocument.isBlanketApproveCapable());
-
-            // The only exception to the supervisor user canSupervise is when the supervisor
-            // user is also the initiator, and does NOT have an approval request. In other words if they
-            // are the document initiator, and its still in Initiated or Saved phase, they cant have access
-            // to the supervisor buttons. If they're the initiator, but for some reason they are also
-            // approving the document, then they can have the supervisor button & functions.
-            boolean canSuperviseAsInitiator = !(hasInitiateAuthorization && !workflowDocument.isApprovalRequested());
-            flags.setCanSupervise(org.kuali.rice.kim.service.KIMServiceLocator.getIdentityManagementService().isMemberOfGroup(user.getPrincipalId(), org.kuali.rice.kim.util.KimConstants.TEMP_GROUP_NAMESPACE,	KNSServiceLocator.getKualiConfigurationService().getParameterValue(KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.CoreApcParms.SUPERVISOR_WORKGROUP)) && canSuperviseAsInitiator);
-
-            // default normal documents to be unable to copy
-            flags.setCanCopy(false);
-            // default route report to false and set individually based on workflow doc status below
-            flags.setCanPerformRouteReport(allowsPerformRouteReport(document, user));
-
-            if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-                ValidActionsDTO validActions = workflowDocument.getRouteHeader().getValidActions();
-                boolean hasPreRouteEditAuthorization = hasPreRouteEditAuthorization(document, user);
-                flags.setCanCancel(hasPreRouteEditAuthorization && validActions.contains(KEWConstants.ACTION_TAKEN_CANCELED_CD));
-
-                flags.setCanSave(hasPreRouteEditAuthorization && validActions.contains(KEWConstants.ACTION_TAKEN_SAVED_CD));
-
-                flags.setCanRoute(hasPreRouteEditAuthorization && validActions.contains(KEWConstants.ACTION_TAKEN_ROUTED_CD));
-
-                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
-                flags.setCanFYI(workflowDocument.isFYIRequested());
-
-                flags.setCanAdHocRoute(flags.getCanSave() || flags.getCanRoute());
-            }
-            else if (workflowDocument.stateIsEnroute()) {
-                flags.setCanApprove(workflowDocument.isApprovalRequested());
-
-                flags.setCanDisapprove(workflowDocument.isApprovalRequested());
-
-                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
-                flags.setCanFYI(workflowDocument.isFYIRequested());
-
-                flags.setCanAdHocRoute(workflowDocument.isApprovalRequested() || workflowDocument.isAcknowledgeRequested());
-            }
-            else if (workflowDocument.stateIsApproved() || workflowDocument.stateIsFinal() || workflowDocument.stateIsDisapproved()) {
-                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
-                flags.setCanFYI(workflowDocument.isFYIRequested());
-
-                flags.setCanAdHocRoute(false);
-            }
-            else if (workflowDocument.stateIsException()) {
-            try {
-                    ActionRequestDTO[] requests = getKualiWorkflowInfo().getActionRequests(workflowDocument.getRouteHeaderId());
-                    boolean reqFound = false;
-                    for ( ActionRequestDTO req : requests ) {
-                        if ( req.isExceptionRequest() && req.getActionTakenId() == null ) {
-                        if ( req.getWorkgroupDTO() != null ) {
-                        UserDTO[] users = req.getWorkgroupDTO().getMembers();
-                        for ( UserDTO usr : users ) {
-                            if ( usr.getUuId().equals( user.getPrincipalId() ) ) {
-                            flags.setCanCancel( true );
-                                    flags.setCanApprove( true );
-                                    flags.setCanDisapprove( true );
-                                    reqFound = true; // used to break out of outer loop
-                                    break;
-                            }
-                        }
-                        if ( reqFound ) {
-                            break;
-                        }
-                        } else {
-                        LOG.error( "Unable to retrieve user list for exception workgroup.  ActionRequestVO.getWorkgroupVO() returned null" );
-                        LOG.error( "request: " + req );
-                        }
-                    }
-                    }
-            } catch( WorkflowException ex ) {
-                LOG.error("Unable to retrieve action requests for document: " + document.getDocumentNumber(),ex);
-            }
-
-                flags.setCanAdHocRoute(false);
-            }
-        }
-
-        setAnnotateFlag(flags);
-
-        return flags;
-    }
-    
-    protected KualiConfigurationService getKualiConfigurationService() {
-    if ( kualiConfigurationService == null ) {
-        kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
-    }
-    return kualiConfigurationService;
-    }
-    
-    protected AuthorizationService getAuthorizationService() {
-    if ( authorizationService == null ) {
-        authorizationService = KNSServiceLocator.getAuthorizationService();
-    }
-    return authorizationService;
-    }
-    
-    protected KualiWorkflowInfo getKualiWorkflowInfo() {
-    if ( kualiWorkflowInfo == null ) {
-        kualiWorkflowInfo = KNSServiceLocator.getWorkflowInfoService();
-    }
-    return kualiWorkflowInfo;
-    }
-    
-    /**
-     * Helper method to disallow the perform route report button globally for a particular authorizer class
-     * @param document - current document
-     * @param user - current user
-     * @return boolean to allow or disallow route report button to show for user
-     */
-    public boolean allowsPerformRouteReport(Document document, Person user) {
-        KualiConfigurationService kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
-        return kualiConfigurationService.getIndicatorParameter( KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.SystemGroupParameterNames.DEFAULT_CAN_PERFORM_ROUTE_REPORT_IND);
-    }
-
-    /**
-     * Helper method to set the annotate flag based on other workflow tags
-     * @param flags
-     */
-    public void setAnnotateFlag(DocumentActionFlags flags) {
-        boolean canWorkflow = flags.getCanSave() || flags.getCanRoute() || flags.getCanCancel() || flags.getCanBlanketApprove() || flags.getCanApprove() || flags.getCanDisapprove() || flags.getCanAcknowledge() || flags.getCanAdHocRoute();
-        flags.setCanAnnotate(canWorkflow);
-    }
-
-    /**
-     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public void canInitiate(String documentTypeName, Person user) {
-        if (!getAuthorizationService().isAuthorized(user, "initiate", documentTypeName)) {
-            // build authorized workgroup list for error message
-            Set authorizedWorkgroups = getAuthorizationService().getAuthorizedWorkgroups("initiate", documentTypeName);
-            String workgroupList = StringUtils.join(authorizedWorkgroups.toArray(), ",");
-            throw new DocumentInitiationAuthorizationException(new String[] {workgroupList,documentTypeName});
-        }
-    }
-
-    /**
-     * Default implementation here is if a user cannot initiate a document they cannot copy one.
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canCopy(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public boolean canCopy(String documentTypeName, Person user) {
-        return getAuthorizationService().isAuthorized(user, "initiate", documentTypeName);
-    }
-
-    /**
-     * This method checks to see if a document is using Pessimistic Locking first. If the document is not using Pessimistic
-     * Locking this method will return the value returned by {@link #hasInitiateAuthorization(Document, Person)}. If
-     * the document is using pessimistic locking and the value of {@link #hasInitiateAuthorization(Document, Person)}
-     * is true, the system will check to see that the given user has a lock on the document and return true if one is found.
-     * 
-     * @param document - document to check
-     * @param user - current user
-     * @return true if the document is using Pessimistic Locking, the user has initiate authorization (see
-     *         {@link #hasInitiateAuthorization(Document, Person)}), and the document has a lock owned by the given
-     *         user. If the document is not using Pessimistic Locking the value returned will be that returned by
-     *         {@link #hasInitiateAuthorization(Document, Person)}.
-     */
-    public boolean hasPreRouteEditAuthorization(Document document, Person user) {
-        if (usesPessimisticLocking(document)) {
-            if (hasInitiateAuthorization(document, user)) {
-                for (Iterator iterator = document.getPessimisticLocks().iterator(); iterator.hasNext();) {
-                    PessimisticLock lock = (PessimisticLock) iterator.next();
-                    if (lock.isOwnedByUser(user)) {
-                        return true;
-                    }
-                }
-            }
-            return false;
-        } else {
-            return hasInitiateAuthorization(document, user);
-        }
-    }
-    
-    protected boolean usesPessimisticLocking(Document document) {
-        return KNSServiceLocator.getDataDictionaryService().getDataDictionary().getDocumentEntry(document.getClass().getName()).getUsePessimisticLocking();
-    }
-    
-    /**
-     * Determines whether the given user should have initiate permissions on the given document.
-     * @param document - current document
-     * @param user - current user
-     * @return boolean (true if they should have permissions)
-     */
-    public boolean hasInitiateAuthorization(Document document, Person user) {
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-        return workflowDocument.getInitiatorNetworkId().equalsIgnoreCase(user.getPrincipalName());
-    }
-
-    /**
-     * Determines whether the given user should be able to view the attachment on the given document
-     * and the attachment type
-     * @param attachmentTypeName - the attachment type
-     * @param document - current document
-     * @param user - current user
-     * @return boolean (true if they should have permissions)
-     */
-    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user) {
-        return true;
-    }
-
-    /**
-     * This method creates a new {@link PessimisticLock} when Workflow processing requires one
-     * 
-     * @param document - the document to create the lock against and add the lock to
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
-     */
-    public void establishWorkflowPessimisticLocking(Document document) {
-        PessimisticLock lock = createNewPessimisticLock(document, new HashMap(), getWorkflowPessimisticLockOwnerUser());
-        document.addPessimisticLock(lock);
-    }
-    
-    /**
-     * This method releases locks created via the {@link #establishWorkflowPessimisticLocking(Document)} method for the given document
-     * 
-     * @param document - document to release locks from
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#releaseWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
-     */
-    public void releaseWorkflowPessimisticLocking(Document document) {
-        KNSServiceLocator.getPessimisticLockService().releaseAllLocksForUser(document.getPessimisticLocks(), getWorkflowPessimisticLockOwnerUser());
-        document.refreshPessimisticLocks();
-    }
-
-    /**
-     * This method identifies the user that should be used to create and clear {@link PessimisticLock} objects required by
-     * Workflow.<br>
-     * <br>
-     * The default is the Kuali system user defined by {@link RiceConstants#SYSTEM_USER}. This method can be overriden by
-     * implementing documents if another user is needed.
-     * 
-     * @return a valid {@link Person} object
-     */
-    protected Person getWorkflowPessimisticLockOwnerUser() {
-        String networkId = KNSConstants.SYSTEM_USER;
-        return org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().getPersonByPrincipalName(networkId);
-    }
-    
-    /**
-     * This implementation will check the given document, editMode map, and user object to verify Pessimistic Locking. If the
-     * given edit mode map contains an 'entry type' edit mode then the system will check the locks already in existance on
-     * the document. If a valid lock for the given user is found the system will return the given edit mode map. If a valid
-     * lock is found but is owned by another user the edit mode map returned will have any 'entry type' edit modes removed. If the
-     * given document has no locks and the edit mode map passed in has at least one 'entry type' mode then a new
-     * {@link PessimisticLock} object will be created and set on the document for the given user.<br>
-     * <br> 
-     * NOTE: This method is only called if the document uses pessimistic locking as described in the data dictionary file.
-     * 
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishLocks(org.kuali.rice.kns.document.Document,
-     *      java.util.Map, org.kuali.rice.kim.bo.Person)
-     */
-    public Map establishLocks(Document document, Map editMode, Person user) {
-        Map editModeMap = new HashMap();
-        // givenUserLockDescriptors is a list of lock descriptors currently held on the document by the given user
-        List<String> givenUserLockDescriptors = new ArrayList<String>();
-        // lockDescriptorUsers is a map with lock descriptors as keys and users other than the given user who hold a lock of each descriptor 
-        Map<String,Set<Person>> lockDescriptorUsers = new HashMap<String,Set<Person>>();
-
-        // build the givenUserLockDescriptors set and the lockDescriptorUsers map
-        for (PessimisticLock lock : document.getPessimisticLocks()) {
-            if (lock.isOwnedByUser(user)) {
-                // lock is owned by given user
-                givenUserLockDescriptors.add(lock.getLockDescriptor());
-            } else {
-                // lock is not owned by the given user
-                if (!lockDescriptorUsers.containsKey(lock.getLockDescriptor())) {
-                    lockDescriptorUsers.put(lock.getLockDescriptor(), new HashSet<Person>());
-                }
-                ((Set<Person>) lockDescriptorUsers.get(lock.getLockDescriptor())).add(lock.getOwnedByUser());
-            }
-        }
-
-        // verify that no locks held by current user exist for any other user
-        for (String givenUserLockDescriptor : givenUserLockDescriptors) {
-            if ( (lockDescriptorUsers.containsKey(givenUserLockDescriptor)) && (lockDescriptorUsers.get(givenUserLockDescriptor).size() > 0) ) {
-                Set<Person> users = lockDescriptorUsers.get(givenUserLockDescriptor);
-                if ( (users.size() != 1) || (!getWorkflowPessimisticLockOwnerUser().getPrincipalId().equals(users.iterator().next().getPrincipalId())) ) {
-                    String descriptorText = (useCustomLockDescriptors()) ? " using lock descriptor '" + givenUserLockDescriptor + "'" : "";
-                    String errorMsg = "Found an invalid lock status on document number " + document.getDocumentNumber() + "with current user and other user both having locks" + descriptorText + " concurrently";
-                    LOG.debug(errorMsg);
-                    throw new PessimisticLockingException(errorMsg);
-                }
-            }
-        }
-        
-        // check to see if the given user has any locks in the system at all
-        if (givenUserLockDescriptors.isEmpty()) {
-            // given user has no locks... check for other user locks
-            if (lockDescriptorUsers.isEmpty()) {
-                // no other user has any locks... set up locks for given user if user has edit privileges
-                if (isLockRequiredByUser(document, editMode, user)) {
-                    document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
-                }
-                editModeMap.putAll(editMode);
-            } else {
-                // at least one other user has at least one other lock... adjust edit mode for read only
-                if (useCustomLockDescriptors()) {
-                    // check to see if the custom lock descriptor is already in use
-                    String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
-                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
-                        // at least one other user has this descriptor locked... remove editable edit modes
-                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
-                    } else {
-                        // no other user has a lock with this descriptor
-                        if (isLockRequiredByUser(document, editMode, user)) {
-                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
-                        }
-                        editModeMap.putAll(editMode);
-                    }
-                } else {
-                    editModeMap = getEditModeWithEditableModesRemoved(editMode);
-                }
-            }
-        } else {
-            // given user already has at least one lock descriptor
-            if (useCustomLockDescriptors()) {
-                // get the custom lock descriptor and check to see if if the given user has a lock with that descriptor
-                String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
-                if (givenUserLockDescriptors.contains(customLockDescriptor)) {
-                    // user already has lock that is required
-                    editModeMap.putAll(editMode);
-                } else {
-                    // user does not have lock for descriptor required
-                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
-                        // another user has the lock descriptor that the given user requires... disallow lock and alter edit modes to have read only
-                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
-                    } else {
-                        // no other user has a lock with this descriptor... check if this user needs a lock
-                        if (isLockRequiredByUser(document, editMode, user)) {
-                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
-                        }
-                        editModeMap.putAll(editMode);
-                    }
-                }
-            } else {
-                // user already has lock and no descriptors are being used... use the existing edit modes
-                editModeMap.putAll(editMode);
-            }
-        }
-
-        return editModeMap;
-    }
-    
-    /**
-     * This method is used to check if the given parameters warrant a new lock to be created for the given user. This method
-     * utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method.
-     * 
-     * @param document -
-     *            document to verify lock creation against
-     * @param editMode -
-     *            edit modes list to check for 'entry type' edit modes
-     * @param user -
-     *            user the lock will be 'owned' by
-     * @return true if the given edit mode map has at least one 'entry type' edit mode... false otherwise
-     */
-    protected boolean isLockRequiredByUser(Document document, Map editMode, Person user) {
-        // check for entry edit mode
-        for (Iterator iterator = editMode.entrySet().iterator(); iterator.hasNext();) {
-            Map.Entry entry = (Map.Entry) iterator.next();
-            if (isEntryEditMode(entry)) {
-                return true;
-            }
-        }
-        return false;
-    }
-    
-   /**
-     * This method is used to remove edit modes from the given map that allow the user to edit data on the document. This
-     * method utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method to identify if an edit mode is defined as an
-     * 'entry type' edit mode. It also uses the {@link #getEntryEditModeReplacementMode(java.util.Map.Entry)} method to replace
-     * any 'entry type' edit modes it finds.
-     * 
-     * @param currentEditMode -
-     *            current set of edit modes the user has assigned to them
-     * @return an adjusted edit mode map where 'entry type' edit modes have been removed or replaced using the
-     *         {@link #getEntryEditModeReplacementMode()} method
-     */
-    protected Map getEditModeWithEditableModesRemoved(Map currentEditMode) {
-        Map editModeMap = new HashMap();
-        for (Iterator iterator = currentEditMode.entrySet().iterator(); iterator.hasNext();) {
-            Map.Entry entry = (Map.Entry) iterator.next();
-            if (isEntryEditMode(entry)) {
-                editModeMap.putAll(getEntryEditModeReplacementMode(entry));
-            } else {
-                editModeMap.put(entry.getKey(), entry.getValue());
-            }
-        }
-        return editModeMap;
-    }
-    
-    /**
-     * This method is used to check if the given {@link Map.Entry} is an 'entry type' edit mode and that the value is set to
-     * signify that this user has that edit mode available to them
-     * 
-     * @param entry -
-     *            the {@link Map.Entry} object that contains an edit mode such as the ones returned but
-     *            {@link #getEditMode(Document, Person)}
-     * @return true if the given entry has a key signifying an 'entry type' edit mode and the value is equal to
-     *         {@link #EDIT_MODE_DEFAULT_TRUE_VALUE}... false if not
-     */
-    protected boolean isEntryEditMode(Map.Entry entry) {
-        // check for FULL_ENTRY edit mode set to default true value
-        if (AuthorizationConstants.EditMode.FULL_ENTRY.equals(entry.getKey())) {
-            String fullEntryEditModeValue = (String)entry.getValue();
-            return ( (ObjectUtils.isNotNull(fullEntryEditModeValue)) && (EDIT_MODE_DEFAULT_TRUE_VALUE.equals(fullEntryEditModeValue)) );
-        }
-        return false;
-    }
-    
-    /**
-     * This method is used to return values needed to replace the given 'entry type' edit mode {@link Map.Entry} with one that will not allow the user to enter data on the document 
-     * 
-     * @param entry - the current 'entry type' edit mode to replace 
-     * @return a Map of edit modes that will be used to replace this edit mode (represented by the given entry parameter)
-     */
-    protected Map getEntryEditModeReplacementMode(Map.Entry entry) {
-        Map editMode = new HashMap();
-        editMode.put(AuthorizationConstants.EditMode.VIEW_ONLY, EDIT_MODE_DEFAULT_TRUE_VALUE);
-        return editMode;
-    }
-    
-    /**
-     * This method creates a new {@link PessimisticLock} object using the given document and user. If the
-     * {@link #useCustomLockDescriptors()} method returns true then the new lock will also have a custom lock descriptor
-     * value set to the return value of {@link #getCustomLockDescriptor(Document, Map, Person)}.
-     * 
-     * @param document -
-     *            document to place the lock on
-     * @param editMode -
-     *            current edit modes for given user
-     * @param user -
-     *            user who will 'own' the new lock object
-     * @return the newly created lock object
-     */
-    protected PessimisticLock createNewPessimisticLock(Document document, Map editMode, Person user) {
-        if (useCustomLockDescriptors()) {
-            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), getCustomLockDescriptor(document, editMode, user), user);
-        } else {
-            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), user);
-        }
-    }
-    
-    /**
-     * This method should be overriden by groups requiring the lock descriptor field in the {@link PessimisticLock} objects.
-     * If it is not overriden and {@link #useCustomLockDescriptors()} returns true then this method will throw a
-     * {@link PessimisticLockingException}
-     * 
-     * @param document - document being checked for locking
-     * @param editMode - editMode generated for passed in user
-     * @param user - user attempting to establish locks
-     * @return a {@link PessimisticLockingException} will be thrown as the default implementation
-     */
-    protected String getCustomLockDescriptor(Document document, Map editMode, Person user) {
-        throw new PessimisticLockingException("Document " + document.getDocumentNumber() + " is using Pessimistic Locking with lock descriptors but the authorizer class has not defined the getCustomLockDescriptor() method");
-    }
-
-    /**
-     * This method should be used to define Document Authorizer classes which will use custom lock descriptors in the
-     * {@link PessimisticLock} objects NOTE: if this method is overriden to return true then the method
-     * {@link #getCustomLockDescriptor(Document, Map, Person)} must be overriden
-     * 
-     * @return false if the document will not be using lock descriptors or true if the document will use lock descriptors.
-     *         The default return value is false
-     */
-    protected boolean useCustomLockDescriptors() {
-        return false;
-    }
-    
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.core.util.RiceConstants;
+import org.kuali.rice.kew.dto.ActionRequestDTO;
+import org.kuali.rice.kew.dto.UserDTO;
+import org.kuali.rice.kew.dto.ValidActionsDTO;
+import org.kuali.rice.kew.exception.WorkflowException;
+import org.kuali.rice.kew.util.KEWConstants;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.service.IdentityManagementService;
+import org.kuali.rice.kim.service.KIMServiceLocator;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
+import org.kuali.rice.kns.exception.PessimisticLockingException;
+import org.kuali.rice.kns.service.AuthorizationService;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.KualiConfigurationService;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowInfo;
+
+
+/**
+ * DocumentAuthorizer containing common, reusable document-level authorization code.
+ */
+public class DocumentAuthorizerBase implements DocumentAuthorizer {
+    private static Log LOG = LogFactory.getLog(DocumentAuthorizerBase.class);
+    
+    public static final String EDIT_MODE_DEFAULT_TRUE_VALUE = "TRUE";
+    public static final String USER_SESSION_METHOD_TO_CALL_OBJECT_KEY = "METHOD_TO_CALL_KEYS_METHOD_OBJECT_KEY";
+    public static final String USER_SESSION_METHOD_TO_CALL_COMPLETE_OBJECT_KEY = "METHOD_TO_CALL_KEYS_COMPLETE_OBJECT_KEY";
+
+    private static AuthorizationService authorizationService;
+    private static KualiWorkflowInfo kualiWorkflowInfo;
+    private static KualiConfigurationService kualiConfigurationService;
+    private static IdentityManagementService identityManagementService;
+    
+    /**
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public Map getEditMode(Document d, Person u) {
+        Map editModeMap = new HashMap();
+        String editMode = AuthorizationConstants.EditMode.VIEW_ONLY;
+
+        KualiWorkflowDocument workflowDocument = d.getDocumentHeader().getWorkflowDocument();
+        if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+            if (hasInitiateAuthorization(d, u)) {
+                editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
+            }
+        }
+        else if (workflowDocument.stateIsEnroute() && workflowDocument.isApprovalRequested()) {
+            editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
+        }
+
+        editModeMap.put(editMode, EDIT_MODE_DEFAULT_TRUE_VALUE);
+
+        return editModeMap;
+    }
+    
+    /**
+     * 
+     * This method is used to get overall document edit permission
+     * 
+     * @param document
+     * @param user
+     * @return
+     */
+    public boolean isViewOnly(Document document, Person user){
+    	boolean isViewOnly = true;
+    	//TODO: Should use ParameterService getNameSpace to get name space
+        String nameSpaceCode = "KR-NS";
+    	
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+    	String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();
+    	String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+    	
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentType);
+    	AttributeSet qualifications = null;
+    	
+    	
+    	if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+    		permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, KimConstants.KIM_AD_HOC);
+    		qualifications = new AttributeSet();
+        	qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, document.getDocumentNumber());
+         }else{
+        	 permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+         }
+
+ 	   //TODO: InitiatorRoleTypeService is only used for testing. 
+ 	   if(getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_DOCUMENT, permissionDetails, qualifications)){
+ 		   isViewOnly = false;
+	   }
+ 	   
+    	return isViewOnly;
+    }
+
+    
+    /**
+     * Individual document families will need to reimplement this according to their own needs; this version should be good enough
+     * to be usable during initial development.
+     *
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+        LOG.debug("calling DocumentAuthorizerBase.getDocumentActionFlags for document '" + document.getDocumentNumber() + "'. user '" + user.getPrincipalName() + "'");
+
+        DocumentActionFlags flags = new DocumentActionFlags(); // all flags default to false
+
+        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+        boolean hasInitiateAuthorization = hasInitiateAuthorization(document, user);
+        
+        //TODO:
+    	String nameSpaceCode = "KR-WKFLW";
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, workflowDocument.getDocumentType());
+    	
+
+        flags.setCanClose(true); // can always close a document
+
+        // if a document is canceled, everything other than close should be set to false
+        // if a document is NOT canceled, then we want to process the rest
+        if (!workflowDocument.stateIsCanceled()) {
+            flags.setCanReload(!workflowDocument.stateIsInitiated());
+            
+            //flags.setCanBlanketApprove(workflowDocument.isBlanketApproveCapable());
+            flags.setCanBlanketApprove(getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_BLANKET_APPROVE_DOCUMENT, permissionDetails, null));
+           
+	            
+            // The only exception to the supervisor user canSupervise is when the supervisor
+            // user is also the initiator, and does NOT have an approval request. In other words if they
+            // are the document initiator, and its still in Initiated or Saved phase, they cant have access
+            // to the supervisor buttons. If they're the initiator, but for some reason they are also
+            // approving the document, then they can have the supervisor button & functions.
+            
+            boolean canSuperviseAsInitiator = !(hasInitiateAuthorization && !workflowDocument.isApprovalRequested());
+            flags.setCanSupervise(org.kuali.rice.kim.service.KIMServiceLocator.getIdentityManagementService().isMemberOfGroup(user.getPrincipalId(), org.kuali.rice.kim.util.KimConstants.TEMP_GROUP_NAMESPACE,	KNSServiceLocator.getKualiConfigurationService().getParameterValue(KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.CoreApcParms.SUPERVISOR_WORKGROUP)) && canSuperviseAsInitiator);
+
+            // default normal documents to be unable to copy
+            flags.setCanCopy(false);
+            // default route report to false and set individually based on workflow doc status below
+            //flags.setCanPerformRouteReport(allowsPerformRouteReport(document, user));
+            //TODO:PerformRouteReport permission is not in perm table
+            flags.setCanPerformRouteReport( getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PERFORM_ROUTE_REPORT, permissionDetails, null));
+
+            if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+                //ValidActionsDTO validActions = workflowDocument.getRouteHeader().getValidActions();
+                boolean hasPreRouteEditAuthorization = hasPreRouteEditAuthorization(document, user);
+                flags.setCanCancel(hasPreRouteEditAuthorization &&
+                		           getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_CANCEL_DOCUMENT, permissionDetails, null));
+
+                flags.setCanSave(hasPreRouteEditAuthorization && 
+                				 getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_SAVE_DOCUMENT, permissionDetails, null));
+
+                flags.setCanRoute(hasPreRouteEditAuthorization && 
+                				  getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_ROUTE_DOCUMENT, permissionDetails, null));
+
+                
+                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
+                flags.setCanFYI(workflowDocument.isFYIRequested());
+                
+                flags.setCanAdHocRoute(flags.getCanSave() || flags.getCanRoute());
+            }
+            else if (workflowDocument.stateIsEnroute()) {
+            	flags.setCanApprove(workflowDocument.isApprovalRequested());
+
+                flags.setCanDisapprove(workflowDocument.isApprovalRequested());
+
+                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
+                flags.setCanFYI(workflowDocument.isFYIRequested());
+                
+                flags.setCanAdHocRoute(workflowDocument.isApprovalRequested() || workflowDocument.isAcknowledgeRequested());
+
+            }
+            else if (workflowDocument.stateIsApproved() || workflowDocument.stateIsFinal() || workflowDocument.stateIsDisapproved()) {
+                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
+                flags.setCanFYI(workflowDocument.isFYIRequested());
+
+                flags.setCanAdHocRoute(false);
+            }
+            else if (workflowDocument.stateIsException()) {
+            try {
+                    ActionRequestDTO[] requests = getKualiWorkflowInfo().getActionRequests(workflowDocument.getRouteHeaderId());
+                    boolean reqFound = false;
+                    for ( ActionRequestDTO req : requests ) {
+                        if ( req.isExceptionRequest() && req.getActionTakenId() == null ) {
+                        if ( req.getWorkgroupDTO() != null ) {
+                        UserDTO[] users = req.getWorkgroupDTO().getMembers();
+                        for ( UserDTO usr : users ) {
+                            if ( usr.getUuId().equals( user.getPrincipalId() ) ) {
+                            flags.setCanCancel( true );
+                                    flags.setCanApprove( true );
+                                    flags.setCanDisapprove( true );
+                                    reqFound = true; // used to break out of outer loop
+                                    break;
+                            }
+                        }
+                        if ( reqFound ) {
+                            break;
+                        }
+                        } else {
+                        LOG.error( "Unable to retrieve user list for exception workgroup.  ActionRequestVO.getWorkgroupVO() returned null" );
+                        LOG.error( "request: " + req );
+                        }
+                    }
+                    }
+            } catch( WorkflowException ex ) {
+                LOG.error("Unable to retrieve action requests for document: " + document.getDocumentNumber(),ex);
+            }
+
+                flags.setCanAdHocRoute(false);
+            }
+        }
+
+        setAnnotateFlag(flags);
+
+        return flags;
+    }
+    
+    protected KualiConfigurationService getKualiConfigurationService() {
+    if ( kualiConfigurationService == null ) {
+        kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+    }
+    return kualiConfigurationService;
+    }
+    
+    protected AuthorizationService getAuthorizationService() {
+    if ( authorizationService == null ) {
+        authorizationService = KNSServiceLocator.getAuthorizationService();
+    }
+    return authorizationService;
+    }
+    
+    protected KualiWorkflowInfo getKualiWorkflowInfo() {
+    if ( kualiWorkflowInfo == null ) {
+        kualiWorkflowInfo = KNSServiceLocator.getWorkflowInfoService();
+    }
+    return kualiWorkflowInfo;
+    }
+    
+    /**
+     * Helper method to disallow the perform route report button globally for a particular authorizer class
+     * @param document - current document
+     * @param user - current user
+     * @return boolean to allow or disallow route report button to show for user
+     */
+    public boolean allowsPerformRouteReport(Document document, Person user) {
+        KualiConfigurationService kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+        return kualiConfigurationService.getIndicatorParameter( KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.SystemGroupParameterNames.DEFAULT_CAN_PERFORM_ROUTE_REPORT_IND);
+    }
+
+    /**
+     * Helper method to set the annotate flag based on other workflow tags
+     * @param flags
+     */
+    public void setAnnotateFlag(DocumentActionFlags flags) {
+        boolean canWorkflow = flags.getCanSave() || flags.getCanRoute() || flags.getCanCancel() || flags.getCanBlanketApprove() || flags.getCanApprove() || flags.getCanDisapprove() || flags.getCanAcknowledge() || flags.getCanAdHocRoute();
+        flags.setCanAnnotate(canWorkflow);
+    }
+
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public void canInitiate(String documentTypeName, Person user) {
+    	
+    }
+
+    /**
+     * Default implementation here is if a user cannot initiate a document they cannot copy one.
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canCopy(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public boolean canCopy(String documentTypeName, Person user) {
+        return false;
+    }
+
+    /**
+     * This method checks to see if a document is using Pessimistic Locking first. If the document is not using Pessimistic
+     * Locking this method will return the value returned by {@link #hasInitiateAuthorization(Document, Person)}. If
+     * the document is using pessimistic locking and the value of {@link #hasInitiateAuthorization(Document, Person)}
+     * is true, the system will check to see that the given user has a lock on the document and return true if one is found.
+     * 
+     * @param document - document to check
+     * @param user - current user
+     * @return true if the document is using Pessimistic Locking, the user has initiate authorization (see
+     *         {@link #hasInitiateAuthorization(Document, Person)}), and the document has a lock owned by the given
+     *         user. If the document is not using Pessimistic Locking the value returned will be that returned by
+     *         {@link #hasInitiateAuthorization(Document, Person)}.
+     */
+    public boolean hasPreRouteEditAuthorization(Document document, Person user) {
+        if (usesPessimisticLocking(document)) {
+            if (hasInitiateAuthorization(document, user)) {
+                for (Iterator iterator = document.getPessimisticLocks().iterator(); iterator.hasNext();) {
+                    PessimisticLock lock = (PessimisticLock) iterator.next();
+                    if (lock.isOwnedByUser(user)) {
+                        return true;
+                    }
+                }
+            }
+            return false;
+        } else {
+            return hasInitiateAuthorization(document, user);
+        }
+    }
+    
+    protected boolean usesPessimisticLocking(Document document) {
+        return KNSServiceLocator.getDataDictionaryService().getDataDictionary().getDocumentEntry(document.getClass().getName()).getUsePessimisticLocking();
+    }
+    
+    /**
+     * Determines whether the given user should have initiate permissions on the given document.
+     * @param document - current document
+     * @param user - current user
+     * @return boolean (true if they should have permissions)
+     */
+    public boolean hasInitiateAuthorization(Document document, Person user) {
+        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+        return workflowDocument.getInitiatorNetworkId().equalsIgnoreCase(user.getPrincipalName());
+    }
+
+    /**
+     * Determines whether the given user should be able to view the attachment on the given document
+     * and the attachment type
+     * @param attachmentTypeName - the attachment type
+     * @param document - current document
+     * @param user - current user
+     * @return boolean (true if they should have permissions)
+     */
+    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user) {
+        return true;
+    }
+
+    /**
+     * This method creates a new {@link PessimisticLock} when Workflow processing requires one
+     * 
+     * @param document - the document to create the lock against and add the lock to
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
+     */
+    public void establishWorkflowPessimisticLocking(Document document) {
+        PessimisticLock lock = createNewPessimisticLock(document, new HashMap(), getWorkflowPessimisticLockOwnerUser());
+        document.addPessimisticLock(lock);
+    }
+    
+    /**
+     * This method releases locks created via the {@link #establishWorkflowPessimisticLocking(Document)} method for the given document
+     * 
+     * @param document - document to release locks from
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#releaseWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
+     */
+    public void releaseWorkflowPessimisticLocking(Document document) {
+        KNSServiceLocator.getPessimisticLockService().releaseAllLocksForUser(document.getPessimisticLocks(), getWorkflowPessimisticLockOwnerUser());
+        document.refreshPessimisticLocks();
+    }
+
+    /**
+     * This method identifies the user that should be used to create and clear {@link PessimisticLock} objects required by
+     * Workflow.<br>
+     * <br>
+     * The default is the Kuali system user defined by {@link RiceConstants#SYSTEM_USER}. This method can be overriden by
+     * implementing documents if another user is needed.
+     * 
+     * @return a valid {@link Person} object
+     */
+    protected Person getWorkflowPessimisticLockOwnerUser() {
+        String networkId = KNSConstants.SYSTEM_USER;
+        return org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().getPersonByPrincipalName(networkId);
+    }
+    
+    /**
+     * This implementation will check the given document, editMode map, and user object to verify Pessimistic Locking. If the
+     * given edit mode map contains an 'entry type' edit mode then the system will check the locks already in existance on
+     * the document. If a valid lock for the given user is found the system will return the given edit mode map. If a valid
+     * lock is found but is owned by another user the edit mode map returned will have any 'entry type' edit modes removed. If the
+     * given document has no locks and the edit mode map passed in has at least one 'entry type' mode then a new
+     * {@link PessimisticLock} object will be created and set on the document for the given user.<br>
+     * <br> 
+     * NOTE: This method is only called if the document uses pessimistic locking as described in the data dictionary file.
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishLocks(org.kuali.rice.kns.document.Document,
+     *      java.util.Map, org.kuali.rice.kim.bo.Person)
+     */
+    public Map establishLocks(Document document, Map editMode, Person user) {
+        Map editModeMap = new HashMap();
+        // givenUserLockDescriptors is a list of lock descriptors currently held on the document by the given user
+        List<String> givenUserLockDescriptors = new ArrayList<String>();
+        // lockDescriptorUsers is a map with lock descriptors as keys and users other than the given user who hold a lock of each descriptor 
+        Map<String,Set<Person>> lockDescriptorUsers = new HashMap<String,Set<Person>>();
+
+        // build the givenUserLockDescriptors set and the lockDescriptorUsers map
+        for (PessimisticLock lock : document.getPessimisticLocks()) {
+            if (lock.isOwnedByUser(user)) {
+                // lock is owned by given user
+                givenUserLockDescriptors.add(lock.getLockDescriptor());
+            } else {
+                // lock is not owned by the given user
+                if (!lockDescriptorUsers.containsKey(lock.getLockDescriptor())) {
+                    lockDescriptorUsers.put(lock.getLockDescriptor(), new HashSet<Person>());
+                }
+                ((Set<Person>) lockDescriptorUsers.get(lock.getLockDescriptor())).add(lock.getOwnedByUser());
+            }
+        }
+
+        // verify that no locks held by current user exist for any other user
+        for (String givenUserLockDescriptor : givenUserLockDescriptors) {
+            if ( (lockDescriptorUsers.containsKey(givenUserLockDescriptor)) && (lockDescriptorUsers.get(givenUserLockDescriptor).size() > 0) ) {
+                Set<Person> users = lockDescriptorUsers.get(givenUserLockDescriptor);
+                if ( (users.size() != 1) || (!getWorkflowPessimisticLockOwnerUser().getPrincipalId().equals(users.iterator().next().getPrincipalId())) ) {
+                    String descriptorText = (useCustomLockDescriptors()) ? " using lock descriptor '" + givenUserLockDescriptor + "'" : "";
+                    String errorMsg = "Found an invalid lock status on document number " + document.getDocumentNumber() + "with current user and other user both having locks" + descriptorText + " concurrently";
+                    LOG.debug(errorMsg);
+                    throw new PessimisticLockingException(errorMsg);
+                }
+            }
+        }
+        
+        // check to see if the given user has any locks in the system at all
+        if (givenUserLockDescriptors.isEmpty()) {
+            // given user has no locks... check for other user locks
+            if (lockDescriptorUsers.isEmpty()) {
+                // no other user has any locks... set up locks for given user if user has edit privileges
+                if (isLockRequiredByUser(document, editMode, user)) {
+                    document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
+                }
+                editModeMap.putAll(editMode);
+            } else {
+                // at least one other user has at least one other lock... adjust edit mode for read only
+                if (useCustomLockDescriptors()) {
+                    // check to see if the custom lock descriptor is already in use
+                    String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
+                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
+                        // at least one other user has this descriptor locked... remove editable edit modes
+                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
+                    } else {
+                        // no other user has a lock with this descriptor
+                        if (isLockRequiredByUser(document, editMode, user)) {
+                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
+                        }
+                        editModeMap.putAll(editMode);
+                    }
+                } else {
+                    editModeMap = getEditModeWithEditableModesRemoved(editMode);
+                }
+            }
+        } else {
+            // given user already has at least one lock descriptor
+            if (useCustomLockDescriptors()) {
+                // get the custom lock descriptor and check to see if if the given user has a lock with that descriptor
+                String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
+                if (givenUserLockDescriptors.contains(customLockDescriptor)) {
+                    // user already has lock that is required
+                    editModeMap.putAll(editMode);
+                } else {
+                    // user does not have lock for descriptor required
+                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
+                        // another user has the lock descriptor that the given user requires... disallow lock and alter edit modes to have read only
+                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
+                    } else {
+                        // no other user has a lock with this descriptor... check if this user needs a lock
+                        if (isLockRequiredByUser(document, editMode, user)) {
+                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
+                        }
+                        editModeMap.putAll(editMode);
+                    }
+                }
+            } else {
+                // user already has lock and no descriptors are being used... use the existing edit modes
+                editModeMap.putAll(editMode);
+            }
+        }
+
+        return editModeMap;
+    }
+    
+    /**
+     * This method is used to check if the given parameters warrant a new lock to be created for the given user. This method
+     * utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method.
+     * 
+     * @param document -
+     *            document to verify lock creation against
+     * @param editMode -
+     *            edit modes list to check for 'entry type' edit modes
+     * @param user -
+     *            user the lock will be 'owned' by
+     * @return true if the given edit mode map has at least one 'entry type' edit mode... false otherwise
+     */
+    protected boolean isLockRequiredByUser(Document document, Map editMode, Person user) {
+        // check for entry edit mode
+        for (Iterator iterator = editMode.entrySet().iterator(); iterator.hasNext();) {
+            Map.Entry entry = (Map.Entry) iterator.next();
+            if (isEntryEditMode(entry)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+   /**
+     * This method is used to remove edit modes from the given map that allow the user to edit data on the document. This
+     * method utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method to identify if an edit mode is defined as an
+     * 'entry type' edit mode. It also uses the {@link #getEntryEditModeReplacementMode(java.util.Map.Entry)} method to replace
+     * any 'entry type' edit modes it finds.
+     * 
+     * @param currentEditMode -
+     *            current set of edit modes the user has assigned to them
+     * @return an adjusted edit mode map where 'entry type' edit modes have been removed or replaced using the
+     *         {@link #getEntryEditModeReplacementMode()} method
+     */
+    protected Map getEditModeWithEditableModesRemoved(Map currentEditMode) {
+        Map editModeMap = new HashMap();
+        for (Iterator iterator = currentEditMode.entrySet().iterator(); iterator.hasNext();) {
+            Map.Entry entry = (Map.Entry) iterator.next();
+            if (isEntryEditMode(entry)) {
+                editModeMap.putAll(getEntryEditModeReplacementMode(entry));
+            } else {
+                editModeMap.put(entry.getKey(), entry.getValue());
+            }
+        }
+        return editModeMap;
+    }
+    
+    /**
+     * This method is used to check if the given {@link Map.Entry} is an 'entry type' edit mode and that the value is set to
+     * signify that this user has that edit mode available to them
+     * 
+     * @param entry -
+     *            the {@link Map.Entry} object that contains an edit mode such as the ones returned but
+     *            {@link #getEditMode(Document, Person)}
+     * @return true if the given entry has a key signifying an 'entry type' edit mode and the value is equal to
+     *         {@link #EDIT_MODE_DEFAULT_TRUE_VALUE}... false if not
+     */
+    protected boolean isEntryEditMode(Map.Entry entry) {
+        // check for FULL_ENTRY edit mode set to default true value
+        if (AuthorizationConstants.EditMode.FULL_ENTRY.equals(entry.getKey())) {
+            String fullEntryEditModeValue = (String)entry.getValue();
+            return ( (ObjectUtils.isNotNull(fullEntryEditModeValue)) && (EDIT_MODE_DEFAULT_TRUE_VALUE.equals(fullEntryEditModeValue)) );
+        }
+        return false;
+    }
+    
+    /**
+     * This method is used to return values needed to replace the given 'entry type' edit mode {@link Map.Entry} with one that will not allow the user to enter data on the document 
+     * 
+     * @param entry - the current 'entry type' edit mode to replace 
+     * @return a Map of edit modes that will be used to replace this edit mode (represented by the given entry parameter)
+     */
+    protected Map getEntryEditModeReplacementMode(Map.Entry entry) {
+        Map editMode = new HashMap();
+        editMode.put(AuthorizationConstants.EditMode.VIEW_ONLY, EDIT_MODE_DEFAULT_TRUE_VALUE);
+        return editMode;
+    }
+    
+    /**
+     * This method creates a new {@link PessimisticLock} object using the given document and user. If the
+     * {@link #useCustomLockDescriptors()} method returns true then the new lock will also have a custom lock descriptor
+     * value set to the return value of {@link #getCustomLockDescriptor(Document, Map, Person)}.
+     * 
+     * @param document -
+     *            document to place the lock on
+     * @param editMode -
+     *            current edit modes for given user
+     * @param user -
+     *            user who will 'own' the new lock object
+     * @return the newly created lock object
+     */
+    protected PessimisticLock createNewPessimisticLock(Document document, Map editMode, Person user) {
+        if (useCustomLockDescriptors()) {
+            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), getCustomLockDescriptor(document, editMode, user), user);
+        } else {
+            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), user);
+        }
+    }
+    
+    /**
+     * This method should be overriden by groups requiring the lock descriptor field in the {@link PessimisticLock} objects.
+     * If it is not overriden and {@link #useCustomLockDescriptors()} returns true then this method will throw a
+     * {@link PessimisticLockingException}
+     * 
+     * @param document - document being checked for locking
+     * @param editMode - editMode generated for passed in user
+     * @param user - user attempting to establish locks
+     * @return a {@link PessimisticLockingException} will be thrown as the default implementation
+     */
+    protected String getCustomLockDescriptor(Document document, Map editMode, Person user) {
+        throw new PessimisticLockingException("Document " + document.getDocumentNumber() + " is using Pessimistic Locking with lock descriptors but the authorizer class has not defined the getCustomLockDescriptor() method");
+    }
+
+    /**
+     * This method should be used to define Document Authorizer classes which will use custom lock descriptors in the
+     * {@link PessimisticLock} objects NOTE: if this method is overriden to return true then the method
+     * {@link #getCustomLockDescriptor(Document, Map, Person)} must be overriden
+     * 
+     * @return false if the document will not be using lock descriptors or true if the document will use lock descriptors.
+     *         The default return value is false
+     */
+    protected boolean useCustomLockDescriptors() {
+        return false;
+    }
+    
+	/**
+	 * @return the identityManagementService
+	 */
+	public static IdentityManagementService getIdentityManagementService() {
+		
+		if (identityManagementService == null ) {
+			identityManagementService = KIMServiceLocator.getIdentityManagementService();
+		}
+		return identityManagementService;
+	}
+    
+    
+}
Index: impl/src/main/java/org/kuali/rice/kim/service/impl/InitiatorRoleTypeServiceImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/service/impl/InitiatorRoleTypeServiceImpl.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kim/service/impl/InitiatorRoleTypeServiceImpl.java	(revision 0)
@@ -0,0 +1,30 @@
+/*
+ * Copyright 2008 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.service.impl;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.service.support.impl.KimRoleTypeServiceBase;
+import org.kuali.rice.kim.util.KimConstants;
+
+public class InitiatorRoleTypeServiceImpl extends KimRoleTypeServiceBase {
+
+    @Override
+    public boolean performMatch(final AttributeSet qualification, final AttributeSet roleQualifier) {
+        return true;
+    }
+
+}
\ No newline at end of file
Index: impl/src/main/java/org/kuali/rice/kns/lookup/HtmlData.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/lookup/HtmlData.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/lookup/HtmlData.java	(working copy)
@@ -24,6 +24,7 @@
 
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.kns.bo.BusinessObject;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
 import org.kuali.rice.kns.datadictionary.mask.Mask;
 import org.kuali.rice.kns.service.KNSServiceLocator;
 import org.kuali.rice.kns.util.GlobalVariables;
@@ -197,20 +198,20 @@
 		StringBuffer titleText = new StringBuffer(prependText);
 		for (String key : keyValueList.keySet()) {
 			String fieldVal = keyValueList.get(key).toString();
-			// Mask value if it is a secure field
-			boolean viewAuthorized = KNSServiceLocator
-					.getAuthorizationService()
-					.isAuthorizedToViewAttribute(
-							GlobalVariables.getUserSession()
-									.getPerson(),
-							element.getName(), key);
-			if (!viewAuthorized) {
-				Mask displayMask = KNSServiceLocator
-						.getDataDictionaryService()
-						.getAttributeDisplayMask(
-								element.getName(), key);
-				fieldVal = displayMask.maskValue(fieldVal);
+			
+			AttributeSecurity attributeSecurity = KNSServiceLocator.getDataDictionaryService().getAttributeSecurity(element.getName(), key);
+			if(attributeSecurity != null && attributeSecurity.isPartialMask()){
+            	boolean viewAuthorized =  KNSServiceLocator.getAuthorizationService().isAuthorizedToPartiallyUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), element.getSimpleName(), key);
+                if(!viewAuthorized){
+                	fieldVal = attributeSecurity.getMaskFormatter().maskValue(fieldVal);
+                }
 			}
+			if(attributeSecurity != null && attributeSecurity.isMask()){
+            	boolean viewAuthorized =  KNSServiceLocator.getAuthorizationService().isAuthorizedToUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), element.getSimpleName(), key);
+            	if(!viewAuthorized){
+            		fieldVal = attributeSecurity.getMaskFormatter().maskValue(fieldVal);
+            	}
+            }
 			titleText.append(KNSServiceLocator.getDataDictionaryService()
 					.getAttributeLabel(element, key)
 					+ "=" + fieldVal.toString() + " ");
@@ -427,4 +428,4 @@
 
 	}
 
-}
+}
Index: impl/src/main/java/org/kuali/rice/kns/maintenance/KualiMaintainableImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/maintenance/KualiMaintainableImpl.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/maintenance/KualiMaintainableImpl.java	(working copy)
@@ -30,6 +30,7 @@
 import org.apache.commons.beanutils.PropertyUtils;
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.core.service.EncryptionService;
+import org.kuali.rice.kns.authorization.FieldAuthorization;
 import org.kuali.rice.kns.bo.BusinessObject;
 import org.kuali.rice.kns.bo.BusinessObjectRelationship;
 import org.kuali.rice.kns.bo.DocumentHeader;
@@ -38,11 +39,10 @@
 import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
 import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
-import org.kuali.rice.kns.document.Document;
 import org.kuali.rice.kns.document.MaintenanceDocument;
 import org.kuali.rice.kns.document.MaintenanceLock;
-import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
-import org.kuali.rice.kns.exception.KualiException;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
 import org.kuali.rice.kns.lookup.LookupUtils;
 import org.kuali.rice.kns.service.BusinessObjectDictionaryService;
 import org.kuali.rice.kns.service.BusinessObjectMetaDataService;
@@ -51,7 +51,6 @@
 import org.kuali.rice.kns.service.KNSServiceLocator;
 import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
 import org.kuali.rice.kns.service.PersistenceStructureService;
-import org.kuali.rice.kim.service.PersonService;
 import org.kuali.rice.kns.util.FieldUtils;
 import org.kuali.rice.kns.util.GlobalVariables;
 import org.kuali.rice.kns.util.InactiveRecordsHidingUtils;
@@ -190,6 +189,7 @@
         return cachedValues;
     }
 
+
     /**
      * Special hidden parameters are set on the maintenance jsp starting with a prefix that tells us which fields have been
      * encrypted. This field finds the those parameters in the map, whose value gives us the property name that has an encrypted
@@ -198,7 +198,7 @@
      * @param fieldValues - possibly with encrypted values
      * @return Map fieldValues - with no encrypted values
      */
-    private Map decryptEncryptedData(Map fieldValues, Document maintenanceDocument) {
+    private Map decryptEncryptedData(Map fieldValues, MaintenanceDocument maintenanceDocument) {
     	try {
 	        for (Iterator iter = fieldValues.keySet().iterator(); iter.hasNext();) {
 	                String fieldName = (String) iter.next();
@@ -228,24 +228,30 @@
         return fieldValues;
     }
 
-    private boolean shouldFieldBeEncrypted(Document maintenanceDocument, String fieldName){
-    	DocumentAuthorizer authorizer = KNSServiceLocator.getDocumentAuthorizationService().getDocumentAuthorizer(maintenanceDocument);
-    	Map editMap = authorizer.getEditMode(maintenanceDocument, GlobalVariables.getUserSession().getPerson());
-    	String displayEditMode = getDisplayEditMode(maintenanceDocument, fieldName);
-    	// Non-blank displayEditMode implies that this field should be encrypted, if the user does not have appropriate permissions
+    private boolean shouldFieldBeEncrypted(MaintenanceDocument maintenanceDocument, String fieldName){
+    	MaintenanceDocumentAuthorizer authorizer = (MaintenanceDocumentAuthorizer)
+    		KNSServiceLocator.getDocumentAuthorizationService().getDocumentAuthorizer(maintenanceDocument);
+    	MaintenanceDocumentAuthorizations auths = 
+    		authorizer.getFieldAuthorizations(maintenanceDocument, GlobalVariables.getUserSession().getPerson());
+    	// If the user does not have appropriate permissions, a non-blank displayEditMode implies that this field should be encrypted
     	// If the logged in user has the permission to view or edit this field, 
-    	// editMap will have an entry corresponding to displayEditMode, in which case, the field value received will not be encrypted 
-    	if(StringUtils.isNotBlank(displayEditMode) && (editMap==null || !editMap.containsKey(displayEditMode)))
-    		return true;
+    	// editMap will have an entry corresponding to displayEditMode, in which case, the field value received will not be encrypted
+    	// The corresponding value in editMap actually does not matter;
+    	// just the presence of the displayEditMode inside that map is enough.
+    	// Note: this "if" stmt is same as "${field.secure && empty KualiForm.editingMode[field.displayEditMode]}" of rowDisplay.jsp
+    	if(auths!=null && auths.hasAuthFieldRestricted(fieldName)){
+    		FieldAuthorization fieldAuth = auths.getAuthFieldAuthorization(fieldName);
+    		return fieldAuth.shouldBeEncrypted();
+    	}
     	return false;
     }
     
-    private String getDisplayEditMode(Document maintenanceDocument, String fieldName){
+    /*private String getDisplayEditMode(Document maintenanceDocument, String fieldName){
     	String docTypeName = maintenanceDocument.getDocumentHeader().getWorkflowDocument().getDocumentType();
     	MaintainableFieldDefinition fieldDefinition =
     		KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableField(docTypeName, fieldName);
     	return fieldDefinition==null?null:fieldDefinition.getDisplayEditMode();
-	}
+	}*/
     
     /**
      * Calls method to get all the core sections for the business object defined in the data dictionary. Then determines if the bo
@@ -1091,4 +1097,4 @@
     }
 
 	
-}
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(working copy)
@@ -1,174 +1,343 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-
-public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
-
-    /**
-     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
-        // by default, there are no restrictions, only if this method is
-        // overridden by a subclass that adds restrictions
-        return new MaintenanceDocumentAuthorizations();
-    }
-
-    /**
-     * 
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-
-        // run the super, let the common flags be set
-        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
-
-        // run the fieldAuthorizations
-        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
-        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
-
-        // if there are any field restrictions for this user, then we need to turn off the
-        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
-        // they certainly cant blanket approve it.
-        if (docAuths.hasAnyFieldRestrictions()) {
-            docActionFlags.setCanBlanketApprove(false);
-        }
-
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-
-        // if a user can't initiate a document of this type then they can't copy one, either
-        if (!canCopy(workflowDocument.getDocumentType(), user)) {
-            docActionFlags.setCanCopy(false);
-        }
-        else {
-            docActionFlags.setCanCopy(document.getAllowsCopy() && (!workflowDocument.stateIsInitiated() && !workflowDocument.stateIsEnroute() && !workflowDocument.stateIsException() && !workflowDocument.stateIsSaved()));
-        }
-
-        return docActionFlags;
-    }
-
-    /**
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public Map getEditMode(Document document, Person user) {
-
-        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
-        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
-            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
-        }
-
-        Map editMode = new HashMap();
-        
-        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
-        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
-
-        // default to view-only, as a safety precaution
-        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-
-        // if the document is cancelled, then its view only
-        if (workflowDocument.stateIsCanceled()) {
-            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-        }
-
-        // if the document is being edited, then its full entry, or if the current user is
-        // the system supervisor
-        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-            if (workflowDocument.userIsInitiator(user)) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
-                
-                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
-                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
-                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
-                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
-                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
-                }
-            }
-        }
-
-        // if the document is in routing, then we have some special rules
-        else if (workflowDocument.stateIsEnroute()) {
-
-            // the person who has the approval request in their Actiong List
-            // should be able to modify the document
-            if (workflowDocument.isApprovalRequested()) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
-            }
-        }
-
-        // save the editmode
-        editMode.put(editModeKey, "TRUE");
-        return editMode;
-    }
-
-    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
-        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
-        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
-        
-        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
-            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
-                if (itemDefinition instanceof MaintainableFieldDefinition) {
-                    String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
-                    if (StringUtils.isNotBlank(displayEditMode)) {
-                        editModes.put(displayEditMode, "TRUE");
-                    }
-                }
-                // TODO: what about MaintainableCollectionDefinition?
-            }
-        }
-    }
-    
-    /**
-     * This method returns whether this document is creating a new entry in the maintenible/underlying table
-     * 
-     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
-     * useful in determining which fields are encrypted
-     * 
-     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
-     * there is uncertainity how documents with this action will actually be implemented
-     * 
-     * @param maintDoc
-     * @param user
-     * @return
-     */
-    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
-        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
-        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
-        
-        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
-        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
-        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
-    }
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.bo.FieldAttributeSecurity;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.service.IdentityManagementService;
+import org.kuali.rice.kim.service.KIMServiceLocator;
+import org.kuali.rice.kim.util.DocumentAttributeSecurityUtils;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
+import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
+
+	private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
+
+    /**
+     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
+        // by default, there are no restrictions, only if this method is
+        // overridden by a subclass that adds restrictions
+    	//return new MaintenanceDocumentAuthorizations();
+    	
+    	MaintenanceDocumentAuthorizations auths = new MaintenanceDocumentAuthorizations();
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+    	String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+    	String documentNumber = document.getDocumentNumber();
+    	String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+    	
+    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
+    	Map<String, FieldAttributeSecurity> restrictionFields = DocumentAttributeSecurityUtils.getRestrictionMaintainableFields(objectEntry);
+    	
+    	Set keys = restrictionFields.keySet();    
+    	Iterator keyIter = keys.iterator();
+        while (keyIter.hasNext()) { 
+           String fullFieldName = (String) keyIter.next(); 
+           FieldAttributeSecurity fieldAttributeSecurity = (FieldAttributeSecurity) restrictionFields.get(fullFieldName);
+           String fieldName = fieldAttributeSecurity.getAttributeName();
+           
+           //TODO:Should use ParameterService.getDetailType to get the componentName
+           String componentName = fieldAttributeSecurity.getBusinessObjectClass().getSimpleName();
+           //TODO: Should use ParameterService getNameSpace to get name space
+           //Should be nameSpaceCode in krim_perm_templ_t table
+           String nameSpaceCode = "KR-NS";
+           
+           AttributeSecurity maintainableFieldAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getMaintainableFieldAttributeSecurity();
+           AttributeSecurity  businessObjectAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getBusinessObjectAttributeSecurity();
+           
+           AttributeSet permissionDetails = new AttributeSet();
+       	   //permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+       	   //permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentType);
+       	   //permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	   //permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+    	   permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, fieldName);
+    	   //permissionDetails.put(KimConstants.KIM_ATTRIB_NAMESPACE_CODE, nameSpaceCode);
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null && maintainableFieldAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+    			   MaskFormatter partialMaskFormatter = businessObjectAttributeSecurity.getPartialMaskFormatter();
+    			   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
+				   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+			   }
+		   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+    		       MaskFormatter maskFormatter = businessObjectAttributeSecurity.getMaskFormatter();
+    			   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isMask()){  
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
+				   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+			   }
+		   }
+    	
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+    			   auths.addHiddenAuthField(fullFieldName);	  
+    		   }
+    	   }   
+
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+				   auths.addHiddenAuthField(fullFieldName);	  
+			   }
+		   }
+  
+        }    	
+    	return auths; 
+    }
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+
+        // run the super, let the common flags be set
+        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
+
+        // run the fieldAuthorizations
+        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
+        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
+
+        // if there are any field restrictions for this user, then we need to turn off the
+        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
+        // they certainly cant blanket approve it.
+        if (docAuths.hasAnyFieldRestrictions()) {
+            docActionFlags.setCanBlanketApprove(false);
+        }
+
+        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+
+        // if a user can't initiate a document of this type then they can't copy one, either
+        if (!canCopy(workflowDocument.getDocumentType(), user)) {
+            docActionFlags.setCanCopy(false);
+        }
+        else {
+            docActionFlags.setCanCopy(document.getAllowsCopy() && (!workflowDocument.stateIsInitiated() && !workflowDocument.stateIsEnroute() && !workflowDocument.stateIsException() && !workflowDocument.stateIsSaved()));
+        }
+
+        return docActionFlags;
+    }
+    
+ 
+    /**
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public Map getEditMode(Document document, Person user) {
+
+        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
+        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
+            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
+        }
+
+        Map editMode = new HashMap();
+        
+        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
+        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
+
+        // default to view-only, as a safety precaution
+        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+
+        // if the document is cancelled, then its view only
+        if (workflowDocument.stateIsCanceled()) {
+            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+        }
+
+        // if the document is being edited, then its full entry, or if the current user is
+        // the system supervisor
+        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+            if (workflowDocument.userIsInitiator(user)) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
+                
+                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
+                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
+                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
+                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
+                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
+                }
+            }
+        }
+
+        // if the document is in routing, then we have some special rules
+        else if (workflowDocument.stateIsEnroute()) {
+
+            // the person who has the approval request in their Actiong List
+            // should be able to modify the document
+            if (workflowDocument.isApprovalRequested()) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
+            }
+        }
+
+        // save the editmode
+        editMode.put(editModeKey, "TRUE");
+        return editMode;
+    }
+
+    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
+        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
+        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
+        
+        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
+            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
+                if (itemDefinition instanceof MaintainableFieldDefinition) {
+                    /*String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
+                    if (StringUtils.isNotBlank(displayEditMode)) {
+                        editModes.put(displayEditMode, "TRUE");
+                    }*/
+                }
+                // TODO: what about MaintainableCollectionDefinition?
+            }
+        }
+    }
+    
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public void canInitiate(String documentTypeName, Person user) {
+    	//TODO:
+    	String nameSpaceCode = "KR_SYS";
+    	String action = (String) GlobalVariables.getUserSession().retrieveObject(DocumentAuthorizerBase.USER_SESSION_METHOD_TO_CALL_OBJECT_KEY);
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION, action);
+        //if (!getAuthorizationService().isAuthorized(user, KimConstants.PERMISSION_INITIATE_DOCUMENT, documentTypeName)) {
+        if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null)){
+        	
+        	//TODO:
+        	// build authorized workgroup list for error message
+          //  Set authorizedWorkgroups = getAuthorizationService().getAuthorizedWorkgroups("initiate", documentTypeName);
+          //  String workgroupList = StringUtils.join(authorizedWorkgroups.toArray(), ",");
+          String userName = (String) GlobalVariables.getUserSession().getPrincipalName();
+          throw new DocumentInitiationAuthorizationException(new String[] {userName,documentTypeName});
+        }
+    }
+
+    /**
+     * Default implementation here is if a user cannot initiate a document they cannot copy one.
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canCopy(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public boolean canCopy(String documentTypeName, Person user) {
+        //return getAuthorizationService().isAuthorized(user, KimConstants.PERMISSION_INITIATE_DOCUMENT, documentTypeName);
+    	//TODO:
+    	String nameSpaceCode = "KR_SYS";
+    	String action = (String) GlobalVariables.getUserSession().retrieveObject(DocumentAuthorizerBase.USER_SESSION_METHOD_TO_CALL_OBJECT_KEY);
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION, action);
+        return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null);
+        	
+        
+    }
+    
+    /**
+     * This method returns whether this document is creating a new entry in the maintenible/underlying table
+     * 
+     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
+     * useful in determining which fields are encrypted
+     * 
+     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
+     * there is uncertainity how documents with this action will actually be implemented
+     * 
+     * @param maintDoc
+     * @param user
+     * @return
+     */
+    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
+        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
+        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
+        
+        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
+        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
+        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
+    }
+    
+
+	
+	/**
+	 * @return the maintenanceDocumentDictionaryService
+	 */
+	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+		
+		if (maintenanceDocumentDictionaryService == null ) {
+			maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+		}
+		return maintenanceDocumentDictionaryService;
+	}
+
+    
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/web/ui/FieldBridge.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/ui/FieldBridge.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/web/ui/FieldBridge.java	(working copy)
@@ -24,6 +24,7 @@
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.kns.bo.BusinessObject;
 import org.kuali.rice.kns.bo.Summarizable;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
 import org.kuali.rice.kns.datadictionary.CollectionDefinitionI;
 import org.kuali.rice.kns.datadictionary.FieldDefinition;
 import org.kuali.rice.kns.datadictionary.FieldDefinitionI;
@@ -64,7 +65,7 @@
 
             MaintainableFieldDefinition maintainableFieldDefinition = ((MaintainableFieldDefinition) definition);
             field.setFieldRequired(maintainableFieldDefinition.isRequired());
-            field.setReadOnly(maintainableFieldDefinition.isReadOnly());
+            field.setReadOnly(maintainableFieldDefinition.isUnconditionallyReadOnly());
             if (maintainableFieldDefinition.isLookupReadOnly()) {
             	field.setFieldType(Field.LOOKUP_READONLY);
             }
@@ -83,15 +84,7 @@
         /* setup security of field (sensitive data) if needed, note this will always be true on old maintainables since
          * maintenanceAction is not set
          */
-        String displayEditMode = definition.getDisplayEditMode();
-        if (StringUtils.isNotBlank(displayEditMode)) {
-
-            field.setSecure(true);
-            field.setDisplayEditMode(displayEditMode);
-            field.setDisplayMask(definition.getDisplayMask());
-
-        }
-
+        //field.setAttributeSecurity(definition.getAttributeSecurity());
     }
 
     /**
@@ -157,17 +150,28 @@
             }
 
             // check if field contains sensitive data and user is authorized to see value
-            boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(GlobalVariables.getUserSession().getPerson(), bo.getClass().getName(), propertyName);
-            if (!viewAuthorized) {
+            //boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(GlobalVariables.getUserSession().getPerson(), bo.getClass().getName(), propertyName);
+            //if (!viewAuthorized) {
                 // set mask as field value
-                Mask propertyMask = KNSServiceLocator.getDataDictionaryService().getAttributeDisplayMask(bo.getClass(), propertyName);
-                if (propertyMask == null) {
-                    throw new RuntimeException("No mask specified for secure field.");
-                }
+                //Mask propertyMask = KNSServiceLocator.getDataDictionaryService().getAttributeDisplayMask(bo.getClass(), propertyName);
+                //if (propertyMask == null) {
+                //    throw new RuntimeException("No mask specified for secure field.");
+                //}
 
-                field.setPropertyValue(propertyMask.maskValue(propValue));
-                field.setDisplayMaskValue(propertyMask.maskValue(propValue));
-
+                //field.setPropertyValue(propertyMask.maskValue(propValue));
+                //field.setDisplayMaskValue(propertyMask.maskValue(propValue));
+            AttributeSecurity attributeSecurity = KNSServiceLocator.getDataDictionaryService().getAttributeSecurity(bo.getClass().getName(), propertyName);
+            if(attributeSecurity != null && attributeSecurity.isMask() 
+               && KNSServiceLocator.getAuthorizationService().isAuthorizedToUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), bo.getClass().getSimpleName(), propertyName) 
+               ){
+            	field.setPropertyValue(attributeSecurity.getMaskFormatter().maskValue(propValue));
+                field.setDisplayMaskValue(attributeSecurity.getMaskFormatter().maskValue(propValue));
+            		
+            }else if(attributeSecurity != null && attributeSecurity.isPartialMask()
+            		&& KNSServiceLocator.getAuthorizationService().isAuthorizedToPartiallyUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), bo.getClass().getSimpleName(), propertyName) ){
+            		field.setPropertyValue(attributeSecurity.getPartialMaskFormatter().maskValue(propValue));
+                    field.setDisplayMaskValue(attributeSecurity.getPartialMaskFormatter().maskValue(propValue));
+                
             } else {
                 field.setPropertyValue(propValue);
                 FieldUtils.setInquiryURL(field, bo, propertyName);
@@ -324,7 +328,7 @@
             // if this flag is set, and the current field is required, and readonly, and blank, use the
             // defaultValueFinder if one exists
             if (autoFillBlankRequiredValues) {
-                if ( maintainableFieldDefinition.isRequired() && maintainableFieldDefinition.isReadOnly() ) {
+                if ( maintainableFieldDefinition.isRequired() && maintainableFieldDefinition.isUnconditionallyReadOnly() ) {
                     if ( StringUtils.isBlank( field.getPropertyValue() ) ) {
                         Class defaultValueFinderClass = maintainableFieldDefinition.getDefaultValueFinderClass();
                         if (defaultValueFinderClass != null) {
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/MaintainableFieldDefinition.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/MaintainableFieldDefinition.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/MaintainableFieldDefinition.java	(working copy)
@@ -58,6 +58,7 @@
 
     protected boolean required = false;
     protected boolean readOnly = false;
+    protected boolean unconditionallyReadOnly = false;
     protected boolean readOnlyAfterAdd = false;
     private boolean noLookup = false;
     private boolean lookupReadOnly = false;
@@ -119,11 +120,18 @@
     }
 
     /**
-     * @return Returns the readOnly.
+     * @return Returns the unconditionallyReadOnly.
      */
-    public boolean isReadOnly() {
-        return readOnly;
+    public boolean isUnconditionallyReadOnly() {
+        return unconditionallyReadOnly;
     }
+    
+    /**
+     * unconditionallyReadOnly is true if it cannot be updated
+     */
+    public void setUnconditionallyReadOnly(boolean unconditionallyReadOnly) {
+        this.unconditionallyReadOnly = unconditionallyReadOnly;
+    }
 
     /**
      * readOnly is true if it cannot be updated
Index: impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java	(revision 5311)
+++ impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java	(working copy)
@@ -1,56 +1,68 @@
-/*
- * Copyright 2007 The Kuali Foundation
- *
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.opensource.org/licenses/ecl1.php
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kim.util;
-
-/**
- * This is a description of what this class does - jonathan don't forget to fill this in. 
- * 
- * @author Kuali Rice Team (kuali-rice@googlegroups.com)
- *
- */
-public class KimConstants {
-
-	public static final String TAX_EXT_ID_TYPE = "TAX";
-
-	public static final String STAFF_AFFILIATION_TYPE = "STAFF";
-	public static final String STUDENT_AFFILIATION_TYPE = "STUDENT";
-	public static final String AFFILIATE_AFFILIATION_TYPE = "AFFILIATE";
-	public static final String FACULTY_AFFILIATION_TYPE = "FACULTY";
-	public static final String DOC_STATUS = "Route Status Code";
-    public static final String KEY_EDIT_MODE = "keyEditMode";
-	public static final String PERMISSION_UNMARK = "Unmark";
-	public static final String PERMISSION_UNMASK_PROPERTY = "Completely Unmask Property";
-	public static final String PERMISSION_PARTIALLY_UNMASK_PROPERTY = "Partially Unmask Property";
-	public static final String PERMISSION_VIEW_PROPERTY = "View Property";
-	public static final String PERMISSION_EDIT_PROPERTY = "Edit Property";
-	public static final String DOCUMENT_STATUS_PERMISSION_TYPE = "DocumentStatusComponentAttributePermissionType";
-	public static final String KIM_ATTRIB_EDIT_MODE = "Edit Mode";
-	public static final String USER_IS_INITIATOR = "userIsInitiator";
-	public static final String KIM_ATTRIB_CHART_CODE ="Chart Code";
-	public static final String KIM_ATTRIB_ORGANIZATION_CODE = "Organization Code";
-	public static final String KIM_ATTRIB_CAMPUS_CODE = "Campus Code";
-	public static final String KIM_ATTRIB_NAMESPACE_CODE = "Namespace Code";
-	public static final String KIM_ATTRIB_DOCUMENT_TYPE_NAME = "Document Type Name";
-	public static final String KIM_ATTRIB_ROUTE_STATUS_CODE = "Route Status Code";
-	public static final String KIM_ATTRIB_ROUTE_NODE_NAME = "Route Node Name";
-	public static final String KIM_ATTRIB_DOCUMENT_NUMBER = "Document Number";
-	public static final String KIM_ATTRIB_PROPERTY_NAME = "Property Name";
-	public static final String KIM_ATTRIB_COMPONENT_NAME = "Component";
-		
-	@Deprecated
-	public static final String TEMP_GROUP_NAMESPACE = "KFS";
-	
-}
+/*
+ * Copyright 2007 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.util;
+
+/**
+ * This is a description of what this class does - jonathan don't forget to fill this in. 
+ * 
+ * @author Kuali Rice Team (kuali-rice@googlegroups.com)
+ *
+ */
+public class KimConstants {
+
+	public static final String TAX_EXT_ID_TYPE = "TAX";
+
+	public static final String STAFF_AFFILIATION_TYPE = "STAFF";
+	public static final String STUDENT_AFFILIATION_TYPE = "STUDENT";
+	public static final String AFFILIATE_AFFILIATION_TYPE = "AFFILIATE";
+	public static final String FACULTY_AFFILIATION_TYPE = "FACULTY";
+	public static final String DOC_STATUS = "Route Status Code";
+    public static final String KEY_EDIT_MODE = "keyEditMode";
+	public static final String PERMISSION_UNMARK = "Unmark";
+	public static final String PERMISSION_UNMASK_PROPERTY = "Full Unmask Field";
+	public static final String PERMISSION_PARTIALLY_UNMASK_PROPERTY = "Partial Unmask Field";
+	public static final String PERMISSION_VIEW_PROPERTY = "View Inquiry or Maintenance Document Field(s)";
+	public static final String PERMISSION_EDIT_PROPERTY = "Modify Maintenance Document Field(s)";
+	public static final String PERMISSION_EDIT_DOCUMENT = "Edit Document";
+	public static final String PERMISSION_INITIATE_DOCUMENT = "Initiate Document";
+	public static final String PERMISSION_BLANKET_APPROVE_DOCUMENT ="Blanket Approve Document";
+	public static final String PERMISSION_CANCEL_DOCUMENT ="Cancel Document";
+	public static final String PERMISSION_SAVE_DOCUMENT ="Save Document";
+	public static final String PERMISSION_ROUTE_DOCUMENT ="Route Document";
+	public static final String PERMISSION_PERFORM_ROUTE_REPORT = "Perform Route Report";
+	public static final String PERMISSION_APPROVE_DOCUMENT = "Approve Document";
+	public static final String DOCUMENT_STATUS_PERMISSION_TYPE = "DocumentStatusComponentAttributePermissionType";
+	public static final String KIM_ATTRIB_EDIT_MODE = "Edit Mode";
+	public static final String USER_IS_INITIATOR = "userIsInitiator";
+	public static final String KIM_ATTRIB_CHART_CODE ="Chart Code";
+	public static final String KIM_ATTRIB_ORGANIZATION_CODE = "Organization Code";
+	public static final String KIM_ATTRIB_CAMPUS_CODE = "Campus Code";
+	public static final String KIM_ATTRIB_NAMESPACE_CODE = "Namespace Code";
+	public static final String KIM_ATTRIB_DOCUMENT_TYPE_NAME = "name";
+	public static final String KIM_ATTRIB_ROUTE_STATUS_CODE = "docRouteStatus";
+	public static final String KIM_ATTRIB_ROUTE_NODE_NAME = "docRouteName";
+	public static final String KIM_ATTRIB_DOCUMENT_NUMBER = "Document Number";
+	public static final String KIM_ATTRIB_PROPERTY_NAME = "propertyName";
+	public static final String KIM_ATTRIB_COMPONENT_NAME = "parameterDetailTypeCode";
+	public static final String KIM_ATTRIB_ACTION = "action";
+
+	public static final String KIM_AD_HOC  ="AdHoc";
+	
+	
+	@Deprecated
+	public static final String TEMP_GROUP_NAMESPACE = "KFS";
+	
+}
Index: impl/src/main/java/org/kuali/rice/kns/service/impl/DataDictionaryServiceImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/service/impl/DataDictionaryServiceImpl.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/service/impl/DataDictionaryServiceImpl.java	(working copy)
@@ -29,6 +29,7 @@
 import org.apache.commons.lang.StringUtils;
 import org.kuali.rice.kns.bo.BusinessObject;
 import org.kuali.rice.kns.datadictionary.AttributeDefinition;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
 import org.kuali.rice.kns.datadictionary.BusinessObjectEntry;
 import org.kuali.rice.kns.datadictionary.CollectionDefinition;
 import org.kuali.rice.kns.datadictionary.DataDictionary;
@@ -61,6 +62,7 @@
     private KualiConfigurationService kualiConfigurationService;
     private KualiModuleService kualiModuleService;
 
+    
     /**
      * @see org.kuali.rice.kns.service.DataDictionaryService#setBaselinePackages(java.lang.String)
      */
@@ -256,7 +258,22 @@
 
         return displayMask;
     }
+    
+    /**
+     * @see org.kuali.rice.kns.service.DataDictionaryService#getAttributeDisplayMask(java.lang.String, java.lang.String)
+     */
+    public AttributeSecurity getAttributeSecurity(String entryName, String attributeName) {
+        AttributeSecurity attributeSecurity = null;
 
+        AttributeDefinition attributeDefinition = getAttributeDefinition(entryName, attributeName);
+        if (attributeDefinition != null) {
+            attributeSecurity = attributeDefinition.getAttributeSecurity();
+        }
+
+        return attributeSecurity;
+    }
+
+
     /**
      * @see org.kuali.rice.kns.service.DataDictionaryService#getAttributeDisplayWorkgroup(java.lang.String, java.lang.String)
      */
@@ -866,10 +883,15 @@
     	BusinessObjectEntry boEntry = getDataDictionary().getBusinessObjectEntry(entryClassName);
     	List<String> encryptedFieldsList = new ArrayList<String>();
     	Mask displayMask;
+    	AttributeSecurity attributeSecurity;
     	for(AttributeDefinition attributeDefinition: boEntry.getAttributes()){
     		displayMask = attributeDefinition.getDisplayMask();
+    		attributeSecurity = attributeDefinition.getAttributeSecurity();
         	if(displayMask != null)
         		encryptedFieldsList.add(attributeDefinition.getName());
+        	if(attributeSecurity != null && (attributeSecurity.isMask() || attributeSecurity.isPartialMask())){
+        		encryptedFieldsList.add(attributeDefinition.getName());
+        	}
     	}
     	return encryptedFieldsList;
     }
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java	(revision 5087)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java	(working copy)
@@ -15,11 +15,17 @@
  */
 package org.kuali.rice.kns.document.authorization;
 
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.KimConstants;
 import org.kuali.rice.kns.document.Document;
 import org.kuali.rice.kns.document.TransactionalDocument;
+import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
 import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
 
 /**
@@ -49,4 +55,42 @@
         }
         return flags;
     }
+    
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public void canInitiate(String documentTypeName, Person user) {
+    	//TODO:
+    	String nameSpaceCode = "KR_SYS";
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	
+        //if (!getAuthorizationService().isAuthorized(user, KimConstants.PERMISSION_INITIATE_DOCUMENT, documentTypeName)) {
+        if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null)){
+        	
+        	//TODO:
+        	// build authorized workgroup list for error message
+            Set authorizedWorkgroups = getAuthorizationService().getAuthorizedWorkgroups("initiate", documentTypeName);
+            String workgroupList = StringUtils.join(authorizedWorkgroups.toArray(), ",");
+            throw new DocumentInitiationAuthorizationException(new String[] {workgroupList,documentTypeName});
+        }
+    }
+
+    /**
+     * Default implementation here is if a user cannot initiate a document they cannot copy one.
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canCopy(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public boolean canCopy(String documentTypeName, Person user) {
+        //return getAuthorizationService().isAuthorized(user, KimConstants.PERMISSION_INITIATE_DOCUMENT, documentTypeName);
+    	//TODO:
+    	String nameSpaceCode = "KR_SYS";
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	
+        return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null);
+        	
+        
+    }
+
 }
Index: impl/src/main/java/org/kuali/rice/kns/service/AuthorizationService.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/service/AuthorizationService.java	(revision 5087)
+++ impl/src/main/java/org/kuali/rice/kns/service/AuthorizationService.java	(working copy)
@@ -49,6 +49,28 @@
      */
     public boolean isAuthorizedToViewAttribute(Person user, String entryName, String attributeName);
     
+    /**
+     * 
+     * This method is used to check if user has permission to unmask masked attribute
+     * 
+     * @param user
+     * @param entryName
+     * @param attributeName
+     * @return
+     */
+    public boolean isAuthorizedToUnmaskAttribute(Person user, String entryName, String attributeName);
+    
+    /**
+     * 
+     * This method is used to check if user has permission to unmask partially masked attribute
+     * 
+     * @param user
+     * @param entryName
+     * @param attributeName
+     * @return
+     */
+    public boolean isAuthorizedToPartiallyUnmaskAttribute(Person user, String entryName, String attributeName);
+    
 //    public void completeInitialization( DataDictionary dataDictionary );
     
     public void setupAuthorizations(DocumentEntry documentEntry) ;
Index: impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java	(working copy)
@@ -1,528 +1,535 @@
-/*
- * Copyright 2005-2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.web.struts.form;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.struts.upload.FormFile;
-import org.kuali.rice.core.config.ConfigurationException;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.bo.BusinessObject;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.document.MaintenanceDocumentBase;
-import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
-import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
-import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
-import org.kuali.rice.kns.exception.UnknownDocumentTypeException;
-import org.kuali.rice.kns.maintenance.Maintainable;
-import org.kuali.rice.kns.service.DocumentAuthorizationService;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
-import org.kuali.rice.kns.util.FieldUtils;
-import org.kuali.rice.kns.util.GlobalVariables;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.util.ObjectUtils;
-import org.kuali.rice.kns.util.RiceKeyConstants;
-import org.kuali.rice.kns.web.format.FormatException;
-import org.kuali.rice.kns.web.format.Formatter;
-
-
-/**
- * This class is the base action form for all maintenance documents.
- * 
- * 
- */
-public class KualiMaintenanceForm extends KualiDocumentFormBase {
-    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KualiMaintenanceForm.class);
-
-    private static final long serialVersionUID = 1L;
-
-    private String businessObjectClassName;
-    private String description;
-    private boolean readOnly;
-    private Map oldMaintainableValues;
-    private Map newMaintainableValues;
-    private String maintenanceAction;
-    
-    /**
-     * Used to indicate which result set we're using when refreshing/returning from a multi-value lookup
-     */
-    private String lookupResultsSequenceNumber;
-    /**
-     * The type of result returned by the multi-value lookup
-     * 
-     * TODO: to be persisted in the lookup results service instead?
-     */
-    private String lookupResultsBOClassName;
-    
-    /**
-     * The name of the collection looked up (by a multiple value lookup)
-     */
-    private String lookedUpCollectionName;
-    
-    private MaintenanceDocumentAuthorizations authorizations;
-    
-    /**
-     * Override the default method to add the if statement which can't be called until after parameters from a multipart request
-     * have been made accessible, but which must be called before the parameter values are used to instantiate and populate business
-     * objects.
-     * 
-     * @param requestParameters
-     */
-    @Override
-    public void postprocessRequestParameters(Map requestParameters) {
-        super.postprocessRequestParameters(requestParameters);
-
-        String docTypeName = null;
-        String[] docTypeNames = (String[]) requestParameters.get(KNSConstants.DOCUMENT_TYPE_NAME);
-        if ((docTypeNames != null) && (docTypeNames.length > 0)) {
-            docTypeName = docTypeNames[0];
-        }
-
-        if (StringUtils.isNotBlank(docTypeName)) {          
-        	if(this.getDocument() == null){
-            setDocTypeName(docTypeName);
-            Class documentClass = KNSServiceLocator.getDataDictionaryService().getDocumentClassByTypeName(docTypeName);
-            if (documentClass == null) {
-                throw new UnknownDocumentTypeException("unable to get class for unknown documentTypeName '" + docTypeName + "'");
-            }
-            if (!MaintenanceDocumentBase.class.isAssignableFrom(documentClass)) {
-                throw new ConfigurationException("Document class '" + documentClass + "' is not assignable to '" + MaintenanceDocumentBase.class + "'");
-            }
-            Document document = null;
-            try {
-                Class[] defaultConstructor = new Class[]{String.class};
-                Constructor cons = documentClass.getConstructor(defaultConstructor);
-                if (ObjectUtils.isNull(cons)) {
-                    throw new ConfigurationException("Could not find constructor with document type name parameter needed for Maintenance Document Base class");
-                }
-                document = (Document) cons.newInstance(docTypeName);
-            } catch (SecurityException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (NoSuchMethodException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document: No constructor with String parameter found", e);
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (InstantiationException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (IllegalArgumentException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            }
-            if (document == null) {
-                throw new RuntimeException("Unable to instantiate document with type name '" + docTypeName + "' and document class '" + documentClass + "'");
-            }
-            setDocument(document);
-          } 
-       }
-        
-        MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
-        
-        //Handling the Multi-Part Attachment
-        for ( Object obj : requestParameters.entrySet() ) {
-            String parameter = (String)((Map.Entry)obj).getKey(); 
-            if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-                String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-                Object propertyValue = requestParameters.get(parameter);
-                
-                if(propertyValue != null && propertyValue instanceof FormFile) {
-                    if(StringUtils.isNotEmpty(((FormFile)propertyValue).getFileName())) {
-                        maintenanceDocument.setFileAttachment((FormFile) propertyValue);
-                    }
-                    maintenanceDocument.setAttachmentPropertyName(propertyName);
-                }
-            }
-        }
-    }
-
-    /**
-     * Hook into populate so we can set the maintenance documents and feed the field values to its maintainables.
-     */
-    @Override
-    public void populate(HttpServletRequest request) {
-        super.populate(request);
-
-
-        // document type name is null on start, otherwise should be here
-        if (StringUtils.isNotBlank(getDocTypeName())) {
-            Map localOldMaintainableValues = new HashMap();
-            Map localNewMaintainableValues = new HashMap();
-            Map<String,String> localNewCollectionValues = new HashMap<String,String>();
-            for (Enumeration i = request.getParameterNames(); i.hasMoreElements();) {
-                String parameter = (String) i.nextElement();
-                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
-                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
-                    localOldMaintainableValues.put(propertyName, request.getParameter(parameter));
-                }
-                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-                    localNewMaintainableValues.put(propertyName, request.getParameter(parameter));
-                }
-            }
-            
-            // now, get all add lines and store them to a separate map
-            // for use in a separate call to the maintainable
-            for ( Object obj : localNewMaintainableValues.entrySet() ) {
-                String key = (String)((Map.Entry)obj).getKey(); 
-                if ( key.startsWith( KNSConstants.MAINTENANCE_ADD_PREFIX ) ) {
-                    localNewCollectionValues.put( key.substring( KNSConstants.MAINTENANCE_ADD_PREFIX.length() ),
-                            (String)((Map.Entry)obj).getValue() );
-                }
-            }
-            if ( LOG.isDebugEnabled() ) {
-                LOG.debug( "checked for add line parameters - got: " + localNewCollectionValues );
-            }
-            
-            this.newMaintainableValues = localNewMaintainableValues;
-            this.oldMaintainableValues = localOldMaintainableValues;
-
-            MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
-
-            GlobalVariables.getErrorMap().addToErrorPath("document.oldMaintainableObject");
-            maintenanceDocument.getOldMaintainableObject().populateBusinessObject(localOldMaintainableValues, maintenanceDocument);
-            GlobalVariables.getErrorMap().removeFromErrorPath("document.oldMaintainableObject");
-
-            GlobalVariables.getErrorMap().addToErrorPath("document.newMaintainableObject");
-            // update the main object
-            Map cachedValues = 
-            	maintenanceDocument.getNewMaintainableObject().populateBusinessObject(localNewMaintainableValues, maintenanceDocument);
-            
-            if(maintenanceDocument.getFileAttachment() != null) {
-                populateAttachmentPropertyForBO(maintenanceDocument);
-            }
-            
-            // update add lines
-            localNewCollectionValues = org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().resolvePrincipalNamesToPrincipalIds((BusinessObject)maintenanceDocument.getNewMaintainableObject().getBusinessObject(), localNewCollectionValues);
-            cachedValues.putAll( maintenanceDocument.getNewMaintainableObject().populateNewCollectionLines( localNewCollectionValues ) );
-            GlobalVariables.getErrorMap().removeFromErrorPath("document.newMaintainableObject");
-
-            if (cachedValues.size() > 0) {
-                GlobalVariables.getErrorMap().putError(KNSConstants.DOCUMENT_ERRORS, RiceKeyConstants.ERROR_DOCUMENT_MAINTENANCE_FORMATTING_ERROR);
-                for (Iterator iter = cachedValues.keySet().iterator(); iter.hasNext();) {
-                    String propertyName = (String) iter.next();
-                    String value = (String) cachedValues.get(propertyName);
-                    cacheUnconvertedValue(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE + propertyName, value);
-                }
-            }
-        }
-    }
-
-    private void populateAttachmentPropertyForBO(MaintenanceDocumentBase maintenanceDocument) {
-        try {
-            Class type = ObjectUtils.easyGetPropertyType(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName());
-            ObjectUtils.setObjectProperty(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName(), type, maintenanceDocument.getFileAttachment());
-        } catch (FormatException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (IllegalAccessException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (InvocationTargetException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        }
-    }
-    
-    /**
-     * Merges rows of old and new for each section (tab) of the ui. Also, renames fields to prevent naming conflicts and does
-     * setting of read only fields.
-     * 
-     * @return Returns the maintenanceSections.
-     */
-    public List getSections() {
-        if (getDocument() == null) {
-            throw new RuntimeException("Document not set in maintenance form.");
-        }
-        if (((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject() == null) {
-            throw new RuntimeException("New maintainable not set in document.");
-        }
-        if ((KNSConstants.MAINTENANCE_EDIT_ACTION.equals(this.getMaintenanceAction()) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(this.getMaintenanceAction())) && ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject() == null) {
-            throw new RuntimeException("Old maintainable not set in document.");
-        }
-
-        // if the authorization stuff hasnt been applied yet, then apply it
-        if (authorizations == null) {
-            applyAuthorizations();
-        }
-
-        // get business object being maintained and its keys
-        List keyFieldNames = KNSServiceLocator.getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject().getBusinessObject().getClass());
-
-        // sections for maintenance document
-        Maintainable oldMaintainable = ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject();
-        oldMaintainable.setMaintenanceAction(getMaintenanceAction());
-        List oldMaintSections = oldMaintainable.getSections(null);
-        
-        Maintainable newMaintainable = ((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject();
-        newMaintainable.setMaintenanceAction(getMaintenanceAction());
-        List newMaintSections = newMaintainable.getSections(oldMaintainable);
-
-        // mesh sections for proper jsp display
-        List meshedSections = FieldUtils.meshSections(oldMaintSections, newMaintSections, keyFieldNames, getMaintenanceAction(), isReadOnly(), authorizations);
-
-        return meshedSections;
-    }
-
-    protected void applyAuthorizations() {
-        Document document = getDocument();
-        DocumentAuthorizationService docAuthService = KNSServiceLocator.getDocumentAuthorizationService();
-        DocumentAuthorizer documentAuthorizer = docAuthService.getDocumentAuthorizer(document);
-        useDocumentAuthorizer(documentAuthorizer);
-    }
-
-    @Override
-    protected void useDocumentAuthorizer(DocumentAuthorizer documentAuthorizer) {
-
-        // init some things we'll need
-        Person kualiUser = GlobalVariables.getUserSession().getPerson();
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) getDocument();
-        MaintenanceDocumentAuthorizer maintenanceDocumentAuthorizer = (MaintenanceDocumentAuthorizer) documentAuthorizer;
-
-        // set the overall document editing mode
-        setEditingMode(documentAuthorizer.getEditMode(maintenanceDocument, kualiUser ));
-
-        // WHY IS THIS READONLY STUFF HERE YOU ASK, GIVEN THE EDITMODE
-        //
-        // Thats a good question. It's basically just there to make the proper generation
-        // of UI stuff in the JSP code easier, as you can just set a simple var on the jsp
-        // with the isReadOnly property.
-        //
-        // ITS IMPORTANT TO NOTE that the readOnly flag is ALWAYS dependent on the EditingMode
-        // data. So EditingMode is authoritative, readOnly is there for convenience.
-        //
-
-        // set the readOnly flag for this document, default to readOnly = true
-        setReadOnly(true);
-        String editMode;
-        editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY);
-        if ("TRUE".equalsIgnoreCase(editMode)) {
-            setReadOnly(false);
-        }
-        editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY);
-        if ("TRUE".equalsIgnoreCase(editMode)) {
-            setReadOnly(false);
-        }
-
-        // set field permissions
-        setAuthorizations(maintenanceDocumentAuthorizer.getFieldAuthorizations(maintenanceDocument, kualiUser));
-
-        // set the overall document action flags
-        setDocumentActionFlags(maintenanceDocumentAuthorizer.getDocumentActionFlags(maintenanceDocument, kualiUser));
-    }
-
-    /**
-     * @return Returns the maintenanceAction.
-     */
-    public String getMaintenanceAction() {
-        return maintenanceAction;
-    }
-
-    /**
-     * @return Returns the businessObjectClassName.
-     */
-    public String getBusinessObjectClassName() {
-        return businessObjectClassName;
-    }
-
-    /**
-     * @param businessObjectClassName The businessObjectClassName to set.
-     */
-    public void setBusinessObjectClassName(String businessObjectClassName) {
-        this.businessObjectClassName = businessObjectClassName;
-    }
-
-    /**
-     * @return Returns the description.
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * @param description The description to set.
-     */
-    public void setDescription(String description) {
-        this.description = description;
-    }
-
-    /**
-     * @return Returns the isReadOnly.
-     */
-    public boolean isReadOnly() {
-        return readOnly;
-    }
-
-    /**
-     * @param readOnly The isReadOnly to set.
-     */
-    public void setReadOnly(boolean readOnly) {
-        this.readOnly = readOnly;
-    }
-
-    /**
-     * @return Returns the newMaintainableValues.
-     */
-    public Map getNewMaintainableValues() {
-        return newMaintainableValues;
-    }
-
-    /**
-     * @return Returns the oldMaintainableValues.
-     */
-    public Map getOldMaintainableValues() {
-        return oldMaintainableValues;
-    }
-
-    /**
-     * @param maintenanceAction The maintenanceAction to set.
-     */
-    public void setMaintenanceAction(String maintenanceAction) {
-        this.maintenanceAction = maintenanceAction;
-    }
-
-    /**
-     * Gets the authorizations attribute.
-     * 
-     * @return Returns the authorizations.
-     */
-    public MaintenanceDocumentAuthorizations getAuthorizations() {
-        return authorizations;
-    }
-
-    /**
-     * Sets the authorizations attribute value.
-     * 
-     * @param authorizations The authorizations to set.
-     */
-    public void setAuthorizations(MaintenanceDocumentAuthorizations authorizations) {
-        this.authorizations = authorizations;
-    }
-
-    /**
-     * Sets the newMaintainableValues attribute value.
-     * 
-     * @param newMaintainableValues The newMaintainableValues to set.
-     */
-    public void setNewMaintainableValues(Map newMaintainableValues) {
-        this.newMaintainableValues = newMaintainableValues;
-    }
-
-
-    /**
-     * Sets the oldMaintainableValues attribute value.
-     * 
-     * @param oldMaintainableValues The oldMaintainableValues to set.
-     */
-    public void setOldMaintainableValues(Map oldMaintainableValues) {
-        this.oldMaintainableValues = oldMaintainableValues;
-    }
-
-
-    public String getLookupResultsSequenceNumber() {
-        return lookupResultsSequenceNumber;
-    }
-
-
-    public void setLookupResultsSequenceNumber(String lookupResultsSequenceNumber) {
-        this.lookupResultsSequenceNumber = lookupResultsSequenceNumber;
-    }
-
-
-    public String getLookupResultsBOClassName() {
-        return lookupResultsBOClassName;
-    }
-
-
-    public void setLookupResultsBOClassName(String lookupResultsBOClassName) {
-        this.lookupResultsBOClassName = lookupResultsBOClassName;
-    }
-
-
-    public String getLookedUpCollectionName() {
-        return lookedUpCollectionName;
-    }
-
-
-    public void setLookedUpCollectionName(String lookedUpCollectionName) {
-        this.lookedUpCollectionName = lookedUpCollectionName;
-    }
-
-    public String getAdditionalSectionsFile() {
-        if ( businessObjectClassName != null ) {
-            try {
-                MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-                String docTypeName = maintenanceDocumentDictionaryService.getDocumentTypeName(Class.forName(businessObjectClassName));
-                return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(businessObjectClassName).getAdditionalSectionsFile();
-            } catch ( ClassNotFoundException ex ) {
-                LOG.error( "Unable to resolve business object class", ex);
-            }
-        }else{
-            MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-            return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(this.getDocTypeName()).getAdditionalSectionsFile();
-        }
-        return null;
-    }
-
-	/**
-	 * This overridden method handles the case where maint doc properties do not reflect the true nature of the 
-	 * 
-	 * @see org.kuali.rice.kns.web.struts.form.KualiForm#retrieveFormValueForLookupInquiryParameters(java.lang.String, java.lang.String)
-	 */
-	@Override
-	public String retrieveFormValueForLookupInquiryParameters(String parameterName, String parameterValueLocation) {
-		MaintenanceDocument maintDoc = (MaintenanceDocument) getDocument();
-		if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
-            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
-            if (maintDoc.getOldMaintainableObject() != null && maintDoc.getOldMaintainableObject().getBusinessObject() != null) {
-            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getOldMaintainableObject().getBusinessObject(), propertyName);
-            	if (parameterValue == null) {
-            		return null;
-            	}
-            	if (parameterValue instanceof String) {
-            		return (String) parameterValue;
-            	}
-            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
-        		return (String) formatter.format(parameterValue);	
-            }
-        }
-        if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-            if (maintDoc.getNewMaintainableObject() != null && maintDoc.getNewMaintainableObject().getBusinessObject() != null) {
-            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getNewMaintainableObject().getBusinessObject(), propertyName);
-            	if (parameterValue == null) {
-            		return null;
-            	}
-            	if (parameterValue instanceof String) {
-            		return (String) parameterValue;
-            	}
-            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
-        		return (String) formatter.format(parameterValue);	
-            }
-        }
-		return super.retrieveFormValueForLookupInquiryParameters(parameterName, parameterValueLocation);
-	}
-}
+/*
+ * Copyright 2005-2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.web.struts.form;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.struts.upload.FormFile;
+import org.kuali.rice.core.config.ConfigurationException;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.bo.BusinessObject;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.document.MaintenanceDocumentBase;
+import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
+import org.kuali.rice.kns.exception.UnknownDocumentTypeException;
+import org.kuali.rice.kns.maintenance.Maintainable;
+import org.kuali.rice.kns.service.DocumentAuthorizationService;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.FieldUtils;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.util.RiceKeyConstants;
+import org.kuali.rice.kns.web.format.FormatException;
+import org.kuali.rice.kns.web.format.Formatter;
+
+
+/**
+ * This class is the base action form for all maintenance documents.
+ * 
+ * 
+ */
+public class KualiMaintenanceForm extends KualiDocumentFormBase {
+    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KualiMaintenanceForm.class);
+
+    private static final long serialVersionUID = 1L;
+
+    private String businessObjectClassName;
+    private String description;
+    private boolean readOnly;
+    private Map oldMaintainableValues;
+    private Map newMaintainableValues;
+    private String maintenanceAction;
+    
+    /**
+     * Used to indicate which result set we're using when refreshing/returning from a multi-value lookup
+     */
+    private String lookupResultsSequenceNumber;
+    /**
+     * The type of result returned by the multi-value lookup
+     * 
+     * TODO: to be persisted in the lookup results service instead?
+     */
+    private String lookupResultsBOClassName;
+    
+    /**
+     * The name of the collection looked up (by a multiple value lookup)
+     */
+    private String lookedUpCollectionName;
+    
+    private MaintenanceDocumentAuthorizations authorizations;
+    
+    /**
+     * Override the default method to add the if statement which can't be called until after parameters from a multipart request
+     * have been made accessible, but which must be called before the parameter values are used to instantiate and populate business
+     * objects.
+     * 
+     * @param requestParameters
+     */
+    @Override
+    public void postprocessRequestParameters(Map requestParameters) {
+        super.postprocessRequestParameters(requestParameters);
+
+        String docTypeName = null;
+        String[] docTypeNames = (String[]) requestParameters.get(KNSConstants.DOCUMENT_TYPE_NAME);
+        if ((docTypeNames != null) && (docTypeNames.length > 0)) {
+            docTypeName = docTypeNames[0];
+        }
+
+        if (StringUtils.isNotBlank(docTypeName)) {          
+        	if(this.getDocument() == null){
+            setDocTypeName(docTypeName);
+            Class documentClass = KNSServiceLocator.getDataDictionaryService().getDocumentClassByTypeName(docTypeName);
+            if (documentClass == null) {
+                throw new UnknownDocumentTypeException("unable to get class for unknown documentTypeName '" + docTypeName + "'");
+            }
+            if (!MaintenanceDocumentBase.class.isAssignableFrom(documentClass)) {
+                throw new ConfigurationException("Document class '" + documentClass + "' is not assignable to '" + MaintenanceDocumentBase.class + "'");
+            }
+            Document document = null;
+            try {
+                Class[] defaultConstructor = new Class[]{String.class};
+                Constructor cons = documentClass.getConstructor(defaultConstructor);
+                if (ObjectUtils.isNull(cons)) {
+                    throw new ConfigurationException("Could not find constructor with document type name parameter needed for Maintenance Document Base class");
+                }
+                document = (Document) cons.newInstance(docTypeName);
+            } catch (SecurityException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document: No constructor with String parameter found", e);
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (InstantiationException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (IllegalArgumentException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            }
+            if (document == null) {
+                throw new RuntimeException("Unable to instantiate document with type name '" + docTypeName + "' and document class '" + documentClass + "'");
+            }
+            setDocument(document);
+          } 
+       }
+        
+        MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
+        
+        //Handling the Multi-Part Attachment
+        for ( Object obj : requestParameters.entrySet() ) {
+            String parameter = (String)((Map.Entry)obj).getKey(); 
+            if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+                String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+                Object propertyValue = requestParameters.get(parameter);
+                
+                if(propertyValue != null && propertyValue instanceof FormFile) {
+                    if(StringUtils.isNotEmpty(((FormFile)propertyValue).getFileName())) {
+                        maintenanceDocument.setFileAttachment((FormFile) propertyValue);
+                    }
+                    maintenanceDocument.setAttachmentPropertyName(propertyName);
+                }
+            }
+        }
+    }
+
+    /**
+     * Hook into populate so we can set the maintenance documents and feed the field values to its maintainables.
+     */
+    @Override
+    public void populate(HttpServletRequest request) {
+        super.populate(request);
+
+
+        // document type name is null on start, otherwise should be here
+        if (StringUtils.isNotBlank(getDocTypeName())) {
+            Map localOldMaintainableValues = new HashMap();
+            Map localNewMaintainableValues = new HashMap();
+            Map<String,String> localNewCollectionValues = new HashMap<String,String>();
+            for (Enumeration i = request.getParameterNames(); i.hasMoreElements();) {
+                String parameter = (String) i.nextElement();
+                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
+                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+                    localOldMaintainableValues.put(propertyName, request.getParameter(parameter));
+                }
+                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+                    localNewMaintainableValues.put(propertyName, request.getParameter(parameter));
+                }
+            }
+            
+            // now, get all add lines and store them to a separate map
+            // for use in a separate call to the maintainable
+            for ( Object obj : localNewMaintainableValues.entrySet() ) {
+                String key = (String)((Map.Entry)obj).getKey(); 
+                if ( key.startsWith( KNSConstants.MAINTENANCE_ADD_PREFIX ) ) {
+                    localNewCollectionValues.put( key.substring( KNSConstants.MAINTENANCE_ADD_PREFIX.length() ),
+                            (String)((Map.Entry)obj).getValue() );
+                }
+            }
+            if ( LOG.isDebugEnabled() ) {
+                LOG.debug( "checked for add line parameters - got: " + localNewCollectionValues );
+            }
+            
+            this.newMaintainableValues = localNewMaintainableValues;
+            this.oldMaintainableValues = localOldMaintainableValues;
+
+            MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
+
+            GlobalVariables.getErrorMap().addToErrorPath("document.oldMaintainableObject");
+            maintenanceDocument.getOldMaintainableObject().populateBusinessObject(localOldMaintainableValues, maintenanceDocument);
+            GlobalVariables.getErrorMap().removeFromErrorPath("document.oldMaintainableObject");
+
+            GlobalVariables.getErrorMap().addToErrorPath("document.newMaintainableObject");
+            // update the main object
+            Map cachedValues = 
+            	maintenanceDocument.getNewMaintainableObject().populateBusinessObject(localNewMaintainableValues, maintenanceDocument);
+            
+            if(maintenanceDocument.getFileAttachment() != null) {
+                populateAttachmentPropertyForBO(maintenanceDocument);
+            }
+            
+            // update add lines
+            localNewCollectionValues = org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().resolvePrincipalNamesToPrincipalIds((BusinessObject)maintenanceDocument.getNewMaintainableObject().getBusinessObject(), localNewCollectionValues);
+            cachedValues.putAll( maintenanceDocument.getNewMaintainableObject().populateNewCollectionLines( localNewCollectionValues ) );
+            GlobalVariables.getErrorMap().removeFromErrorPath("document.newMaintainableObject");
+
+            if (cachedValues.size() > 0) {
+                GlobalVariables.getErrorMap().putError(KNSConstants.DOCUMENT_ERRORS, RiceKeyConstants.ERROR_DOCUMENT_MAINTENANCE_FORMATTING_ERROR);
+                for (Iterator iter = cachedValues.keySet().iterator(); iter.hasNext();) {
+                    String propertyName = (String) iter.next();
+                    String value = (String) cachedValues.get(propertyName);
+                    cacheUnconvertedValue(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE + propertyName, value);
+                }
+            }
+        }
+    }
+
+    private void populateAttachmentPropertyForBO(MaintenanceDocumentBase maintenanceDocument) {
+        try {
+            Class type = ObjectUtils.easyGetPropertyType(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName());
+            ObjectUtils.setObjectProperty(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName(), type, maintenanceDocument.getFileAttachment());
+        } catch (FormatException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        }
+    }
+    
+    /**
+     * Merges rows of old and new for each section (tab) of the ui. Also, renames fields to prevent naming conflicts and does
+     * setting of read only fields.
+     * 
+     * @return Returns the maintenanceSections.
+     */
+    public List getSections() {
+        if (getDocument() == null) {
+            throw new RuntimeException("Document not set in maintenance form.");
+        }
+        if (((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject() == null) {
+            throw new RuntimeException("New maintainable not set in document.");
+        }
+        if ((KNSConstants.MAINTENANCE_EDIT_ACTION.equals(this.getMaintenanceAction()) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(this.getMaintenanceAction())) && ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject() == null) {
+            throw new RuntimeException("Old maintainable not set in document.");
+        }
+
+        // if the authorization stuff hasnt been applied yet, then apply it
+        if (authorizations == null) {
+            applyAuthorizations();
+        }
+
+        // get business object being maintained and its keys
+        List keyFieldNames = KNSServiceLocator.getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject().getBusinessObject().getClass());
+
+        // sections for maintenance document
+        Maintainable oldMaintainable = ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject();
+        oldMaintainable.setMaintenanceAction(getMaintenanceAction());
+        List oldMaintSections = oldMaintainable.getSections(null);
+        
+        Maintainable newMaintainable = ((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject();
+        newMaintainable.setMaintenanceAction(getMaintenanceAction());
+        List newMaintSections = newMaintainable.getSections(oldMaintainable);
+
+        // mesh sections for proper jsp display
+        List meshedSections = FieldUtils.meshSections(oldMaintSections, newMaintSections, keyFieldNames, getMaintenanceAction(), isReadOnly(), authorizations);
+
+        return meshedSections;
+    }
+
+    protected void applyAuthorizations() {
+        Document document = getDocument();
+        DocumentAuthorizationService docAuthService = KNSServiceLocator.getDocumentAuthorizationService();
+        DocumentAuthorizer documentAuthorizer = docAuthService.getDocumentAuthorizer(document);
+        useDocumentAuthorizer(documentAuthorizer);
+    }
+
+    @Override
+    protected void useDocumentAuthorizer(DocumentAuthorizer documentAuthorizer) {
+
+        // init some things we'll need
+        Person kualiUser = GlobalVariables.getUserSession().getPerson();
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) getDocument();
+        MaintenanceDocumentAuthorizer maintenanceDocumentAuthorizer = (MaintenanceDocumentAuthorizer) documentAuthorizer;
+
+        // set the overall document editing mode
+        //setEditingMode(documentAuthorizer.getEditMode(maintenanceDocument, kualiUser ));
+
+        // WHY IS THIS READONLY STUFF HERE YOU ASK, GIVEN THE EDITMODE
+        //
+        // Thats a good question. It's basically just there to make the proper generation
+        // of UI stuff in the JSP code easier, as you can just set a simple var on the jsp
+        // with the isReadOnly property.
+        //
+        // ITS IMPORTANT TO NOTE that the readOnly flag is ALWAYS dependent on the EditingMode
+        // data. So EditingMode is authoritative, readOnly is there for convenience.
+        //        
+        //String editMode;
+        //editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY);
+        //if ("TRUE".equalsIgnoreCase(editMode)) {
+        //    setReadOnly(false);
+        //}
+        //editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY);
+        //if ("TRUE".equalsIgnoreCase(editMode)) {
+        //    setReadOnly(false);
+        //}
+
+        // set the readOnly flag for this document, default to readOnly = true
+        setReadOnly(true);
+        
+        // Check overall document edit permission
+        if(!maintenanceDocumentAuthorizer.isViewOnly(getDocument(), kualiUser)){
+        	setReadOnly(false);
+        }
+        
+        // set field permissions
+        setAuthorizations(maintenanceDocumentAuthorizer.getFieldAuthorizations(maintenanceDocument, kualiUser));
+
+        // set the overall document action flags
+        setDocumentActionFlags(maintenanceDocumentAuthorizer.getDocumentActionFlags(maintenanceDocument, kualiUser));
+    }
+
+    /**
+     * @return Returns the maintenanceAction.
+     */
+    public String getMaintenanceAction() {
+        return maintenanceAction;
+    }
+
+    /**
+     * @return Returns the businessObjectClassName.
+     */
+    public String getBusinessObjectClassName() {
+        return businessObjectClassName;
+    }
+
+    /**
+     * @param businessObjectClassName The businessObjectClassName to set.
+     */
+    public void setBusinessObjectClassName(String businessObjectClassName) {
+        this.businessObjectClassName = businessObjectClassName;
+    }
+
+    /**
+     * @return Returns the description.
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * @param description The description to set.
+     */
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    /**
+     * @return Returns the isReadOnly.
+     */
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    /**
+     * @param readOnly The isReadOnly to set.
+     */
+    public void setReadOnly(boolean readOnly) {
+        this.readOnly = readOnly;
+    }
+
+    /**
+     * @return Returns the newMaintainableValues.
+     */
+    public Map getNewMaintainableValues() {
+        return newMaintainableValues;
+    }
+
+    /**
+     * @return Returns the oldMaintainableValues.
+     */
+    public Map getOldMaintainableValues() {
+        return oldMaintainableValues;
+    }
+
+    /**
+     * @param maintenanceAction The maintenanceAction to set.
+     */
+    public void setMaintenanceAction(String maintenanceAction) {
+        this.maintenanceAction = maintenanceAction;
+    }
+
+    /**
+     * Gets the authorizations attribute.
+     * 
+     * @return Returns the authorizations.
+     */
+    public MaintenanceDocumentAuthorizations getAuthorizations() {
+        return authorizations;
+    }
+
+    /**
+     * Sets the authorizations attribute value.
+     * 
+     * @param authorizations The authorizations to set.
+     */
+    public void setAuthorizations(MaintenanceDocumentAuthorizations authorizations) {
+        this.authorizations = authorizations;
+    }
+
+    /**
+     * Sets the newMaintainableValues attribute value.
+     * 
+     * @param newMaintainableValues The newMaintainableValues to set.
+     */
+    public void setNewMaintainableValues(Map newMaintainableValues) {
+        this.newMaintainableValues = newMaintainableValues;
+    }
+
+
+    /**
+     * Sets the oldMaintainableValues attribute value.
+     * 
+     * @param oldMaintainableValues The oldMaintainableValues to set.
+     */
+    public void setOldMaintainableValues(Map oldMaintainableValues) {
+        this.oldMaintainableValues = oldMaintainableValues;
+    }
+
+
+    public String getLookupResultsSequenceNumber() {
+        return lookupResultsSequenceNumber;
+    }
+
+
+    public void setLookupResultsSequenceNumber(String lookupResultsSequenceNumber) {
+        this.lookupResultsSequenceNumber = lookupResultsSequenceNumber;
+    }
+
+
+    public String getLookupResultsBOClassName() {
+        return lookupResultsBOClassName;
+    }
+
+
+    public void setLookupResultsBOClassName(String lookupResultsBOClassName) {
+        this.lookupResultsBOClassName = lookupResultsBOClassName;
+    }
+
+
+    public String getLookedUpCollectionName() {
+        return lookedUpCollectionName;
+    }
+
+
+    public void setLookedUpCollectionName(String lookedUpCollectionName) {
+        this.lookedUpCollectionName = lookedUpCollectionName;
+    }
+
+    public String getAdditionalSectionsFile() {
+        if ( businessObjectClassName != null ) {
+            try {
+                MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+                String docTypeName = maintenanceDocumentDictionaryService.getDocumentTypeName(Class.forName(businessObjectClassName));
+                return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(businessObjectClassName).getAdditionalSectionsFile();
+            } catch ( ClassNotFoundException ex ) {
+                LOG.error( "Unable to resolve business object class", ex);
+            }
+        }else{
+            MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+            return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(this.getDocTypeName()).getAdditionalSectionsFile();
+        }
+        return null;
+    }
+
+	/**
+	 * This overridden method handles the case where maint doc properties do not reflect the true nature of the 
+	 * 
+	 * @see org.kuali.rice.kns.web.struts.form.KualiForm#retrieveFormValueForLookupInquiryParameters(java.lang.String, java.lang.String)
+	 */
+	@Override
+	public String retrieveFormValueForLookupInquiryParameters(String parameterName, String parameterValueLocation) {
+		MaintenanceDocument maintDoc = (MaintenanceDocument) getDocument();
+		if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
+            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+            if (maintDoc.getOldMaintainableObject() != null && maintDoc.getOldMaintainableObject().getBusinessObject() != null) {
+            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getOldMaintainableObject().getBusinessObject(), propertyName);
+            	if (parameterValue == null) {
+            		return null;
+            	}
+            	if (parameterValue instanceof String) {
+            		return (String) parameterValue;
+            	}
+            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
+        		return (String) formatter.format(parameterValue);	
+            }
+        }
+        if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+            if (maintDoc.getNewMaintainableObject() != null && maintDoc.getNewMaintainableObject().getBusinessObject() != null) {
+            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getNewMaintainableObject().getBusinessObject(), propertyName);
+            	if (parameterValue == null) {
+            		return null;
+            	}
+            	if (parameterValue instanceof String) {
+            		return (String) parameterValue;
+            	}
+            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
+        		return (String) formatter.format(parameterValue);	
+            }
+        }
+		return super.retrieveFormValueForLookupInquiryParameters(parameterName, parameterValueLocation);
+	}
+}
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeSecurity.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeSecurity.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeSecurity.java	(working copy)
@@ -147,4 +147,17 @@
 		}
 	}
 
+	public String getDisplayMaskValue(Object value){
+		String displayMaskValue = "";
+        if(isMask())
+        	displayMaskValue = getMaskFormatter().maskValue(value);
+        else if(isPartialMask())
+        	displayMaskValue = getPartialMaskFormatter().maskValue(value);
+        return displayMaskValue;
+	}
+	
+	public boolean shouldBeEncrypted(){
+		return isMask() || isPartialMask();
+	}
+	
 }
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(working copy)
@@ -1,40 +1,44 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-
-/**
- * Extension to DocumentAuthorizer for Maintenance Document specific methods
- * 
- * 
- */
-public interface MaintenanceDocumentAuthorizer extends DocumentAuthorizer {
-
-    /**
-     * 
-     * This method returns the set of authorization restrictions (if any) that apply to this object in this context.
-     * 
-     * @param document
-     * @param user
-     * @return MaintenanceDocumentAuthorizations
-     * 
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
-
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+
+/**
+ * Extension to DocumentAuthorizer for Maintenance Document specific methods
+ * 
+ * 
+ */
+public interface MaintenanceDocumentAuthorizer extends DocumentAuthorizer {
+
+    /**
+     * 
+     * This method returns the set of authorization restrictions (if any) that apply to this object in this context.
+     * 
+     * @param document
+     * @param user
+     * @return MaintenanceDocumentAuthorizations
+     * 
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
+    
+   
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/inquiry/KualiInquirableImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/inquiry/KualiInquirableImpl.java	(revision 5105)
+++ impl/src/main/java/org/kuali/rice/kns/inquiry/KualiInquirableImpl.java	(working copy)
@@ -33,6 +33,7 @@
 import org.kuali.rice.kns.bo.BusinessObjectRelationship;
 import org.kuali.rice.kns.bo.DocumentHeader;
 import org.kuali.rice.kns.bo.ExternalizableBusinessObject;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
 import org.kuali.rice.kns.datadictionary.InquirySectionDefinition;
 import org.kuali.rice.kns.lookup.CollectionIncomplete;
 import org.kuali.rice.kns.lookup.HtmlData;
@@ -303,19 +304,35 @@
 
             // Encrypt value if it is a secure field
             //String displayWorkgroup = getDataDictionaryService().getAttributeDisplayWorkgroup(businessObject.getClass(), keyName);
-            boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(
-					GlobalVariables.getUserSession().getPerson(), businessObject.getClass().getName(), keyName);
-            if (!viewAuthorized) {
-                try {
-                    keyValue = getEncryptionService().encrypt(keyValue);
+            //boolean viewAuthorized = KNSServiceLocator.getAuthorizationService().isAuthorizedToViewAttribute(
+			//		GlobalVariables.getUserSession().getPerson(), businessObject.getClass().getName(), keyName);
+            //if (!viewAuthorized) {
+            AttributeSecurity attributeSecurity = KNSServiceLocator.getDataDictionaryService().getAttributeSecurity(businessObject.getClass().getName(), keyName);
+            if(attributeSecurity != null && attributeSecurity.isMask()){
+            	boolean viewAuthorized =  KNSServiceLocator.getAuthorizationService().isAuthorizedToUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), businessObject.getClass().getSimpleName(), keyName);
+            	if(!viewAuthorized){
+            		try {
+                        keyValue = getEncryptionService().encrypt(keyValue);
+                    }
+                    catch (GeneralSecurityException e) {
+                        LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
+                        throw new RuntimeException(e);
+                    }
+            	}
+            }
+            if(attributeSecurity != null && attributeSecurity.isPartialMask()){
+            	boolean viewAuthorized =  KNSServiceLocator.getAuthorizationService().isAuthorizedToPartiallyUnmaskAttribute(GlobalVariables.getUserSession().getPerson(), businessObject.getClass().getSimpleName(), keyName);
+                if(!viewAuthorized){
+                	try {
+                        keyValue = getEncryptionService().encrypt(keyValue);
+                    }
+                    catch (GeneralSecurityException e) {
+                        LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
+                        throw new RuntimeException(e);
+                    }
                 }
-                catch (GeneralSecurityException e) {
-                    LOG.error("Exception while trying to encrypted value for inquiry framework.", e);
-                    throw new RuntimeException(e);
-                }
-
-            }
-
+			}
+            
             parameters.put(keyName, keyValue);
             fieldList.put(keyName, keyValue.toString());
         }
Index: impl/src/main/java/org/kuali/rice/kim/util/InquiryAttributeSecurityUtils.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/InquiryAttributeSecurityUtils.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kim/util/InquiryAttributeSecurityUtils.java	(revision 0)
@@ -0,0 +1,101 @@
+/*
+ * Copyright 2007 The Kuali Foundation
+ *
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.opensource.org/licenses/ecl1.php
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kim.util;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.bo.FieldAttributeSecurity;
+import org.kuali.rice.kns.datadictionary.AttributeDefinition;
+import org.kuali.rice.kns.datadictionary.BusinessObjectEntry;
+import org.kuali.rice.kns.datadictionary.FieldDefinition;
+import org.kuali.rice.kns.datadictionary.InquiryCollectionDefinition;
+import org.kuali.rice.kns.datadictionary.InquirySectionDefinition;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.util.KNSConstants;
+
+/**
+ * This is a description of what this class does - mpham don't forget to fill
+ * this in.
+ * 
+ * @author Kuali Rice Team (kuali-rice@googlegroups.com)
+ * 
+ */
+public class InquiryAttributeSecurityUtils {
+
+	public static Map<String, FieldAttributeSecurity> getRestrictedInquiryFields(
+			BusinessObjectEntry objectEntry) {
+		List<InquirySectionDefinition> inquirySections = objectEntry
+				.getInquiryDefinition().getInquirySections();
+		Map<String, FieldAttributeSecurity> returnInquiryFieldList = new HashMap<String, FieldAttributeSecurity>();
+		for (InquirySectionDefinition inquirySectionDefinition : inquirySections) {
+			returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(inquirySectionDefinition
+							.getInquiryFields(), objectEntry
+							.getBusinessObjectClass(),
+					KNSConstants.EMPTY_STRING));
+			Map inquiryCollectionDefinition = inquirySectionDefinition
+			.getInquiryCollections();
+			if(inquiryCollectionDefinition != null && !inquiryCollectionDefinition.isEmpty()){
+				returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(inquirySectionDefinition
+						.getInquiryCollections().values(), objectEntry
+						.getBusinessObjectClass(),
+				KNSConstants.EMPTY_STRING));
+			}
+		}
+		return returnInquiryFieldList;
+	}
+
+	public static Map<String, FieldAttributeSecurity> getRestrictedInquiryFieldList(
+			Collection fieldDefinitions, Class boClass, String key) {
+		key = StringUtils.isEmpty(key) ? "" : key + ".";
+		Map<String, FieldAttributeSecurity> returnInquiryFieldList = new HashMap<String, FieldAttributeSecurity>();
+		for (Object fieldDefinition : fieldDefinitions) {
+			if (fieldDefinition instanceof InquiryCollectionDefinition) {
+				InquiryCollectionDefinition collection = (InquiryCollectionDefinition) fieldDefinition;
+				returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(
+						collection.getInquiryCollections(), collection
+								.getBusinessObjectClass(), key
+								+ collection.getAttributeName()));
+				returnInquiryFieldList.putAll(getRestrictedInquiryFieldList(
+						collection.getInquiryFields(), collection
+								.getBusinessObjectClass(), key));
+			} else if (fieldDefinition instanceof FieldDefinition) {
+				FieldDefinition fields = (FieldDefinition) fieldDefinition;
+				AttributeDefinition attributeDefinition = (KNSServiceLocator
+						.getDataDictionaryService().getDataDictionary()
+						.getBusinessObjectEntry(boClass.getName())
+						.getAttributeDefinition(fields.getAttributeName()));
+				if (attributeDefinition != null
+						&& attributeDefinition.getAttributeSecurity() != null) {
+					FieldAttributeSecurity fieldAttributeSecurity = new FieldAttributeSecurity();
+					fieldAttributeSecurity.setAttributeName(fields
+							.getAttributeName());
+					fieldAttributeSecurity.setBusinessObjectClass(boClass);
+					fieldAttributeSecurity
+							.setBusinessObjectAttributeSecurity(attributeDefinition
+									.getAttributeSecurity());
+
+					returnInquiryFieldList.put(key + fields.getAttributeName(),
+							fieldAttributeSecurity);
+				}
+			}
+		}
+		return returnInquiryFieldList;
+	}
+}
Index: impl/src/main/java/org/kuali/rice/kns/service/impl/AuthorizationServiceImpl.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/service/impl/AuthorizationServiceImpl.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/service/impl/AuthorizationServiceImpl.java	(working copy)
@@ -22,10 +22,14 @@
 import org.apache.commons.logging.Log;
 import org.apache.commons.logging.LogFactory;
 import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.service.IdentityManagementService;
 import org.kuali.rice.kim.service.KIMServiceLocator;
+import org.kuali.rice.kim.util.KimConstants;
 import org.kuali.rice.kns.authorization.AuthorizationStore;
 import org.kuali.rice.kns.datadictionary.AuthorizationDefinition;
 import org.kuali.rice.kns.datadictionary.DocumentEntry;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
 import org.kuali.rice.kns.service.AuthorizationService;
 import org.kuali.rice.kns.service.DataDictionaryService;
 
@@ -40,6 +44,7 @@
 
     private AuthorizationStore authorizationStore;
     private DataDictionaryService dataDictionaryService;
+    private static IdentityManagementService identityManagementService;
 
     private boolean disabled;
 
@@ -95,6 +100,8 @@
      *      java.lang.String)
      */
     public boolean isAuthorized(Person user, String action, String targetType) {
+    	
+    	
         return disabled || authorizationStore.isAuthorized(user, action, targetType);
     }
     
@@ -111,7 +118,7 @@
      * @see org.kuali.rice.kns.service.AuthorizationService#isAuthorizedToViewAttribute(org.kuali.rice.kns.bo.user.KualiUser,
      *      java.lang.String, java.lang.String)
      */
-    public boolean isAuthorizedToViewAttribute(Person user, String entryName, String attributeName) {
+   public boolean isAuthorizedToViewAttribute(Person user, String entryName, String attributeName) {
         boolean authorized = true;
 
         String displayWorkgroupName = this.dataDictionaryService.getAttributeDisplayWorkgroup(entryName, attributeName);
@@ -123,8 +130,50 @@
 
         return authorized;
     }
-
+    
     /**
+     * @see org.kuali.rice.kns.service.AuthorizationService#isAuthorizedToUnmaskAttribute(org.kuali.rice.kns.bo.user.KualiUser,
+     *      java.lang.String, java.lang.String)
+     */
+    public boolean isAuthorizedToUnmaskAttribute(Person user, String entryName, String attributeName) {
+        boolean authorized = false;
+        //TODO:Should use ParameterService.getDetailType to get the componentName
+        String componentName = entryName;
+        //TODO: Should use ParameterService getNameSpace to get name space
+        String nameSpaceCode = "KR-NS";
+        
+        AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, entryName);
+ 	    permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, attributeName);
+ 	    
+	   if(getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+	       authorized = true;
+	   }
+        return authorized;
+    }
+    
+    /**
+     * @see org.kuali.rice.kns.service.AuthorizationService#isAuthorizedToPartiallyUnmaskAttribute(org.kuali.rice.kns.bo.user.KualiUser,
+     *      java.lang.String, java.lang.String)
+     */
+    public boolean isAuthorizedToPartiallyUnmaskAttribute(Person user, String entryName, String attributeName) {
+        boolean authorized = false;
+        //TODO:Should use ParameterService.getDetailType to get the componentName
+        String componentName = entryName;
+        //TODO: Should use ParameterService getNameSpace to get name space
+        String nameSpaceCode = "KR-NS";
+        
+        AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, entryName);
+ 	    permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, attributeName);
+ 	    
+	   if(getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+	       authorized = true;
+	   }
+        return authorized;
+    }
+    
+    /**
      * If disable is true, isAuthorized will thenceforth always return true regardless of the contents of the authorzationStore; if
      * false, isAuthorized will return results based on the contents of the authorizationStore.
      * 
@@ -143,5 +192,17 @@
     public DataDictionaryService getDataDictionaryService() {
         return this.dataDictionaryService;
     }
+    
+	/**
+	 * @return the identityManagementService
+	 */
+	public static IdentityManagementService getIdentityManagementService() {
+		
+		if (identityManagementService == null ) {
+			identityManagementService = KIMServiceLocator.getIdentityManagementService();
+		}
+		return identityManagementService;
+	}
+    
 }
-
+
Index: web/src/main/webapp/WEB-INF/tags/kr/rowDisplay.tag
===================================================================
--- web/src/main/webapp/WEB-INF/tags/kr/rowDisplay.tag	(revision 5288)
+++ web/src/main/webapp/WEB-INF/tags/kr/rowDisplay.tag	(working copy)
@@ -98,7 +98,7 @@
                 
 			<%-- isFieldSecure determines whether or not the encrypted value should be shown for 
 			non-collections and a similar function for collections --%>
-			<c:set var="isFieldSecure" value="${field.secure && empty KualiForm.editingMode[field.displayEditMode]}" />
+			<c:set var="isFieldSecure" value="${field.secure}" />
 				
 			<%-- textStyle is used to store the style of the field value. i.e. whether or not it 
 			should display as red text. --%>
@@ -168,20 +168,23 @@
 			<c:choose>
 
 				<c:when test="${isFieldSecure and field.fieldType ne field.FILE}">
-					<input type="hidden" name="${field.propertyName}" 
-						value='<c:out value="${field.encryptedValue}"/>' />
+					<!-- hidden -->
+					<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}" 
+						value="${field.encryptedValue}" />
 
 				</c:when>
 
-				<c:when test="${isFieldReadOnly && not isFieldAContainer and field.fieldType ne field.FILE}">
+				<c:when test="${isFieldReadOnly && not isFieldSecure && not isFieldAContainer and field.fieldType ne field.FILE}">
 					<c:choose>
 						<c:when test= "${isInquiry || isLookup}">
-					  		<input type="hidden" name="${field.propertyName}" value='<c:out value="${fieldValue}"/>' />
+							<!-- hidden -->
+					  		<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}" value="${fieldValue}" />
 				  		</c:when>
 				  		<c:otherwise>
 							<c:if test="${not fn:contains(field.propertyName, Constants.MAINTENANCE_OLD_MAINTAINABLE)}">
-								<input type="hidden" name="${field.propertyName}" 
-									   value='<c:out value="${fieldValue}"/>' />
+								<!-- hidden -->
+								<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}" 
+									   value="${fieldValue}" />
 							</c:if>
 						</c:otherwise>
 				  	 </c:choose>
@@ -275,8 +278,9 @@
 			    		     so we'll just render the input parameter, but not display anything.  Of course, inquiries are read only, so there's really no reason
 			    		     to have the input tag for inquiries, but it doesn't cause any harm. --%>
 			    		<%-- prevent the field from being written a 2nd time --%>
-						<input type="hidden" name='${field.propertyName}'
-							value='<c:out value="${isFieldSecure ? field.encryptedValue : fieldValue}"/>' />
+						<!-- hidden -->
+						<html:hidden renderHiddenField="${isLookup}" name='${field.propertyName}'
+							value="${isFieldSecure ? field.encryptedValue : fieldValue}" />
 					</c:if>
 				</c:when>
 					
@@ -320,13 +324,14 @@
 							</c:when>
 
 							<c:otherwise>
-
-								<input type="text" id='${field.propertyName}' name='${field.propertyName}'
-									value='<c:out value="${fieldValue}"/>'
+								<!-- ${onblurcall} ? -->
+								<html:text id='${field.propertyName}' name='${field.propertyName}'
+									value='${fieldValue}'
 									size='${field.size}'
 									maxlength='${field.formattedMaxLength}'
-									style="${textStyle}" ${onblurcall} 
-									class="${field.styleClass }"/>
+									style="${textStyle}" 
+									onblur="${onblurcall}" 
+									styleClass="${field.styleClass }"></html:text>
 						    
 								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
 
@@ -353,14 +358,15 @@
 							</c:when>
 									
 							<c:otherwise>
-									
-								<input type="text" name='${field.propertyName}'
+								<!-- ${onblurcall} ? -->
+								<html:text name='${field.propertyName}'
 									id='${field.propertyName}'
-									value='<c:out value="${fieldValue}"/>'
+									value='${fieldValue}'
 									size='${field.size}'
 									maxlength='${field.maxLength}'
-									style="${textStyle}" ${onblurcall} 
-									class="${field.styleClass}"/>
+									style="${textStyle}"
+									onblur="${onblurcall}" 
+									styleClass="${field.styleClass}"/>
 						    
 								<c:if test="${field.datePicker eq true}">
 											
@@ -412,12 +418,14 @@
 
 							<c:otherwise>
 
-								<textarea id='${field.propertyName}' name='${field.propertyName}'
+								<!-- ${onblurcall} ? -->
+								<input type="textarea" id='${field.propertyName}' name='${field.propertyName}'
 									rows='${field.rows}'
 									cols='${field.cols}'
-									style="${textStyle}" ${onblurcall}
+									style="${textStyle}"
+									onblur="${onblurcall}" 
 									maxlength='${field.maxLength}' ><c:out
-									value="${fieldValue}"/></textarea>
+									value="${fieldValue}"/>
 								
 								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
 
@@ -447,10 +455,14 @@
 									
 							<c:otherwise>
 									
-								<input type="checkbox" id='${field.propertyName}' name="${field.propertyName}" 
-									${field.propertyValue eq 'Yes' || field.propertyValue eq 'YES' ? 'checked="checked"' : ''}
-									${onblurcall} />
-								<input type="hidden" name="${field.propertyName}${Constants.CHECKBOX_PRESENT_ON_FORM_ANNOTATION}" value="present"/>
+								<!--${field.propertyValue eq 'Yes' || field.propertyValue eq 'YES' ? 'checked="checked"' : ''}
+									${onblurcall}? -->
+								<html:checkbox id='${field.propertyName}' 
+									name="${field.propertyName}" 
+									onblur="${onblurcall}" 
+									value='${fieldValue}'/>
+								<!-- hidden -->
+								<html:hidden renderHiddenField="${isLookup}" name="${field.propertyName}${Constants.CHECKBOX_PRESENT_ON_FORM_ANNOTATION}" value="present"/>
 									
 							</c:otherwise>
 					
@@ -636,13 +648,15 @@
 							</c:when>
 									
 							<c:otherwise>
-								<input type="text" name='${field.propertyName}'
+								<!-- ${onblurcall} ? -->
+								<html:text name='${field.propertyName}'
 									id='${field.propertyName}'
-									value='<c:out value="${fieldValue}"/>'
+									value='${fieldValue}'
 									size='${field.size}'
 									maxlength='${field.maxLength}'
-									style="${textStyle}" ${onblurcall} 
-									class="${field.styleClass}"/>
+									style="${textStyle}" 
+									onblur="${onblurcall}" 
+									styleClass="${field.styleClass}"/>
 								
 								<!--  adding a lookup here because it goes to workflow as opposed to Kuali -->
 								<kul:workflowWorkgroupLookup fieldConversions="workgroupName:${field.propertyName}" />	
@@ -653,68 +667,69 @@
 					</td>
 				
 				</c:when>
-				
-				<c:when test="${field.fieldType eq field.FILE}">
-					<kul:fieldDefaultLabel isLookup="${isLookup}" isRequired="${field.fieldRequired}" isReadOnly="${isFieldReadOnly}" 
-						cellWidth="${dataCellWidth}%" fieldType="${field.fieldType}" fieldLabel="${field.fieldLabel}" fieldName="${field.propertyName}"/>
-								
-					<td class="grid" width="${dataCellWidth}%">
-						<c:choose>
-							<c:when test="${isFieldReadOnly}">
-								<c:if test="${empty fieldValue}" >
-									<c:out value="<%=((String) request.getAttribute("fileName"))%>" />&nbsp;
-								</c:if>
-								<c:if test="${not empty fieldValue}" >
-									<kul:fieldShowReadOnly field="${field}" addHighlighting="${addHighlighting}" />
-								</c:if>
-							</c:when> 
-									
-							<c:otherwise>
-									<c:choose>
-										<c:when test="${empty fieldValue}" >
-											<c:if test="${isMaintenance}" >
-											<input type="file" name='${field.propertyName}'
-												id='${field.propertyName}' 
-												size='${field.size}'
-												class="${field.styleClass}"/>
-											</c:if>
-										</c:when>
-										<c:otherwise>
-										<div id="replaceDiv" style="display:block;">
-											<html:image property="methodToCall.downloadAttachment" src="${ConfigProperties.kr.externalizable.images.url}clip.gif" alt="download attachment" style="padding:5px" onclick="excludeSubmitRestriction=true"/>
-											<c:out value="${fieldValue}"/>
-	                                    	&nbsp;&nbsp;
-	                                    		                                    	<input type="hidden" name='methodToCall' />
-    										<script type="text/javascript">
-												function replaceAttachment() {
-													excludeSubmitRestriction=true;
-													showHide('replaceFileDiv','replaceDiv');
-													document.forms[0].methodToCall.value='replaceAttachment';
-													submitForm();
-												}
-											</script>
-	                                    	<html:link linkName="replaceAttachment" onclick="javascript: replaceAttachment();" href="" anchor="" property="methodToCall.replaceAttachment">replace</html:link>
-	                                    </div>
-                                    	<div id="replaceFileDiv" valign="middle" style="display:none;">
-				                			<input type="file" name='${field.propertyName}'
-												id='${field.propertyName}' 
-												size='${field.size}'
-												class="${field.styleClass}"/>  
-										</div>
-										</c:otherwise>
-									</c:choose>
-									
-								 	
-								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
-							
-							</c:otherwise>
-					
-						</c:choose>
-						</div>
-					</td>
-				    
-				</c:when>
-									
+				
+				<c:when test="${field.fieldType eq field.FILE}">
+					<kul:fieldDefaultLabel isLookup="${isLookup}" isRequired="${field.fieldRequired}" isReadOnly="${isFieldReadOnly}" 
+						cellWidth="${dataCellWidth}%" fieldType="${field.fieldType}" fieldLabel="${field.fieldLabel}" fieldName="${field.propertyName}"/>
+								
+					<td class="grid" width="${dataCellWidth}%">
+						<c:choose>
+							<c:when test="${isFieldReadOnly}">
+								<c:if test="${empty fieldValue}" >
+									<c:out value="<%=((String) request.getAttribute("fileName"))%>" />&nbsp;
+								</c:if>
+								<c:if test="${not empty fieldValue}" >
+									<kul:fieldShowReadOnly field="${field}" addHighlighting="${addHighlighting}" />
+								</c:if>
+							</c:when> 
+									
+							<c:otherwise>
+									<c:choose>
+										<c:when test="${empty fieldValue}" >
+											<c:if test="${isMaintenance}" >
+											<input type="file" name='${field.propertyName}'
+												id='${field.propertyName}' 
+												size='${field.size}'
+												class="${field.styleClass}"/>
+											</c:if>
+										</c:when>
+										<c:otherwise>
+										<div id="replaceDiv" style="display:block;">
+											<html:image property="methodToCall.downloadAttachment" src="${ConfigProperties.kr.externalizable.images.url}clip.gif" alt="download attachment" style="padding:5px" onclick="excludeSubmitRestriction=true"/>
+											<c:out value="${fieldValue}"/>
+	                                    	&nbsp;&nbsp;
+                           					<!-- hidden -->
+	                                    	<html:hidden renderHiddenField="${isLookup}" name='methodToCall' />
+    										<script type="text/javascript">
+												function replaceAttachment() {
+													excludeSubmitRestriction=true;
+													showHide('replaceFileDiv','replaceDiv');
+													document.forms[0].methodToCall.value='replaceAttachment';
+													submitForm();
+												}
+											</script>
+	                                    	<html:link linkName="replaceAttachment" onclick="javascript: replaceAttachment();" href="" anchor="" property="methodToCall.replaceAttachment">replace</html:link>
+	                                    </div>
+                                    	<div id="replaceFileDiv" valign="middle" style="display:none;">
+				                			<input type="file" name='${field.propertyName}'
+												id='${field.propertyName}' 
+												size='${field.size}'
+												class="${field.styleClass}"/>  
+										</div>
+										</c:otherwise>
+									</c:choose>
+									
+								 	
+								<kul:fieldShowIcons isReadOnly="${isFieldReadOnly}" field="${field}" addHighlighting="${addHighlighting}" />
+							
+							</c:otherwise>
+					
+						</c:choose>
+						</div>
+					</td>
+				    
+				</c:when>
+									
 				<c:when test="${field.fieldType eq field.LOOKUP_HIDDEN || field.fieldType eq field.LOOKUP_READONLY}">
 			    
 					<kul:fieldDefaultLabel isLookup="${isLookup}" isRequired="${field.fieldRequired}" 
@@ -722,8 +737,8 @@
 						fieldLabel="${field.fieldLabel}" />
 								
 					<td class="grid" width="${dataCellWidth}%">
-								
-						<input type="hidden" name='${field.propertyName}' value='<c:out value="${fieldValue}"/>' />
+						<!-- hidden -->
+						<html:hidden renderHiddenField="${isLookup}" name='${field.propertyName}' value="${fieldValue}" />
 					
 						<c:if test="${field.fieldType eq field.LOOKUP_READONLY}">
 					
Index: impl/src/main/java/org/kuali/rice/kns/service/DataDictionaryService.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/service/DataDictionaryService.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/service/DataDictionaryService.java	(working copy)
@@ -24,6 +24,7 @@
 
 import org.kuali.rice.kns.bo.BusinessObject;
 import org.kuali.rice.kns.bo.Inactivateable;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
 import org.kuali.rice.kns.datadictionary.DataDictionary;
 import org.kuali.rice.kns.datadictionary.InactivationBlockingDefinition;
 import org.kuali.rice.kns.datadictionary.InactivationBlockingMetadata;
@@ -134,7 +135,6 @@
      */
     public String getAttributeSummary(Class businessObjectClass, String attributeName);
 
-
     /**
      * detailed help text for attribute
      */
@@ -255,6 +255,11 @@
      * the Mask object defined for masking the attribute's data value
      */
     public Mask getAttributeDisplayMask(String entryName, String attributeName);
+    
+    /**
+     * the AttributeSecurity object defined for the attribute's data value
+     */
+    public AttributeSecurity getAttributeSecurity(String entryName, String attributeName);
 
     /**
      * short help text for attribute
Index: impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeDefinition.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeDefinition.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/datadictionary/AttributeDefinition.java	(working copy)
@@ -518,4 +518,8 @@
 	public void setAttributeSecurity(AttributeSecurity attributeSecurity) {
 		this.attributeSecurity = attributeSecurity;
 	}
+	
+	 public boolean hasAttributeSecurity() {
+	        return (attributeSecurity != null);
+	    }
 }
\ No newline at end of file
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java	(working copy)
@@ -1,88 +1,97 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.Map;
-
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.Document;
-
-/**
- * The DocumentAuthorizer class associated with a given Document is used to dynamically determine what editing mode and what actions
- * are allowed for a given user on a given document instance.
- * 
- * 
- */
-public interface DocumentAuthorizer {
-    /**
-     * @param document
-     * @param user
-     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
-     *         allowed to take on that document.
-     */
-    public Map getEditMode(Document document, Person user);
-
-    /**
-     * @param document - the document locks are to be established against or by
-     * @param editMode - the editMode returned by the method {@link #getEditMode(Document, Person)}
-     * @param user - the user locks are being established for
-     * @return New map generated by locking logic combined with passed in parameter editMode.  Map contains keys 
-     *         AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently 
-     *         allowed to take on that document.  This may be a modified list of 
-     */
-    public Map establishLocks(Document document, Map editMode, Person user);
-
-    /**
-     * @param document - the document to create the lock against and add the lock to
-     */
-    public void establishWorkflowPessimisticLocking(Document document);
-
-    /**
-     * @param document - document to release locks from
-     */
-    public void releaseWorkflowPessimisticLocking(Document document);
-    
-    /**
-     * @param document
-     * @param user
-     * @return DocumentActionFlags instance indicating which actions are permitted the given user on the given document
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user);
-
-    /**
-     * @param documentTypeName
-     * @param user
-     * @return true if the given user is allowed to initiate documents of the given document type
-     */
-    public void canInitiate(String documentTypeName, Person user);
-    
-    /**
-     * @param documentTypeName
-     * @param user
-     * @returns boolean indicating whether a user can copy a document
-     */
-    public boolean canCopy(String documentTypeName, Person user);
-
-    /**
-     * 
-     * @param attachmentTypeName
-     * @param document
-     * @param user
-     * @return
-     */
-    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user);
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentAuthorizer class associated with a given Document is used to dynamically determine what editing mode and what actions
+ * are allowed for a given user on a given document instance.
+ * 
+ * 
+ */
+public interface DocumentAuthorizer {
+    /**
+     * @param document
+     * @param user
+     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
+     *         allowed to take on that document.
+     */
+    public Map getEditMode(Document document, Person user);
+    
+    /**
+     * 
+     * @param document
+     * @param user
+     * @return user has permission to edit the document or not
+     */
+    public boolean isViewOnly(Document document, Person user);
+
+
+    /**
+     * @param document - the document locks are to be established against or by
+     * @param editMode - the editMode returned by the method {@link #getEditMode(Document, Person)}
+     * @param user - the user locks are being established for
+     * @return New map generated by locking logic combined with passed in parameter editMode.  Map contains keys 
+     *         AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently 
+     *         allowed to take on that document.  This may be a modified list of 
+     */
+    public Map establishLocks(Document document, Map editMode, Person user);
+
+    /**
+     * @param document - the document to create the lock against and add the lock to
+     */
+    public void establishWorkflowPessimisticLocking(Document document);
+
+    /**
+     * @param document - document to release locks from
+     */
+    public void releaseWorkflowPessimisticLocking(Document document);
+    
+    /**
+     * @param document
+     * @param user
+     * @return DocumentActionFlags instance indicating which actions are permitted the given user on the given document
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user);
+
+    /**
+     * @param documentTypeName
+     * @param user
+     * @return true if the given user is allowed to initiate documents of the given document type
+     */
+    public void canInitiate(String documentTypeName, Person user);
+    
+    /**
+     * @param documentTypeName
+     * @param user
+     * @returns boolean indicating whether a user can copy a document
+     */
+    public boolean canCopy(String documentTypeName, Person user);
+
+    /**
+     * 
+     * @param attachmentTypeName
+     * @param document
+     * @param user
+     * @return
+     */
+    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user);
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/authorization/FieldAuthorization.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/authorization/FieldAuthorization.java	(revision 5288)
+++ impl/src/main/java/org/kuali/rice/kns/authorization/FieldAuthorization.java	(working copy)
@@ -1,278 +1,317 @@
-/*
- * Copyright 2006-2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.authorization;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.kns.web.ui.Field;
-
-/**
- * This class represents the authorization restrictions (or lack of) for a given field.
- * 
- * 
- */
-public class FieldAuthorization {
-
-    private String fieldName;
-    private boolean editable;
-    private boolean viewable;
-
-    /**
-     * Constructs a FieldAuthorization.java.
-     */
-    public FieldAuthorization() {
-        editable = true;
-        viewable = true;
-    }
-
-    /**
-     * 
-     * Constructs a FieldAuthorization.java.
-     * 
-     * @param fieldName - name of field to represent
-     * @param canEdit - true if the field is editable in this context, false otherwise
-     * @param canView - true if thie field is viewable in this context, false otherwise
-     * 
-     */
-    public FieldAuthorization(String fieldName, boolean canEdit, boolean canView) {
-        this.fieldName = fieldName;
-        setEditable(canEdit); // using setters here to run impossible combinations check
-        setViewable(canView);
-    }
-
-    /**
-     * 
-     * Constructs a FieldAuthorization.java.
-     * 
-     * @param fieldName - name of the field to represent
-     * @param fieldAuthorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE
-     * 
-     */
-    public FieldAuthorization(String fieldName, String fieldAuthorizationFlag) {
-
-        // if an invalid flag is passed in, the choke on it
-        if (!fieldAuthorizationFlag.equals(Field.EDITABLE) && !fieldAuthorizationFlag.equals(Field.READONLY) && !fieldAuthorizationFlag.equals(Field.HIDDEN)) {
-            throw new IllegalArgumentException("The only allowable values are Field.HIDDEN, Field.READONLY, and Field.EDITABLE");
-        }
-
-        this.fieldName = fieldName;
-
-        if (fieldAuthorizationFlag.equals(Field.EDITABLE)) {
-            this.editable = true;
-            this.viewable = true;
-        }
-
-        if (fieldAuthorizationFlag.equals(Field.READONLY)) {
-            this.editable = false;
-            this.viewable = true;
-        }
-
-        if (fieldAuthorizationFlag.equals(Field.HIDDEN)) {
-            this.editable = false;
-            this.viewable = false;
-        }
-
-    }
-
-    /**
-     * 
-     * This method returns the correct flag from the Kuali Field object, that corresponds to the particular combination of editable
-     * and viewable set on this object.
-     * 
-     * @return Field.HIDDEN, Field.READONLY, or Field.EDITABLE
-     * 
-     */
-    public String getKualiFieldDisplayFlag() {
-
-        if (!editable && !viewable) {
-            return Field.HIDDEN;
-        }
-        if (!editable && viewable) {
-            return Field.READONLY;
-        }
-        else {
-            return Field.EDITABLE;
-        }
-
-    }
-
-    /**
-     * 
-     * This method returns true if the FieldAuthorization is some kind of restriction, and returns false if it is an editable field.
-     * 
-     * @return boolean
-     * 
-     */
-    public boolean isRestricted() {
-        if (!editable || !viewable) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * 
-     * This method returns true if this authorization prohibits Viewing and Editing, resulting in a hidden field.
-     * 
-     * @return boolean
-     * 
-     */
-    public boolean isHidden() {
-        if (!editable && !viewable) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * 
-     * This method returns true if this authorization prohibits Editing but not Viewing, resulting in a ReadOnly field.
-     * 
-     * @return boolean
-     * 
-     */
-    public boolean isReadOnly() {
-        if (!editable && viewable) {
-            return true;
-        }
-        else {
-            return false;
-        }
-    }
-
-    /**
-     * Gets the editable attribute.
-     * 
-     * @return Returns the editable.
-     */
-    public boolean isEditable() {
-        return editable;
-    }
-
-    /**
-     * Sets the editable attribute value.
-     * 
-     * Note that if editable is being set to true, and the internal value of viewable is false, viewable will be flipped to true, to
-     * avoid impossible combinations of flags.
-     * 
-     * @param editable The editable to set.
-     */
-    public void setEditable(boolean editable) {
-        if (editable && !this.viewable) {
-            this.viewable = true;
-        }
-        this.editable = editable;
-    }
-
-    /**
-     * Gets the fieldName attribute.
-     * 
-     * @return Returns the fieldName.
-     */
-    public String getFieldName() {
-        return fieldName;
-    }
-
-    /**
-     * Sets the fieldName attribute value.
-     * 
-     * @param fieldName The fieldName to set.
-     */
-    public void setFieldName(String fieldName) {
-        this.fieldName = fieldName;
-    }
-
-    /**
-     * Gets the viewable attribute.
-     * 
-     * @return Returns the viewable.
-     */
-    public boolean isViewable() {
-        return viewable;
-    }
-
-    /**
-     * Sets the viewable attribute value.
-     * 
-     * Note that if viewable is being set to false, and the internal value of editable is true, then editable will be silently
-     * flipped to false. This is done to avoid impossible combinations of authorization flags.
-     * 
-     * @param viewable The viewable to set.
-     */
-    public void setViewable(boolean viewable) {
-        if (!viewable && this.editable) {
-            this.editable = false;
-        }
-        this.viewable = viewable;
-    }
-
-    /**
-     * @see java.lang.Object#toString()
-     */
-    public String toString() {
-        StringBuffer sb = new StringBuffer();
-        sb.append(this.fieldName);
-        sb.append(" [");
-        if (this.editable) {
-            sb.append("editable");
-        }
-        else {
-            sb.append("not editable");
-        }
-        sb.append(",");
-        if (this.viewable) {
-            sb.append("viewable");
-        }
-        else {
-            sb.append("not viewable");
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-
-    /**
-     * @see java.lang.Object#equals(java.lang.Object)
-     */
-    public boolean equals(Object obj) {
-        boolean equal = false;
-
-        if (obj != null) {
-            if (this.getClass().equals(obj.getClass())) {
-                FieldAuthorization other = (FieldAuthorization) obj;
-
-                if (StringUtils.equals(this.fieldName, other.getFieldName())) {
-                    if (this.editable == other.isEditable() && this.viewable == other.isViewable()) {
-                        equal = true;
-                    }
-                }
-            }
-        }
-
-        return equal;
-    }
-
-    /**
-     * @see java.lang.Object#hashCode()
-     */
-    public int hashCode() {
-        return toString().hashCode();
-    }
-
-
-}
+/*
+ * Copyright 2006-2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.authorization;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kns.web.ui.Field;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+
+/**
+ * This class represents the authorization restrictions (or lack of) for a given field.
+ * 
+ * 
+ */
+public class FieldAuthorization {
+
+    private String fieldName;
+    private boolean editable;
+    private boolean viewable;
+    private boolean masked;
+    private boolean partiallyMasked;
+    private MaskFormatter maskFormatter;
+    /**
+     * Constructs a FieldAuthorization.java.
+     */
+    public FieldAuthorization() {
+        editable = true;
+        viewable = true;
+    }
+
+    /**
+     * 
+     * Constructs a FieldAuthorization.java.
+     * 
+     * @param fieldName - name of field to represent
+     * @param canEdit - true if the field is editable in this context, false otherwise
+     * @param canView - true if thie field is viewable in this context, false otherwise
+     * 
+     */
+    public FieldAuthorization(String fieldName, boolean canEdit, boolean canView) {
+        this.fieldName = fieldName;
+        setEditable(canEdit); // using setters here to run impossible combinations check
+        setViewable(canView);
+    }
+    
+    /**
+     * 
+     * Constructs a FieldAuthorization.java.
+     * 
+     * @param fieldName - name of the field to represent
+     * @param fieldAuthorizationFlag - Field.HIDDEN, Field.READONLY, or Field.EDITABLE
+     */
+    public FieldAuthorization(String fieldName, String fieldAuthorizationFlag) {
+        // if an invalid flag is passed in, the choke on it
+        if (!fieldAuthorizationFlag.equals(Field.EDITABLE) && !fieldAuthorizationFlag.equals(Field.READONLY) 
+        		&& !fieldAuthorizationFlag.equals(Field.HIDDEN) && !fieldAuthorizationFlag.equals(Field.MASKED)
+        		&& !fieldAuthorizationFlag.equals(Field.PARTIALLY_MASKED)) {
+            throw new IllegalArgumentException("The only allowable values are " +
+            		"Field.HIDDEN, Field.READONLY, Field.EDITABLE, Field.MASKED and Field.PARTIALLY_MASKED");
+        }
+
+        this.fieldName = fieldName;
+
+        if (fieldAuthorizationFlag.equals(Field.EDITABLE)) {
+            this.editable = true;
+            this.viewable = true;
+        } else if (fieldAuthorizationFlag.equals(Field.READONLY)) {
+            this.editable = false;
+            this.viewable = true;
+        } else if (fieldAuthorizationFlag.equals(Field.HIDDEN)) {
+            this.editable = false;
+            this.viewable = false;
+        } else if(fieldAuthorizationFlag.equals(Field.MASKED)){
+			this.masked = true;
+			this.viewable = true;
+			this.editable = false;
+		} else if(fieldAuthorizationFlag.equals(Field.PARTIALLY_MASKED)){
+			this.partiallyMasked = true;
+			this.viewable = true;
+			this.editable = false;
+		}
+    }
+
+    /**
+     * 
+     * This method returns the correct flag from the Kuali Field object, that corresponds to the particular combination of editable
+     * and viewable set on this object.
+     * 
+     * @return Field.HIDDEN, Field.READONLY, or Field.EDITABLE
+     * 
+     */
+    public String getKualiFieldDisplayFlag() {
+
+        if (!editable && !viewable) {
+            return Field.HIDDEN;
+        }
+        if (!editable && viewable) {
+            return Field.READONLY;
+        }
+        else {
+            return Field.EDITABLE;
+        }
+
+    }
+
+    /**
+     * 
+     * This method returns true if the FieldAuthorization is some kind of restriction, and returns false if it is an editable field.
+     * 
+     * @return boolean
+     * 
+     */
+    public boolean isRestricted() {
+        if (!editable || !viewable) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * 
+     * This method returns true if this authorization prohibits Viewing and Editing, resulting in a hidden field.
+     * 
+     * @return boolean
+     * 
+     */
+    public boolean isHidden() {
+        if (!editable && !viewable) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * 
+     * This method returns true if this authorization prohibits Editing but not Viewing, resulting in a ReadOnly field.
+     * 
+     * @return boolean
+     * 
+     */
+    public boolean isReadOnly() {
+        if (!editable && viewable) {
+            return true;
+        }
+        else {
+            return false;
+        }
+    }
+
+    /**
+     * Gets the editable attribute.
+     * 
+     * @return Returns the editable.
+     */
+    public boolean isEditable() {
+        return editable;
+    }
+
+    /**
+     * Sets the editable attribute value.
+     * 
+     * Note that if editable is being set to true, and the internal value of viewable is false, viewable will be flipped to true, to
+     * avoid impossible combinations of flags.
+     * 
+     * @param editable The editable to set.
+     */
+    public void setEditable(boolean editable) {
+        if (editable && !this.viewable) {
+            this.viewable = true;
+        }
+        this.editable = editable;
+    }
+
+    /**
+     * Gets the fieldName attribute.
+     * 
+     * @return Returns the fieldName.
+     */
+    public String getFieldName() {
+        return fieldName;
+    }
+
+    /**
+     * Sets the fieldName attribute value.
+     * 
+     * @param fieldName The fieldName to set.
+     */
+    public void setFieldName(String fieldName) {
+        this.fieldName = fieldName;
+    }
+
+    /**
+     * Gets the viewable attribute.
+     * 
+     * @return Returns the viewable.
+     */
+    public boolean isViewable() {
+        return viewable;
+    }
+
+    /**
+     * Sets the viewable attribute value.
+     * 
+     * Note that if viewable is being set to false, and the internal value of editable is true, then editable will be silently
+     * flipped to false. This is done to avoid impossible combinations of authorization flags.
+     * 
+     * @param viewable The viewable to set.
+     */
+    public void setViewable(boolean viewable) {
+        if (!viewable && this.editable) {
+            this.editable = false;
+        }
+        this.viewable = viewable;
+    }
+
+    /**
+     * @see java.lang.Object#toString()
+     */
+    public String toString() {
+        StringBuffer sb = new StringBuffer();
+        sb.append(this.fieldName);
+        sb.append(" [");
+        if (this.editable) {
+            sb.append("editable");
+        }
+        else {
+            sb.append("not editable");
+        }
+        sb.append(",");
+        if (this.viewable) {
+            sb.append("viewable");
+        }
+        else {
+            sb.append("not viewable");
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
+    /**
+     * @see java.lang.Object#equals(java.lang.Object)
+     */
+    public boolean equals(Object obj) {
+        boolean equal = false;
+
+        if (obj != null) {
+            if (this.getClass().equals(obj.getClass())) {
+                FieldAuthorization other = (FieldAuthorization) obj;
+
+                if (StringUtils.equals(this.fieldName, other.getFieldName())) {
+                    if (this.editable == other.isEditable() && this.viewable == other.isViewable()) {
+                        equal = true;
+                    }
+                }
+            }
+        }
+
+        return equal;
+    }
+
+    /**
+     * @see java.lang.Object#hashCode()
+     */
+    public int hashCode() {
+        return toString().hashCode();
+    }
+
+	/**
+	 * @return the masked
+	 */
+	public boolean isMasked() {
+		return this.masked;
+	}
+
+	/**
+	 * @return the partiallyMasked
+	 */
+	public boolean isPartiallyMasked() {
+		return this.partiallyMasked;
+	}
+
+	public boolean shouldBeEncrypted(){
+		return isMasked() || isPartiallyMasked();
+	}
+
+	/**
+	 * @return the maskFormatter
+	 */
+	public MaskFormatter getMaskFormatter() {
+		return this.maskFormatter;
+	}
+
+	/**
+	 * @param maskFormatter the maskFormatter to set
+	 */
+	public void setMaskFormatter(MaskFormatter maskFormatter) {
+		this.maskFormatter = maskFormatter;
+	}
+	
+	
+}
