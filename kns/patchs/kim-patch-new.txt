### Eclipse Workspace Patch 1.0
#P rice
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(revision 5571)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(working copy)
@@ -1,284 +1,274 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.kim.bo.FieldAttributeSecurity;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kim.bo.types.dto.AttributeSet;
-import org.kuali.rice.kim.util.DocumentAttributeSecurityUtils;
-import org.kuali.rice.kim.util.KimConstants;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.datadictionary.AttributeSecurity;
-import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
-import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
-import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-
-public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
-
- 	private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
-    /**
-     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
-        
-    	MaintenanceDocumentAuthorizations auths = new MaintenanceDocumentAuthorizations();
-    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
-    	
-    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
-    	Map<String, FieldAttributeSecurity> restrictionFields = DocumentAttributeSecurityUtils.getRestrictionMaintainableFields(objectEntry);
-    	
-    	Set keys = restrictionFields.keySet();    
-    	Iterator keyIter = keys.iterator();
-        while (keyIter.hasNext()) { 
-           String fullFieldName = (String) keyIter.next(); 
-           FieldAttributeSecurity fieldAttributeSecurity = (FieldAttributeSecurity) restrictionFields.get(fullFieldName);
-           String fieldName = fieldAttributeSecurity.getAttributeName();
-           
-           //TODO:Should use ParameterService.getDetailType to get the componentName
-           String componentName = fieldAttributeSecurity.getBusinessObjectClass().getSimpleName();     
-           String nameSpaceCode = "KR-NS";
-           
-           AttributeSecurity maintainableFieldAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getMaintainableFieldAttributeSecurity();
-           AttributeSecurity  businessObjectAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getBusinessObjectAttributeSecurity();
-           
-           AttributeSet permissionDetails = new AttributeSet();
-    	   permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, fieldName);
-    	  
-    	   
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isReadOnly()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
-    			   auths.addReadonlyAuthField(fullFieldName);
-    		   }
-    	   }
-    	   
-    	   if(maintainableFieldAttributeSecurity != null && maintainableFieldAttributeSecurity.isReadOnly()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
-    			   auths.addReadonlyAuthField(fullFieldName);
-    		   }
-    	   }
-    	   
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isPartialMask()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
-    			   MaskFormatter partialMaskFormatter = businessObjectAttributeSecurity.getPartialMaskFormatter();
-    			   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
-    		   }
-    	   }
-    	   
-    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isPartialMask()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
-				   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
-				   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
-			   }
-		   }
-    	   
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isMask()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
-    		       MaskFormatter maskFormatter = businessObjectAttributeSecurity.getMaskFormatter();
-    			   auths.addMaskedAuthField(fullFieldName, maskFormatter);
-    		   }
-    	   }
-    	   
-    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isMask()){  
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
-				   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
-				   auths.addMaskedAuthField(fullFieldName, maskFormatter);
-			   }
-		   }
-    	
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isHide()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
-    			   auths.addHiddenAuthField(fullFieldName);	  
-    		   }
-    	   }   
-
-    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isHide()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
-				   auths.addHiddenAuthField(fullFieldName);	  
-			   }
-		   }
-  
-        }    	
-    	return auths; 
-    }
-
-
-    /**
-     * 
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-
-        // run the super, let the common flags be set
-        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
-
-        // run the fieldAuthorizations
-        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
-        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
-
-        // if there are any field restrictions for this user, then we need to turn off the
-        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
-        // they certainly cant blanket approve it.
-        if (docAuths.hasAnyFieldRestrictions()) {
-            docActionFlags.setCanBlanketApprove(false);
-        }
-
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-
-        // if a user can't initiate a document of this type then they can't copy one, either
-        if (!canCopy(workflowDocument.getDocumentType(), user)) {
-            docActionFlags.setCanCopy(false);
-        }
-        else {
-            docActionFlags.setCanCopy(document.getAllowsCopy() && (!workflowDocument.stateIsInitiated() && !workflowDocument.stateIsEnroute() && !workflowDocument.stateIsException() && !workflowDocument.stateIsSaved()));
-        }
-
-        return docActionFlags;
-    }
-
-    /**
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public Map getEditMode(Document document, Person user) {
-
-        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
-        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
-            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
-        }
-
-        Map editMode = new HashMap();
-        
-        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
-        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
-
-        // default to view-only, as a safety precaution
-        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-
-        // if the document is cancelled, then its view only
-        if (workflowDocument.stateIsCanceled()) {
-            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-        }
-
-        // if the document is being edited, then its full entry, or if the current user is
-        // the system supervisor
-        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-            if (workflowDocument.userIsInitiator(user)) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
-                
-                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
-                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
-                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
-                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
-                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
-                }
-            }
-        }
-
-        // if the document is in routing, then we have some special rules
-        else if (workflowDocument.stateIsEnroute()) {
-
-            // the person who has the approval request in their Actiong List
-            // should be able to modify the document
-            if (workflowDocument.isApprovalRequested()) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
-            }
-        }
-
-        // save the editmode
-        editMode.put(editModeKey, "TRUE");
-        return editMode;
-    }
-
-    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
-        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
-        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
-        
-        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
-            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
-                if (itemDefinition instanceof MaintainableFieldDefinition) {
-                    String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
-                    if (StringUtils.isNotBlank(displayEditMode)) {
-                        editModes.put(displayEditMode, "TRUE");
-                    }
-                }
-                // TODO: what about MaintainableCollectionDefinition?
-            }
-        }
-    }
-    
-    /**
-     * This method returns whether this document is creating a new entry in the maintenible/underlying table
-     * 
-     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
-     * useful in determining which fields are encrypted
-     * 
-     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
-     * there is uncertainity how documents with this action will actually be implemented
-     * 
-     * @param maintDoc
-     * @param user
-     * @return
-     */
-    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
-        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
-        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
-        
-        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
-        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
-        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
-    }
-    
-    	
-	/**
-	 * @return the maintenanceDocumentDictionaryService
-	 */
-	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
-		
-		if (maintenanceDocumentDictionaryService == null ) {
-			maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-		}
-		return maintenanceDocumentDictionaryService;
-	}
-
-    
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.bo.FieldAttributeSecurity;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.DocumentAttributeSecurityUtils;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
+import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
+
+ 	private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
+    /**
+     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
+        
+    	MaintenanceDocumentAuthorizations auths = new MaintenanceDocumentAuthorizations();
+    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+    	
+    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
+    	Map<String, FieldAttributeSecurity> restrictionFields = DocumentAttributeSecurityUtils.getRestrictionMaintainableFields(objectEntry);
+    	
+    	Set keys = restrictionFields.keySet();    
+    	Iterator keyIter = keys.iterator();
+        while (keyIter.hasNext()) { 
+           String fullFieldName = (String) keyIter.next(); 
+           FieldAttributeSecurity fieldAttributeSecurity = (FieldAttributeSecurity) restrictionFields.get(fullFieldName);
+           String fieldName = fieldAttributeSecurity.getAttributeName();
+           
+           //TODO:Should use ParameterService.getDetailType to get the componentName
+           String componentName = fieldAttributeSecurity.getBusinessObjectClass().getSimpleName();     
+           String nameSpaceCode = "KR-NS";
+           
+           AttributeSecurity maintainableFieldAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getMaintainableFieldAttributeSecurity();
+           AttributeSecurity  businessObjectAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getBusinessObjectAttributeSecurity();
+           
+           AttributeSet permissionDetails = new AttributeSet();
+    	   permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, fieldName);
+    	  
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null && maintainableFieldAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+    			   MaskFormatter partialMaskFormatter = businessObjectAttributeSecurity.getPartialMaskFormatter();
+    			   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
+				   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+			   }
+		   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+    		       MaskFormatter maskFormatter = businessObjectAttributeSecurity.getMaskFormatter();
+    			   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isMask()){  
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
+				   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+			   }
+		   }
+    	
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+    			   auths.addHiddenAuthField(fullFieldName);	  
+    		   }
+    	   }   
+
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+				   auths.addHiddenAuthField(fullFieldName);	  
+			   }
+		   }
+  
+        }    	
+    	return auths; 
+    }
+
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+
+            	// run the super, let the common flags be set
+        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
+
+        // run the fieldAuthorizations
+        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
+        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
+
+        // if there are any field restrictions for this user, then we need to turn off the
+        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
+        // they certainly cant blanket approve it.
+        if (docAuths.hasAnyFieldRestrictions()) {
+            docActionFlags.setCanBlanketApprove(false);
+        }
+
+        return docActionFlags;
+    }
+
+    /**
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public Map getEditMode(Document document, Person user) {
+
+        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
+        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
+            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
+        }
+
+        Map editMode = new HashMap();
+        
+        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
+        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
+
+        // default to view-only, as a safety precaution
+        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+
+        // if the document is cancelled, then its view only
+        if (workflowDocument.stateIsCanceled()) {
+            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+        }
+
+        // if the document is being edited, then its full entry, or if the current user is
+        // the system supervisor
+        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+            if (workflowDocument.userIsInitiator(user)) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
+                
+                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
+                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
+                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
+                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
+                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
+                }
+            }
+        }
+
+        // if the document is in routing, then we have some special rules
+        else if (workflowDocument.stateIsEnroute()) {
+
+            // the person who has the approval request in their Actiong List
+            // should be able to modify the document
+            if (workflowDocument.isApprovalRequested()) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
+            }
+        }
+
+        // save the editmode
+        editMode.put(editModeKey, "TRUE");
+        return editMode;
+    }
+
+    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
+        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
+        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
+        
+        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
+            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
+                if (itemDefinition instanceof MaintainableFieldDefinition) {
+                    String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
+                    if (StringUtils.isNotBlank(displayEditMode)) {
+                        editModes.put(displayEditMode, "TRUE");
+                    }
+                }
+                // TODO: what about MaintainableCollectionDefinition?
+            }
+        }
+    }
+    
+    /**
+     * This method returns whether this document is creating a new entry in the maintenible/underlying table
+     * 
+     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
+     * useful in determining which fields are encrypted
+     * 
+     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
+     * there is uncertainity how documents with this action will actually be implemented
+     * 
+     * @param maintDoc
+     * @param user
+     * @return
+     */
+    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
+        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
+        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
+        
+        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
+        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
+        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
+    }
+    
+    	
+	/**
+	 * @return the maintenanceDocumentDictionaryService
+	 */
+	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+		
+		if (maintenanceDocumentDictionaryService == null ) {
+			maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+		}
+		return maintenanceDocumentDictionaryService;
+	}
+
+    
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationController.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationController.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationController.java	(revision 0)
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.List;
+
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentPresentationController class is used for non-user related lock down 
+ * 
+ * 
+ */
+
+public interface MaintenanceDocumentPresentationController extends DocumentPresentationController {
+	
+	/**
+	 * 
+	 * 
+	 * @param document
+	 * @return the list of uncondionallyReadOnly fields
+	 */
+	public List getReadOnlyFields(Document document);
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationControllerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationControllerBase.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationControllerBase.java	(revision 0)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kns.datadictionary.MaintainableCollectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+
+/**
+ * Base class for all MaintenanceDocumentPresentationControllers.
+ */
+public class MaintenanceDocumentPresentationControllerBase extends DocumentPresentationControllerBase implements MaintenanceDocumentPresentationController {
+    private static Log LOG = LogFactory.getLog(MaintenanceDocumentPresentationControllerBase.class);
+
+    private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
+    
+	/**
+	 * 
+	 * @param document
+	 * @return
+	 */
+	public List getReadOnlyFields(Document document){
+		List<MaintainableFieldDefinition> readOnlyFields = new ArrayList();
+		
+		String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+
+    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
+    	
+    	List<MaintainableSectionDefinition> maintainableSectionDefinitions = objectEntry.getMaintainableSections();
+		for (MaintainableSectionDefinition maintainableSectionDefinition : maintainableSectionDefinitions) {
+			List<MaintainableItemDefinition> maintainableItems = maintainableSectionDefinition.getMaintainableItems();
+			
+			readOnlyFields.addAll(getReadOnlyFieldList(readOnlyFields,maintainableItems));
+			
+		}
+		return readOnlyFields;
+	}
+	
+	private static List<MaintainableFieldDefinition> getReadOnlyFieldList(
+			List<MaintainableFieldDefinition> returnList, List items) {
+		
+		for (Object item: items) {
+			if (item instanceof MaintainableFieldDefinition) {
+				MaintainableFieldDefinition maintainableFieldDefinition = (MaintainableFieldDefinition) item;
+				
+				if(maintainableFieldDefinition.isUnconditionallyReadOnly()){
+					returnList.add(maintainableFieldDefinition);
+				}
+			} else if (item instanceof MaintainableCollectionDefinition) {
+				MaintainableCollectionDefinition maintainableCollectionDefinition = (MaintainableCollectionDefinition) item;
+				getReadOnlyFieldList(
+						returnList,
+						maintainableCollectionDefinition.getMaintainableCollections());
+				getReadOnlyFieldList(
+						returnList,
+						maintainableCollectionDefinition.getMaintainableFields());
+			}
+		}
+		return returnList;
+	}
+
+	/**
+	 * @return the maintenanceDocumentDictionaryService
+	 */
+	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+		return maintenanceDocumentDictionaryService;
+	}
+	
+	
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(revision 5507)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(working copy)
@@ -1,40 +1,44 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-
-/**
- * Extension to DocumentAuthorizer for Maintenance Document specific methods
- * 
- * 
- */
-public interface MaintenanceDocumentAuthorizer extends DocumentAuthorizer {
-
-    /**
-     * 
-     * This method returns the set of authorization restrictions (if any) that apply to this object in this context.
-     * 
-     * @param document
-     * @param user
-     * @return MaintenanceDocumentAuthorizations
-     * 
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
-
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+
+/**
+ * Extension to DocumentAuthorizer for Maintenance Document specific methods
+ * 
+ * 
+ */
+public interface MaintenanceDocumentAuthorizer extends DocumentAuthorizer {
+
+    /**
+     * 
+     * This method returns the set of authorization restrictions (if any) that apply to this object in this context.
+     * 
+     * @param document
+     * @param user
+     * @return MaintenanceDocumentAuthorizations
+     * 
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
+    
+   
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationController.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationController.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationController.java	(revision 0)
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentPresentationController class is used for non-user related lock down 
+ * 
+ * 
+ */
+public interface TransactionalDocumentPresentationController extends DocumentPresentationController {
+	 /**
+     * @param document
+     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
+     *         allowed to take on that document.
+     */
+    public Map getEditMode(Document document);
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationController.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationController.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationController.java	(revision 0)
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentPresentationController class is used for non-user related lock down 
+ * 
+ * 
+ */
+public interface DocumentPresentationController {
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be edited 
+     */
+    public boolean canEdit(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be annotated
+     */
+    public boolean canAnnotate(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be reloaded
+     */
+    public boolean canReload(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be closed
+     */
+    public boolean canClose(Document document);
+    
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be saved
+     */
+    public boolean canSave(Document document);
+    
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be routed
+     */
+    public boolean canRoute(Document document);
+    
+  
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be canceled
+     */
+    public boolean canCancel(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be copied
+     */
+    public boolean canCopy(Document document);
+    
+    
+    /**
+     * @param document
+     * @return boolean indicating whether can perform route report
+     */
+    public boolean canPerformRouteReport(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether can ad hoc route
+     */
+    public boolean canAdHocRoute(Document document);
+    
+    
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationControllerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationControllerBase.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationControllerBase.java	(revision 0)
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * Base class for all TransactionalDocumentPresentationControllers.
+ */
+public class TransactionalDocumentPresentationControllerBase extends DocumentPresentationControllerBase implements TransactionalDocumentPresentationController {
+    private static Log LOG = LogFactory.getLog(TransactionalDocumentPresentationControllerBase.class);
+
+    public Map getEditMode(Document document){
+    	Map editModeMap = new HashMap();
+    	return editModeMap;
+    }
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationControllerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationControllerBase.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationControllerBase.java	(revision 0)
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.KualiConfigurationService;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+
+public class DocumentPresentationControllerBase implements DocumentPresentationController {
+    private static Log LOG = LogFactory.getLog(DocumentPresentationControllerBase.class);
+    
+  
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#getEdit(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canEdit(Document document){
+    	boolean canEdit = false;
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+        if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved() || workflowDocument.stateIsEnroute() || workflowDocument.stateIsException()) {
+        	canEdit = true; 
+        }
+        
+        return canEdit;
+    }
+    
+    
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canAnnotate(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canAnnotate(Document document){
+    	return canEdit(document);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canReload(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canReload(Document document){
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	return (canEdit(document) && !workflowDocument.stateIsInitiated()) ;
+             
+    }
+    
+    
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canClose(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canClose(Document document){
+    	return true;
+    }
+    
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canSave(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canSave(Document document){
+    	return canEdit(document);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canRoute(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canRoute(Document document){
+    	boolean canRoute = false;
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()){
+    		 canRoute = true;
+    	}
+    	return canRoute;
+    }
+        
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canCancel(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canCancel(Document document){
+    	return canEdit(document);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canCopy(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canCopy(Document document){
+    	 boolean canCopy = false;
+    	 if(document.getAllowsCopy()){
+    		 canCopy = true;
+    	 }
+    	 return canCopy;
+    }
+    
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canPerformRouteReport(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canPerformRouteReport(Document document){
+    	KualiConfigurationService kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+        return kualiConfigurationService.getIndicatorParameter( KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.SystemGroupParameterNames.DEFAULT_CAN_PERFORM_ROUTE_REPORT_IND);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canAdHocRoute(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canAdHocRoute(Document document){
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	return (canEdit(document)&& !workflowDocument.stateIsException());
+    }
+    
+        
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizer.java	(revision 5490)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizer.java	(working copy)
@@ -1,23 +1,43 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-
-/**
- * Extension to DocumentAuthorizer interface which adds transactional-document-specific methods.
- */
-public interface TransactionalDocumentAuthorizer extends DocumentAuthorizer {
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+
+/**
+ * Extension to DocumentAuthorizer interface which adds transactional-document-specific methods.
+ */
+public interface TransactionalDocumentAuthorizer extends DocumentAuthorizer {
+	
+	/**
+	 * 
+	 * @param editMode
+	 * @param user
+     * @return boolean indicating whether the user has permission to use this edit mode
+     */
+
+	public boolean canUseEditMode(String editMode, Person user); 
+
+	 /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to correct errors for the document
+     */
+    public boolean canErrorCorrect(Document document, Person user); 
+    
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java	(revision 5490)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java	(working copy)
@@ -1,54 +1,107 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.TransactionalDocument;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-
-/**
- * Base class for all TransactionalDocumentAuthorizers.
- */
-public class TransactionalDocumentAuthorizerBase extends DocumentAuthorizerBase implements TransactionalDocumentAuthorizer {
-    private static Log LOG = LogFactory.getLog(TransactionalDocumentAuthorizerBase.class);
-
-    /**
-     * Adds settings for transactional-document-specific flags.
-     * 
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#getDocumentActionFlags(Document, Person)
-     */
-    @Override
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-        LOG.debug("calling TransactionalDocumentAuthorizerBase.getDocumentActionFlags for document '" + document.getDocumentNumber() + "'. user '" + user.getPrincipalName() + "'");
-        TransactionalDocumentActionFlags flags = new TransactionalDocumentActionFlags(super.getDocumentActionFlags(document, user));
-
-        TransactionalDocument transactionalDocument = (TransactionalDocument) document;
-        KualiWorkflowDocument workflowDocument = transactionalDocument.getDocumentHeader().getWorkflowDocument();
-
-        if (!canCopy(workflowDocument.getDocumentType(), user)) {
-            flags.setCanCopy(false);
-            flags.setCanErrorCorrect(false);
-        }
-        else {
-            flags.setCanCopy(transactionalDocument.getAllowsCopy() && !workflowDocument.stateIsInitiated());
-            flags.setCanErrorCorrect(transactionalDocument.getAllowsErrorCorrection() && (workflowDocument.stateIsApproved() || workflowDocument.stateIsProcessed() || workflowDocument.stateIsFinal()));
-        }
-        return flags;
-    }
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kew.util.KEWConstants;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.TransactionalDocument;
+import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+/**
+ * Base class for all TransactionalDocumentAuthorizers.
+ */
+public class TransactionalDocumentAuthorizerBase extends DocumentAuthorizerBase implements TransactionalDocumentAuthorizer {
+    private static Log LOG = LogFactory.getLog(TransactionalDocumentAuthorizerBase.class);
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizerBase#getDocumentActionFlags(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+        TransactionalDocumentActionFlags flags = new TransactionalDocumentActionFlags(super.getDocumentActionFlags(document, user));
+
+        flags.setCanErrorCorrect(canErrorCorrect(document, user));
+      
+        return flags;
+
+    }
+    
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public void canInitiate(String documentTypeName, Person user) {
+    	
+    	String nameSpaceCode = "KR-SYS";
+    	
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	
+        if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null)){
+        	
+        	//TODO:
+        	// build authorized workgroup list for error message
+            Set authorizedWorkgroups = getAuthorizationService().getAuthorizedWorkgroups("initiate", documentTypeName);
+            String workgroupList = StringUtils.join(authorizedWorkgroups.toArray(), ",");
+            throw new DocumentInitiationAuthorizationException(new String[] {workgroupList,documentTypeName});
+        }
+    }
+    
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canAnnotate(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+     */
+    public boolean canErrorCorrect(Document document, Person user){
+    	 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+    	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_ERROR_CORRECT_DOCUMENT, permissionDetails, qualifications);
+	        	
+    }
+    
+    public boolean canUseEditMode(String editMode, Person user){
+    	String nameSpaceCode = "KR-NS"; 
+    	AttributeSet permissionDetails = new AttributeSet();
+	    permissionDetails.put(KimConstants.KIM_ATTRIB_EDIT_MODE, KEWConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ);
+	    
+	    return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_USE_TRANSACTIONAL_DOCUMENT, permissionDetails, null);
+	        	
+    }
+    
+
+}
Index: impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java	(revision 5490)
+++ impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java	(working copy)
@@ -1,528 +1,535 @@
-/*
- * Copyright 2005-2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.web.struts.form;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.struts.upload.FormFile;
-import org.kuali.rice.core.config.ConfigurationException;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.bo.BusinessObject;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.document.MaintenanceDocumentBase;
-import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
-import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
-import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
-import org.kuali.rice.kns.exception.UnknownDocumentTypeException;
-import org.kuali.rice.kns.maintenance.Maintainable;
-import org.kuali.rice.kns.service.DocumentAuthorizationService;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
-import org.kuali.rice.kns.util.FieldUtils;
-import org.kuali.rice.kns.util.GlobalVariables;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.util.ObjectUtils;
-import org.kuali.rice.kns.util.RiceKeyConstants;
-import org.kuali.rice.kns.web.format.FormatException;
-import org.kuali.rice.kns.web.format.Formatter;
-
-
-/**
- * This class is the base action form for all maintenance documents.
- * 
- * 
- */
-public class KualiMaintenanceForm extends KualiDocumentFormBase {
-    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KualiMaintenanceForm.class);
-
-    private static final long serialVersionUID = 1L;
-
-    private String businessObjectClassName;
-    private String description;
-    private boolean readOnly;
-    private Map oldMaintainableValues;
-    private Map newMaintainableValues;
-    private String maintenanceAction;
-    
-    /**
-     * Used to indicate which result set we're using when refreshing/returning from a multi-value lookup
-     */
-    private String lookupResultsSequenceNumber;
-    /**
-     * The type of result returned by the multi-value lookup
-     * 
-     * TODO: to be persisted in the lookup results service instead?
-     */
-    private String lookupResultsBOClassName;
-    
-    /**
-     * The name of the collection looked up (by a multiple value lookup)
-     */
-    private String lookedUpCollectionName;
-    
-    private MaintenanceDocumentAuthorizations authorizations;
-    
-    /**
-     * Override the default method to add the if statement which can't be called until after parameters from a multipart request
-     * have been made accessible, but which must be called before the parameter values are used to instantiate and populate business
-     * objects.
-     * 
-     * @param requestParameters
-     */
-    @Override
-    public void postprocessRequestParameters(Map requestParameters) {
-        super.postprocessRequestParameters(requestParameters);
-
-        String docTypeName = null;
-        String[] docTypeNames = (String[]) requestParameters.get(KNSConstants.DOCUMENT_TYPE_NAME);
-        if ((docTypeNames != null) && (docTypeNames.length > 0)) {
-            docTypeName = docTypeNames[0];
-        }
-
-        if (StringUtils.isNotBlank(docTypeName)) {          
-        	if(this.getDocument() == null){
-            setDocTypeName(docTypeName);
-            Class documentClass = KNSServiceLocator.getDataDictionaryService().getDocumentClassByTypeName(docTypeName);
-            if (documentClass == null) {
-                throw new UnknownDocumentTypeException("unable to get class for unknown documentTypeName '" + docTypeName + "'");
-            }
-            if (!MaintenanceDocumentBase.class.isAssignableFrom(documentClass)) {
-                throw new ConfigurationException("Document class '" + documentClass + "' is not assignable to '" + MaintenanceDocumentBase.class + "'");
-            }
-            Document document = null;
-            try {
-                Class[] defaultConstructor = new Class[]{String.class};
-                Constructor cons = documentClass.getConstructor(defaultConstructor);
-                if (ObjectUtils.isNull(cons)) {
-                    throw new ConfigurationException("Could not find constructor with document type name parameter needed for Maintenance Document Base class");
-                }
-                document = (Document) cons.newInstance(docTypeName);
-            } catch (SecurityException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (NoSuchMethodException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document: No constructor with String parameter found", e);
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (InstantiationException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (IllegalArgumentException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            }
-            if (document == null) {
-                throw new RuntimeException("Unable to instantiate document with type name '" + docTypeName + "' and document class '" + documentClass + "'");
-            }
-            setDocument(document);
-          } 
-       }
-        
-        MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
-        
-        //Handling the Multi-Part Attachment
-        for ( Object obj : requestParameters.entrySet() ) {
-            String parameter = (String)((Map.Entry)obj).getKey(); 
-            if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-                String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-                Object propertyValue = requestParameters.get(parameter);
-                
-                if(propertyValue != null && propertyValue instanceof FormFile) {
-                    if(StringUtils.isNotEmpty(((FormFile)propertyValue).getFileName())) {
-                        maintenanceDocument.setFileAttachment((FormFile) propertyValue);
-                    }
-                    maintenanceDocument.setAttachmentPropertyName(propertyName);
-                }
-            }
-        }
-    }
-
-    /**
-     * Hook into populate so we can set the maintenance documents and feed the field values to its maintainables.
-     */
-    @Override
-    public void populate(HttpServletRequest request) {
-        super.populate(request);
-
-
-        // document type name is null on start, otherwise should be here
-        if (StringUtils.isNotBlank(getDocTypeName())) {
-            Map localOldMaintainableValues = new HashMap();
-            Map localNewMaintainableValues = new HashMap();
-            Map<String,String> localNewCollectionValues = new HashMap<String,String>();
-            for (Enumeration i = request.getParameterNames(); i.hasMoreElements();) {
-                String parameter = (String) i.nextElement();
-                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
-                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
-                    localOldMaintainableValues.put(propertyName, request.getParameter(parameter));
-                }
-                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-                    localNewMaintainableValues.put(propertyName, request.getParameter(parameter));
-                }
-            }
-            
-            // now, get all add lines and store them to a separate map
-            // for use in a separate call to the maintainable
-            for ( Object obj : localNewMaintainableValues.entrySet() ) {
-                String key = (String)((Map.Entry)obj).getKey(); 
-                if ( key.startsWith( KNSConstants.MAINTENANCE_ADD_PREFIX ) ) {
-                    localNewCollectionValues.put( key.substring( KNSConstants.MAINTENANCE_ADD_PREFIX.length() ),
-                            (String)((Map.Entry)obj).getValue() );
-                }
-            }
-            if ( LOG.isDebugEnabled() ) {
-                LOG.debug( "checked for add line parameters - got: " + localNewCollectionValues );
-            }
-            
-            this.newMaintainableValues = localNewMaintainableValues;
-            this.oldMaintainableValues = localOldMaintainableValues;
-
-            MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
-
-            GlobalVariables.getErrorMap().addToErrorPath("document.oldMaintainableObject");
-            maintenanceDocument.getOldMaintainableObject().populateBusinessObject(localOldMaintainableValues, maintenanceDocument);
-            GlobalVariables.getErrorMap().removeFromErrorPath("document.oldMaintainableObject");
-
-            GlobalVariables.getErrorMap().addToErrorPath("document.newMaintainableObject");
-            // update the main object
-            Map cachedValues = 
-            	maintenanceDocument.getNewMaintainableObject().populateBusinessObject(localNewMaintainableValues, maintenanceDocument);
-            
-            if(maintenanceDocument.getFileAttachment() != null) {
-                populateAttachmentPropertyForBO(maintenanceDocument);
-            }
-            
-            // update add lines
-            localNewCollectionValues = org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().resolvePrincipalNamesToPrincipalIds((BusinessObject)maintenanceDocument.getNewMaintainableObject().getBusinessObject(), localNewCollectionValues);
-            cachedValues.putAll( maintenanceDocument.getNewMaintainableObject().populateNewCollectionLines( localNewCollectionValues ) );
-            GlobalVariables.getErrorMap().removeFromErrorPath("document.newMaintainableObject");
-
-            if (cachedValues.size() > 0) {
-                GlobalVariables.getErrorMap().putError(KNSConstants.DOCUMENT_ERRORS, RiceKeyConstants.ERROR_DOCUMENT_MAINTENANCE_FORMATTING_ERROR);
-                for (Iterator iter = cachedValues.keySet().iterator(); iter.hasNext();) {
-                    String propertyName = (String) iter.next();
-                    String value = (String) cachedValues.get(propertyName);
-                    cacheUnconvertedValue(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE + propertyName, value);
-                }
-            }
-        }
-    }
-
-    private void populateAttachmentPropertyForBO(MaintenanceDocumentBase maintenanceDocument) {
-        try {
-            Class type = ObjectUtils.easyGetPropertyType(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName());
-            ObjectUtils.setObjectProperty(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName(), type, maintenanceDocument.getFileAttachment());
-        } catch (FormatException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (IllegalAccessException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (InvocationTargetException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        }
-    }
-    
-    /**
-     * Merges rows of old and new for each section (tab) of the ui. Also, renames fields to prevent naming conflicts and does
-     * setting of read only fields.
-     * 
-     * @return Returns the maintenanceSections.
-     */
-    public List getSections() {
-        if (getDocument() == null) {
-            throw new RuntimeException("Document not set in maintenance form.");
-        }
-        if (((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject() == null) {
-            throw new RuntimeException("New maintainable not set in document.");
-        }
-        if ((KNSConstants.MAINTENANCE_EDIT_ACTION.equals(this.getMaintenanceAction()) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(this.getMaintenanceAction())) && ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject() == null) {
-            throw new RuntimeException("Old maintainable not set in document.");
-        }
-
-        // if the authorization stuff hasnt been applied yet, then apply it
-        if (authorizations == null) {
-            applyAuthorizations();
-        }
-
-        // get business object being maintained and its keys
-        List keyFieldNames = KNSServiceLocator.getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject().getBusinessObject().getClass());
-
-        // sections for maintenance document
-        Maintainable oldMaintainable = ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject();
-        oldMaintainable.setMaintenanceAction(getMaintenanceAction());
-        List oldMaintSections = oldMaintainable.getSections(null);
-        
-        Maintainable newMaintainable = ((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject();
-        newMaintainable.setMaintenanceAction(getMaintenanceAction());
-        List newMaintSections = newMaintainable.getSections(oldMaintainable);
-
-        // mesh sections for proper jsp display
-        List meshedSections = FieldUtils.meshSections(oldMaintSections, newMaintSections, keyFieldNames, getMaintenanceAction(), isReadOnly(), authorizations);
-
-        return meshedSections;
-    }
-
-    protected void applyAuthorizations() {
-        Document document = getDocument();
-        DocumentAuthorizationService docAuthService = KNSServiceLocator.getDocumentAuthorizationService();
-        DocumentAuthorizer documentAuthorizer = docAuthService.getDocumentAuthorizer(document);
-        useDocumentAuthorizer(documentAuthorizer);
-    }
-
-    @Override
-    protected void useDocumentAuthorizer(DocumentAuthorizer documentAuthorizer) {
-
-        // init some things we'll need
-        Person kualiUser = GlobalVariables.getUserSession().getPerson();
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) getDocument();
-        MaintenanceDocumentAuthorizer maintenanceDocumentAuthorizer = (MaintenanceDocumentAuthorizer) documentAuthorizer;
-
-        // set the overall document editing mode
-        setEditingMode(documentAuthorizer.getEditMode(maintenanceDocument, kualiUser ));
-
-        // WHY IS THIS READONLY STUFF HERE YOU ASK, GIVEN THE EDITMODE
-        //
-        // Thats a good question. It's basically just there to make the proper generation
-        // of UI stuff in the JSP code easier, as you can just set a simple var on the jsp
-        // with the isReadOnly property.
-        //
-        // ITS IMPORTANT TO NOTE that the readOnly flag is ALWAYS dependent on the EditingMode
-        // data. So EditingMode is authoritative, readOnly is there for convenience.
-        //
-
-        // set the readOnly flag for this document, default to readOnly = true
-        setReadOnly(true);
-        String editMode;
-        editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY);
-        if ("TRUE".equalsIgnoreCase(editMode)) {
-            setReadOnly(false);
-        }
-        editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY);
-        if ("TRUE".equalsIgnoreCase(editMode)) {
-            setReadOnly(false);
-        }
-
-        // set field permissions
-        setAuthorizations(maintenanceDocumentAuthorizer.getFieldAuthorizations(maintenanceDocument, kualiUser));
-
-        // set the overall document action flags
-        setDocumentActionFlags(maintenanceDocumentAuthorizer.getDocumentActionFlags(maintenanceDocument, kualiUser));
-    }
-
-    /**
-     * @return Returns the maintenanceAction.
-     */
-    public String getMaintenanceAction() {
-        return maintenanceAction;
-    }
-
-    /**
-     * @return Returns the businessObjectClassName.
-     */
-    public String getBusinessObjectClassName() {
-        return businessObjectClassName;
-    }
-
-    /**
-     * @param businessObjectClassName The businessObjectClassName to set.
-     */
-    public void setBusinessObjectClassName(String businessObjectClassName) {
-        this.businessObjectClassName = businessObjectClassName;
-    }
-
-    /**
-     * @return Returns the description.
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * @param description The description to set.
-     */
-    public void setDescription(String description) {
-        this.description = description;
-    }
-
-    /**
-     * @return Returns the isReadOnly.
-     */
-    public boolean isReadOnly() {
-        return readOnly;
-    }
-
-    /**
-     * @param readOnly The isReadOnly to set.
-     */
-    public void setReadOnly(boolean readOnly) {
-        this.readOnly = readOnly;
-    }
-
-    /**
-     * @return Returns the newMaintainableValues.
-     */
-    public Map getNewMaintainableValues() {
-        return newMaintainableValues;
-    }
-
-    /**
-     * @return Returns the oldMaintainableValues.
-     */
-    public Map getOldMaintainableValues() {
-        return oldMaintainableValues;
-    }
-
-    /**
-     * @param maintenanceAction The maintenanceAction to set.
-     */
-    public void setMaintenanceAction(String maintenanceAction) {
-        this.maintenanceAction = maintenanceAction;
-    }
-
-    /**
-     * Gets the authorizations attribute.
-     * 
-     * @return Returns the authorizations.
-     */
-    public MaintenanceDocumentAuthorizations getAuthorizations() {
-        return authorizations;
-    }
-
-    /**
-     * Sets the authorizations attribute value.
-     * 
-     * @param authorizations The authorizations to set.
-     */
-    public void setAuthorizations(MaintenanceDocumentAuthorizations authorizations) {
-        this.authorizations = authorizations;
-    }
-
-    /**
-     * Sets the newMaintainableValues attribute value.
-     * 
-     * @param newMaintainableValues The newMaintainableValues to set.
-     */
-    public void setNewMaintainableValues(Map newMaintainableValues) {
-        this.newMaintainableValues = newMaintainableValues;
-    }
-
-
-    /**
-     * Sets the oldMaintainableValues attribute value.
-     * 
-     * @param oldMaintainableValues The oldMaintainableValues to set.
-     */
-    public void setOldMaintainableValues(Map oldMaintainableValues) {
-        this.oldMaintainableValues = oldMaintainableValues;
-    }
-
-
-    public String getLookupResultsSequenceNumber() {
-        return lookupResultsSequenceNumber;
-    }
-
-
-    public void setLookupResultsSequenceNumber(String lookupResultsSequenceNumber) {
-        this.lookupResultsSequenceNumber = lookupResultsSequenceNumber;
-    }
-
-
-    public String getLookupResultsBOClassName() {
-        return lookupResultsBOClassName;
-    }
-
-
-    public void setLookupResultsBOClassName(String lookupResultsBOClassName) {
-        this.lookupResultsBOClassName = lookupResultsBOClassName;
-    }
-
-
-    public String getLookedUpCollectionName() {
-        return lookedUpCollectionName;
-    }
-
-
-    public void setLookedUpCollectionName(String lookedUpCollectionName) {
-        this.lookedUpCollectionName = lookedUpCollectionName;
-    }
-
-    public String getAdditionalSectionsFile() {
-        if ( businessObjectClassName != null ) {
-            try {
-                MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-                String docTypeName = maintenanceDocumentDictionaryService.getDocumentTypeName(Class.forName(businessObjectClassName));
-                return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(businessObjectClassName).getAdditionalSectionsFile();
-            } catch ( ClassNotFoundException ex ) {
-                LOG.error( "Unable to resolve business object class", ex);
-            }
-        }else{
-            MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-            return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(this.getDocTypeName()).getAdditionalSectionsFile();
-        }
-        return null;
-    }
-
-	/**
-	 * This overridden method handles the case where maint doc properties do not reflect the true nature of the 
-	 * 
-	 * @see org.kuali.rice.kns.web.struts.form.KualiForm#retrieveFormValueForLookupInquiryParameters(java.lang.String, java.lang.String)
-	 */
-	@Override
-	public String retrieveFormValueForLookupInquiryParameters(String parameterName, String parameterValueLocation) {
-		MaintenanceDocument maintDoc = (MaintenanceDocument) getDocument();
-		if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
-            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
-            if (maintDoc.getOldMaintainableObject() != null && maintDoc.getOldMaintainableObject().getBusinessObject() != null) {
-            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getOldMaintainableObject().getBusinessObject(), propertyName);
-            	if (parameterValue == null) {
-            		return null;
-            	}
-            	if (parameterValue instanceof String) {
-            		return (String) parameterValue;
-            	}
-            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
-        		return (String) formatter.format(parameterValue);	
-            }
-        }
-        if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-            if (maintDoc.getNewMaintainableObject() != null && maintDoc.getNewMaintainableObject().getBusinessObject() != null) {
-            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getNewMaintainableObject().getBusinessObject(), propertyName);
-            	if (parameterValue == null) {
-            		return null;
-            	}
-            	if (parameterValue instanceof String) {
-            		return (String) parameterValue;
-            	}
-            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
-        		return (String) formatter.format(parameterValue);	
-            }
-        }
-		return super.retrieveFormValueForLookupInquiryParameters(parameterName, parameterValueLocation);
-	}
-}
+/*
+ * Copyright 2005-2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.web.struts.form;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.struts.upload.FormFile;
+import org.kuali.rice.core.config.ConfigurationException;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.bo.BusinessObject;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.document.MaintenanceDocumentBase;
+import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
+import org.kuali.rice.kns.exception.UnknownDocumentTypeException;
+import org.kuali.rice.kns.maintenance.Maintainable;
+import org.kuali.rice.kns.service.DocumentAuthorizationService;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.FieldUtils;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.util.RiceKeyConstants;
+import org.kuali.rice.kns.web.format.FormatException;
+import org.kuali.rice.kns.web.format.Formatter;
+
+
+/**
+ * This class is the base action form for all maintenance documents.
+ * 
+ * 
+ */
+public class KualiMaintenanceForm extends KualiDocumentFormBase {
+    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KualiMaintenanceForm.class);
+
+    private static final long serialVersionUID = 1L;
+
+    private String businessObjectClassName;
+    private String description;
+    private boolean readOnly;
+    private Map oldMaintainableValues;
+    private Map newMaintainableValues;
+    private String maintenanceAction;
+    
+    /**
+     * Used to indicate which result set we're using when refreshing/returning from a multi-value lookup
+     */
+    private String lookupResultsSequenceNumber;
+    /**
+     * The type of result returned by the multi-value lookup
+     * 
+     * TODO: to be persisted in the lookup results service instead?
+     */
+    private String lookupResultsBOClassName;
+    
+    /**
+     * The name of the collection looked up (by a multiple value lookup)
+     */
+    private String lookedUpCollectionName;
+    
+    private MaintenanceDocumentAuthorizations authorizations;
+    
+    /**
+     * Override the default method to add the if statement which can't be called until after parameters from a multipart request
+     * have been made accessible, but which must be called before the parameter values are used to instantiate and populate business
+     * objects.
+     * 
+     * @param requestParameters
+     */
+    @Override
+    public void postprocessRequestParameters(Map requestParameters) {
+        super.postprocessRequestParameters(requestParameters);
+
+        String docTypeName = null;
+        String[] docTypeNames = (String[]) requestParameters.get(KNSConstants.DOCUMENT_TYPE_NAME);
+        if ((docTypeNames != null) && (docTypeNames.length > 0)) {
+            docTypeName = docTypeNames[0];
+        }
+
+        if (StringUtils.isNotBlank(docTypeName)) {          
+        	if(this.getDocument() == null){
+            setDocTypeName(docTypeName);
+            Class documentClass = KNSServiceLocator.getDataDictionaryService().getDocumentClassByTypeName(docTypeName);
+            if (documentClass == null) {
+                throw new UnknownDocumentTypeException("unable to get class for unknown documentTypeName '" + docTypeName + "'");
+            }
+            if (!MaintenanceDocumentBase.class.isAssignableFrom(documentClass)) {
+                throw new ConfigurationException("Document class '" + documentClass + "' is not assignable to '" + MaintenanceDocumentBase.class + "'");
+            }
+            Document document = null;
+            try {
+                Class[] defaultConstructor = new Class[]{String.class};
+                Constructor cons = documentClass.getConstructor(defaultConstructor);
+                if (ObjectUtils.isNull(cons)) {
+                    throw new ConfigurationException("Could not find constructor with document type name parameter needed for Maintenance Document Base class");
+                }
+                document = (Document) cons.newInstance(docTypeName);
+            } catch (SecurityException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document: No constructor with String parameter found", e);
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (InstantiationException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (IllegalArgumentException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            }
+            if (document == null) {
+                throw new RuntimeException("Unable to instantiate document with type name '" + docTypeName + "' and document class '" + documentClass + "'");
+            }
+            setDocument(document);
+          } 
+       }
+        
+        MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
+        
+        //Handling the Multi-Part Attachment
+        for ( Object obj : requestParameters.entrySet() ) {
+            String parameter = (String)((Map.Entry)obj).getKey(); 
+            if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+                String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+                Object propertyValue = requestParameters.get(parameter);
+                
+                if(propertyValue != null && propertyValue instanceof FormFile) {
+                    if(StringUtils.isNotEmpty(((FormFile)propertyValue).getFileName())) {
+                        maintenanceDocument.setFileAttachment((FormFile) propertyValue);
+                    }
+                    maintenanceDocument.setAttachmentPropertyName(propertyName);
+                }
+            }
+        }
+    }
+
+    /**
+     * Hook into populate so we can set the maintenance documents and feed the field values to its maintainables.
+     */
+    @Override
+    public void populate(HttpServletRequest request) {
+        super.populate(request);
+
+
+        // document type name is null on start, otherwise should be here
+        if (StringUtils.isNotBlank(getDocTypeName())) {
+            Map localOldMaintainableValues = new HashMap();
+            Map localNewMaintainableValues = new HashMap();
+            Map<String,String> localNewCollectionValues = new HashMap<String,String>();
+            for (Enumeration i = request.getParameterNames(); i.hasMoreElements();) {
+                String parameter = (String) i.nextElement();
+                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
+                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+                    localOldMaintainableValues.put(propertyName, request.getParameter(parameter));
+                }
+                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+                    localNewMaintainableValues.put(propertyName, request.getParameter(parameter));
+                }
+            }
+            
+            // now, get all add lines and store them to a separate map
+            // for use in a separate call to the maintainable
+            for ( Object obj : localNewMaintainableValues.entrySet() ) {
+                String key = (String)((Map.Entry)obj).getKey(); 
+                if ( key.startsWith( KNSConstants.MAINTENANCE_ADD_PREFIX ) ) {
+                    localNewCollectionValues.put( key.substring( KNSConstants.MAINTENANCE_ADD_PREFIX.length() ),
+                            (String)((Map.Entry)obj).getValue() );
+                }
+            }
+            if ( LOG.isDebugEnabled() ) {
+                LOG.debug( "checked for add line parameters - got: " + localNewCollectionValues );
+            }
+            
+            this.newMaintainableValues = localNewMaintainableValues;
+            this.oldMaintainableValues = localOldMaintainableValues;
+
+            MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
+
+            GlobalVariables.getErrorMap().addToErrorPath("document.oldMaintainableObject");
+            maintenanceDocument.getOldMaintainableObject().populateBusinessObject(localOldMaintainableValues, maintenanceDocument);
+            GlobalVariables.getErrorMap().removeFromErrorPath("document.oldMaintainableObject");
+
+            GlobalVariables.getErrorMap().addToErrorPath("document.newMaintainableObject");
+            // update the main object
+            Map cachedValues = 
+            	maintenanceDocument.getNewMaintainableObject().populateBusinessObject(localNewMaintainableValues, maintenanceDocument);
+            
+            if(maintenanceDocument.getFileAttachment() != null) {
+                populateAttachmentPropertyForBO(maintenanceDocument);
+            }
+            
+            // update add lines
+            localNewCollectionValues = org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().resolvePrincipalNamesToPrincipalIds((BusinessObject)maintenanceDocument.getNewMaintainableObject().getBusinessObject(), localNewCollectionValues);
+            cachedValues.putAll( maintenanceDocument.getNewMaintainableObject().populateNewCollectionLines( localNewCollectionValues ) );
+            GlobalVariables.getErrorMap().removeFromErrorPath("document.newMaintainableObject");
+
+            if (cachedValues.size() > 0) {
+                GlobalVariables.getErrorMap().putError(KNSConstants.DOCUMENT_ERRORS, RiceKeyConstants.ERROR_DOCUMENT_MAINTENANCE_FORMATTING_ERROR);
+                for (Iterator iter = cachedValues.keySet().iterator(); iter.hasNext();) {
+                    String propertyName = (String) iter.next();
+                    String value = (String) cachedValues.get(propertyName);
+                    cacheUnconvertedValue(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE + propertyName, value);
+                }
+            }
+        }
+    }
+
+    private void populateAttachmentPropertyForBO(MaintenanceDocumentBase maintenanceDocument) {
+        try {
+            Class type = ObjectUtils.easyGetPropertyType(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName());
+            ObjectUtils.setObjectProperty(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName(), type, maintenanceDocument.getFileAttachment());
+        } catch (FormatException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        }
+    }
+    
+    /**
+     * Merges rows of old and new for each section (tab) of the ui. Also, renames fields to prevent naming conflicts and does
+     * setting of read only fields.
+     * 
+     * @return Returns the maintenanceSections.
+     */
+    public List getSections() {
+        if (getDocument() == null) {
+            throw new RuntimeException("Document not set in maintenance form.");
+        }
+        if (((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject() == null) {
+            throw new RuntimeException("New maintainable not set in document.");
+        }
+        if ((KNSConstants.MAINTENANCE_EDIT_ACTION.equals(this.getMaintenanceAction()) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(this.getMaintenanceAction())) && ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject() == null) {
+            throw new RuntimeException("Old maintainable not set in document.");
+        }
+
+        // if the authorization stuff hasnt been applied yet, then apply it
+        if (authorizations == null) {
+            applyAuthorizations();
+        }
+
+        // get business object being maintained and its keys
+        List keyFieldNames = KNSServiceLocator.getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject().getBusinessObject().getClass());
+
+        // sections for maintenance document
+        Maintainable oldMaintainable = ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject();
+        oldMaintainable.setMaintenanceAction(getMaintenanceAction());
+        List oldMaintSections = oldMaintainable.getSections(null);
+        
+        Maintainable newMaintainable = ((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject();
+        newMaintainable.setMaintenanceAction(getMaintenanceAction());
+        List newMaintSections = newMaintainable.getSections(oldMaintainable);
+
+        // mesh sections for proper jsp display
+        List meshedSections = FieldUtils.meshSections(oldMaintSections, newMaintSections, keyFieldNames, getMaintenanceAction(), isReadOnly(), authorizations);
+
+        return meshedSections;
+    }
+
+    protected void applyAuthorizations() {
+        Document document = getDocument();
+        DocumentAuthorizationService docAuthService = KNSServiceLocator.getDocumentAuthorizationService();
+        DocumentAuthorizer documentAuthorizer = docAuthService.getDocumentAuthorizer(document);
+        useDocumentAuthorizer(documentAuthorizer);
+    }
+
+    @Override
+    protected void useDocumentAuthorizer(DocumentAuthorizer documentAuthorizer) {
+
+        // init some things we'll need
+        Person kualiUser = GlobalVariables.getUserSession().getPerson();
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) getDocument();
+        MaintenanceDocumentAuthorizer maintenanceDocumentAuthorizer = (MaintenanceDocumentAuthorizer) documentAuthorizer;
+
+        // set the overall document editing mode
+        //setEditingMode(documentAuthorizer.getEditMode(maintenanceDocument, kualiUser ));
+
+        // WHY IS THIS READONLY STUFF HERE YOU ASK, GIVEN THE EDITMODE
+        //
+        // Thats a good question. It's basically just there to make the proper generation
+        // of UI stuff in the JSP code easier, as you can just set a simple var on the jsp
+        // with the isReadOnly property.
+        //
+        // ITS IMPORTANT TO NOTE that the readOnly flag is ALWAYS dependent on the EditingMode
+        // data. So EditingMode is authoritative, readOnly is there for convenience.
+        //        
+        //String editMode;
+        //editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY);
+        //if ("TRUE".equalsIgnoreCase(editMode)) {
+        //    setReadOnly(false);
+        //}
+        //editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY);
+        //if ("TRUE".equalsIgnoreCase(editMode)) {
+        //    setReadOnly(false);
+        //}
+
+        // set the readOnly flag for this document, default to readOnly = true
+        setReadOnly(true);
+        
+        // Check overall document edit permission
+        if(maintenanceDocumentAuthorizer.canEdit(getDocument(), kualiUser)){
+        	setReadOnly(false);
+        }
+        
+        // set field permissions
+        setAuthorizations(maintenanceDocumentAuthorizer.getFieldAuthorizations(maintenanceDocument, kualiUser));
+
+        // set the overall document action flags
+        setDocumentActionFlags(maintenanceDocumentAuthorizer.getDocumentActionFlags(maintenanceDocument, kualiUser));
+    }
+
+    /**
+     * @return Returns the maintenanceAction.
+     */
+    public String getMaintenanceAction() {
+        return maintenanceAction;
+    }
+
+    /**
+     * @return Returns the businessObjectClassName.
+     */
+    public String getBusinessObjectClassName() {
+        return businessObjectClassName;
+    }
+
+    /**
+     * @param businessObjectClassName The businessObjectClassName to set.
+     */
+    public void setBusinessObjectClassName(String businessObjectClassName) {
+        this.businessObjectClassName = businessObjectClassName;
+    }
+
+    /**
+     * @return Returns the description.
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * @param description The description to set.
+     */
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    /**
+     * @return Returns the isReadOnly.
+     */
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    /**
+     * @param readOnly The isReadOnly to set.
+     */
+    public void setReadOnly(boolean readOnly) {
+        this.readOnly = readOnly;
+    }
+
+    /**
+     * @return Returns the newMaintainableValues.
+     */
+    public Map getNewMaintainableValues() {
+        return newMaintainableValues;
+    }
+
+    /**
+     * @return Returns the oldMaintainableValues.
+     */
+    public Map getOldMaintainableValues() {
+        return oldMaintainableValues;
+    }
+
+    /**
+     * @param maintenanceAction The maintenanceAction to set.
+     */
+    public void setMaintenanceAction(String maintenanceAction) {
+        this.maintenanceAction = maintenanceAction;
+    }
+
+    /**
+     * Gets the authorizations attribute.
+     * 
+     * @return Returns the authorizations.
+     */
+    public MaintenanceDocumentAuthorizations getAuthorizations() {
+        return authorizations;
+    }
+
+    /**
+     * Sets the authorizations attribute value.
+     * 
+     * @param authorizations The authorizations to set.
+     */
+    public void setAuthorizations(MaintenanceDocumentAuthorizations authorizations) {
+        this.authorizations = authorizations;
+    }
+
+    /**
+     * Sets the newMaintainableValues attribute value.
+     * 
+     * @param newMaintainableValues The newMaintainableValues to set.
+     */
+    public void setNewMaintainableValues(Map newMaintainableValues) {
+        this.newMaintainableValues = newMaintainableValues;
+    }
+
+
+    /**
+     * Sets the oldMaintainableValues attribute value.
+     * 
+     * @param oldMaintainableValues The oldMaintainableValues to set.
+     */
+    public void setOldMaintainableValues(Map oldMaintainableValues) {
+        this.oldMaintainableValues = oldMaintainableValues;
+    }
+
+
+    public String getLookupResultsSequenceNumber() {
+        return lookupResultsSequenceNumber;
+    }
+
+
+    public void setLookupResultsSequenceNumber(String lookupResultsSequenceNumber) {
+        this.lookupResultsSequenceNumber = lookupResultsSequenceNumber;
+    }
+
+
+    public String getLookupResultsBOClassName() {
+        return lookupResultsBOClassName;
+    }
+
+
+    public void setLookupResultsBOClassName(String lookupResultsBOClassName) {
+        this.lookupResultsBOClassName = lookupResultsBOClassName;
+    }
+
+
+    public String getLookedUpCollectionName() {
+        return lookedUpCollectionName;
+    }
+
+
+    public void setLookedUpCollectionName(String lookedUpCollectionName) {
+        this.lookedUpCollectionName = lookedUpCollectionName;
+    }
+
+    public String getAdditionalSectionsFile() {
+        if ( businessObjectClassName != null ) {
+            try {
+                MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+                String docTypeName = maintenanceDocumentDictionaryService.getDocumentTypeName(Class.forName(businessObjectClassName));
+                return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(businessObjectClassName).getAdditionalSectionsFile();
+            } catch ( ClassNotFoundException ex ) {
+                LOG.error( "Unable to resolve business object class", ex);
+            }
+        }else{
+            MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+            return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(this.getDocTypeName()).getAdditionalSectionsFile();
+        }
+        return null;
+    }
+
+	/**
+	 * This overridden method handles the case where maint doc properties do not reflect the true nature of the 
+	 * 
+	 * @see org.kuali.rice.kns.web.struts.form.KualiForm#retrieveFormValueForLookupInquiryParameters(java.lang.String, java.lang.String)
+	 */
+	@Override
+	public String retrieveFormValueForLookupInquiryParameters(String parameterName, String parameterValueLocation) {
+		MaintenanceDocument maintDoc = (MaintenanceDocument) getDocument();
+		if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
+            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+            if (maintDoc.getOldMaintainableObject() != null && maintDoc.getOldMaintainableObject().getBusinessObject() != null) {
+            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getOldMaintainableObject().getBusinessObject(), propertyName);
+            	if (parameterValue == null) {
+            		return null;
+            	}
+            	if (parameterValue instanceof String) {
+            		return (String) parameterValue;
+            	}
+            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
+        		return (String) formatter.format(parameterValue);	
+            }
+        }
+        if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+            if (maintDoc.getNewMaintainableObject() != null && maintDoc.getNewMaintainableObject().getBusinessObject() != null) {
+            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getNewMaintainableObject().getBusinessObject(), propertyName);
+            	if (parameterValue == null) {
+            		return null;
+            	}
+            	if (parameterValue instanceof String) {
+            		return (String) parameterValue;
+            	}
+            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
+        		return (String) formatter.format(parameterValue);	
+            }
+        }
+		return super.retrieveFormValueForLookupInquiryParameters(parameterName, parameterValueLocation);
+	}
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java	(revision 5507)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java	(working copy)
@@ -1,88 +1,190 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.Map;
-
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.Document;
-
-/**
- * The DocumentAuthorizer class associated with a given Document is used to dynamically determine what editing mode and what actions
- * are allowed for a given user on a given document instance.
- * 
- * 
- */
-public interface DocumentAuthorizer {
-    /**
-     * @param document
-     * @param user
-     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
-     *         allowed to take on that document.
-     */
-    public Map getEditMode(Document document, Person user);
-
-    /**
-     * @param document - the document locks are to be established against or by
-     * @param editMode - the editMode returned by the method {@link #getEditMode(Document, Person)}
-     * @param user - the user locks are being established for
-     * @return New map generated by locking logic combined with passed in parameter editMode.  Map contains keys 
-     *         AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently 
-     *         allowed to take on that document.  This may be a modified list of 
-     */
-    public Map establishLocks(Document document, Map editMode, Person user);
-
-    /**
-     * @param document - the document to create the lock against and add the lock to
-     */
-    public void establishWorkflowPessimisticLocking(Document document);
-
-    /**
-     * @param document - document to release locks from
-     */
-    public void releaseWorkflowPessimisticLocking(Document document);
-    
-    /**
-     * @param document
-     * @param user
-     * @return DocumentActionFlags instance indicating which actions are permitted the given user on the given document
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user);
-
-    /**
-     * @param documentTypeName
-     * @param user
-     * @return true if the given user is allowed to initiate documents of the given document type
-     */
-    public void canInitiate(String documentTypeName, Person user);
-    
-    /**
-     * @param documentTypeName
-     * @param user
-     * @returns boolean indicating whether a user can copy a document
-     */
-    public boolean canCopy(String documentTypeName, Person user);
-
-    /**
-     * 
-     * @param attachmentTypeName
-     * @param document
-     * @param user
-     * @return
-     */
-    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user);
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentAuthorizer class associated with a given Document is used to dynamically determine what editing mode and what actions
+ * are allowed for a given user on a given document instance.
+ * 
+ * 
+ */
+public interface DocumentAuthorizer {
+    /**
+     * @param document
+     * @param user
+     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
+     *         allowed to take on that document.
+     */
+    public Map getEditMode(Document document, Person user);
+    
+    /**
+     * @param document - the document locks are to be established against or by
+     * @param editMode - the editMode returned by the method {@link #getEditMode(Document, Person)}
+     * @param user - the user locks are being established for
+     * @return New map generated by locking logic combined with passed in parameter editMode.  Map contains keys 
+     *         AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently 
+     *         allowed to take on that document.  This may be a modified list of 
+     */
+    public Map establishLocks(Document document, Map editMode, Person user);
+
+    /**
+     * @param document - the document to create the lock against and add the lock to
+     */
+    public void establishWorkflowPessimisticLocking(Document document);
+
+    /**
+     * @param document - document to release locks from
+     */
+    public void releaseWorkflowPessimisticLocking(Document document);
+    
+    /**
+     * @param document
+     * @param user
+     * @return DocumentActionFlags instance indicating which actions are permitted the given user on the given document
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user);
+
+    /**
+     * @param documentTypeName
+     * @param user
+     * @return true if the given user is allowed to initiate documents of the given document type
+     */
+    public void canInitiate(String documentTypeName, Person user);
+    
+    /**
+     * @param documentTypeName
+     * @param user
+     * @returns boolean indicating whether a user can copy a document
+     */
+    public boolean canCopy(String documentTypeName, Person user);
+
+    /**
+     * 
+     * @param attachmentTypeName
+     * @param document
+     * @param user
+     * @return
+     */
+    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to open the document
+     */
+    public boolean canOpen(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to edit the document
+     */
+    public boolean canEdit(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to copy the document
+     */
+    public boolean canCopy(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to cancel the document
+     */
+    public boolean canCancel(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to Route the document
+     */
+    public boolean canRoute(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to save the document
+     */
+    public boolean canSave(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to approve the document
+     */
+    public boolean canBlanketApprove(Document document, Person user); 
+    
+    /**
+     * @param document
+     * @param user
+     * @param actionRequestCode
+     * @return true if the given user is allowed to receive ad hoc
+     */
+    public boolean canReceiveAdHoc(Document document, Person user, String actionRequestCode);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to approve the document
+     */
+    public boolean canApprove(Document document, Person user); 
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to clear FYI
+     */
+    public boolean canClearFYI(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to acknowledge
+     */
+    public boolean canAcknowledge(Document document, Person user); 
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to complete the document
+     */
+    public boolean canComplete(Document document, Person user ); 
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to disapprove the document
+     */
+    public boolean canDisapprove(Document document, Person user); 
+    
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to annotate the document
+     */
+    public boolean canAnnotate(Document document, Person user); 
+    
+    
+}
+
