### Eclipse Workspace Patch 1.0
#P rice
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizerBase.java	(working copy)
@@ -1,284 +1,292 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.StringUtils;
-import org.kuali.rice.kim.bo.FieldAttributeSecurity;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kim.bo.types.dto.AttributeSet;
-import org.kuali.rice.kim.util.DocumentAttributeSecurityUtils;
-import org.kuali.rice.kim.util.KimConstants;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.datadictionary.AttributeSecurity;
-import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
-import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
-import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
-import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-
-public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
-
- 	private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
-    /**
-     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
-        
-    	MaintenanceDocumentAuthorizations auths = new MaintenanceDocumentAuthorizations();
-    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
-    	
-    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
-    	Map<String, FieldAttributeSecurity> restrictionFields = DocumentAttributeSecurityUtils.getRestrictionMaintainableFields(objectEntry);
-    	
-    	Set keys = restrictionFields.keySet();    
-    	Iterator keyIter = keys.iterator();
-        while (keyIter.hasNext()) { 
-           String fullFieldName = (String) keyIter.next(); 
-           FieldAttributeSecurity fieldAttributeSecurity = (FieldAttributeSecurity) restrictionFields.get(fullFieldName);
-           String fieldName = fieldAttributeSecurity.getAttributeName();
-           
-           //TODO:Should use ParameterService.getDetailType to get the componentName
-           String componentName = fieldAttributeSecurity.getBusinessObjectClass().getSimpleName();     
-           String nameSpaceCode = "KR-NS";
-           
-           AttributeSecurity maintainableFieldAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getMaintainableFieldAttributeSecurity();
-           AttributeSecurity  businessObjectAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getBusinessObjectAttributeSecurity();
-           
-           AttributeSet permissionDetails = new AttributeSet();
-    	   permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, fieldName);
-    	  
-    	   
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isReadOnly()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
-    			   auths.addReadonlyAuthField(fullFieldName);
-    		   }
-    	   }
-    	   
-    	   if(maintainableFieldAttributeSecurity != null && maintainableFieldAttributeSecurity.isReadOnly()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
-    			   auths.addReadonlyAuthField(fullFieldName);
-    		   }
-    	   }
-    	   
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isPartialMask()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
-    			   MaskFormatter partialMaskFormatter = businessObjectAttributeSecurity.getPartialMaskFormatter();
-    			   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
-    		   }
-    	   }
-    	   
-    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isPartialMask()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
-				   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
-				   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
-			   }
-		   }
-    	   
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isMask()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
-    		       MaskFormatter maskFormatter = businessObjectAttributeSecurity.getMaskFormatter();
-    			   auths.addMaskedAuthField(fullFieldName, maskFormatter);
-    		   }
-    	   }
-    	   
-    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isMask()){  
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
-				   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
-				   auths.addMaskedAuthField(fullFieldName, maskFormatter);
-			   }
-		   }
-    	
-    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isHide()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
-    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
-    			   auths.addHiddenAuthField(fullFieldName);	  
-    		   }
-    	   }   
-
-    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isHide()){
-    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
-			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
-				   auths.addHiddenAuthField(fullFieldName);	  
-			   }
-		   }
-  
-        }    	
-    	return auths; 
-    }
-
-
-    /**
-     * 
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-
-        // run the super, let the common flags be set
-        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
-
-        // run the fieldAuthorizations
-        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
-        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
-
-        // if there are any field restrictions for this user, then we need to turn off the
-        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
-        // they certainly cant blanket approve it.
-        if (docAuths.hasAnyFieldRestrictions()) {
-            docActionFlags.setCanBlanketApprove(false);
-        }
-
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-
-        // if a user can't initiate a document of this type then they can't copy one, either
-        if (!canCopy(workflowDocument.getDocumentType(), user)) {
-            docActionFlags.setCanCopy(false);
-        }
-        else {
-            docActionFlags.setCanCopy(document.getAllowsCopy() && (!workflowDocument.stateIsInitiated() && !workflowDocument.stateIsEnroute() && !workflowDocument.stateIsException() && !workflowDocument.stateIsSaved()));
-        }
-
-        return docActionFlags;
-    }
-
-    /**
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public Map getEditMode(Document document, Person user) {
-
-        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
-        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
-            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
-        }
-
-        Map editMode = new HashMap();
-        
-        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
-        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
-
-        // default to view-only, as a safety precaution
-        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-
-        // if the document is cancelled, then its view only
-        if (workflowDocument.stateIsCanceled()) {
-            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
-        }
-
-        // if the document is being edited, then its full entry, or if the current user is
-        // the system supervisor
-        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-            if (workflowDocument.userIsInitiator(user)) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
-                
-                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
-                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
-                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
-                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
-                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
-                }
-            }
-        }
-
-        // if the document is in routing, then we have some special rules
-        else if (workflowDocument.stateIsEnroute()) {
-
-            // the person who has the approval request in their Actiong List
-            // should be able to modify the document
-            if (workflowDocument.isApprovalRequested()) {
-                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
-            }
-        }
-
-        // save the editmode
-        editMode.put(editModeKey, "TRUE");
-        return editMode;
-    }
-
-    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
-        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
-        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
-        
-        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
-            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
-                if (itemDefinition instanceof MaintainableFieldDefinition) {
-                    String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
-                    if (StringUtils.isNotBlank(displayEditMode)) {
-                        editModes.put(displayEditMode, "TRUE");
-                    }
-                }
-                // TODO: what about MaintainableCollectionDefinition?
-            }
-        }
-    }
-    
-    /**
-     * This method returns whether this document is creating a new entry in the maintenible/underlying table
-     * 
-     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
-     * useful in determining which fields are encrypted
-     * 
-     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
-     * there is uncertainity how documents with this action will actually be implemented
-     * 
-     * @param maintDoc
-     * @param user
-     * @return
-     */
-    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
-        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
-        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
-        
-        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
-        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
-        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
-    }
-    
-    	
-	/**
-	 * @return the maintenanceDocumentDictionaryService
-	 */
-	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
-		
-		if (maintenanceDocumentDictionaryService == null ) {
-			maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-		}
-		return maintenanceDocumentDictionaryService;
-	}
-
-    
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.kuali.rice.kim.bo.FieldAttributeSecurity;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.DocumentAttributeSecurityUtils;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.datadictionary.AttributeSecurity;
+import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
+import org.kuali.rice.kns.datadictionary.mask.MaskFormatter;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+public class MaintenanceDocumentAuthorizerBase extends DocumentAuthorizerBase implements MaintenanceDocumentAuthorizer {
+
+ 	private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
+    /**
+     * @see org.kuali.rice.kns.authorization.MaintenanceDocumentAuthorizer#getFieldAuthorizations(org.kuali.rice.kns.document.MaintenanceDocument,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user) {
+        
+    	MaintenanceDocumentAuthorizations auths = new MaintenanceDocumentAuthorizations();
+    	String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+    	
+    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
+    	Map<String, FieldAttributeSecurity> restrictionFields = DocumentAttributeSecurityUtils.getRestrictionMaintainableFields(objectEntry);
+    	
+    	Set keys = restrictionFields.keySet();    
+    	Iterator keyIter = keys.iterator();
+        while (keyIter.hasNext()) { 
+           String fullFieldName = (String) keyIter.next(); 
+           FieldAttributeSecurity fieldAttributeSecurity = (FieldAttributeSecurity) restrictionFields.get(fullFieldName);
+           String fieldName = fieldAttributeSecurity.getAttributeName();
+           
+           //TODO:Should use ParameterService.getDetailType to get the componentName
+           String componentName = fieldAttributeSecurity.getBusinessObjectClass().getSimpleName();     
+           String nameSpaceCode = "KR-NS";
+           
+           AttributeSecurity maintainableFieldAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getMaintainableFieldAttributeSecurity();
+           AttributeSecurity  businessObjectAttributeSecurity = (AttributeSecurity) fieldAttributeSecurity.getBusinessObjectAttributeSecurity();
+           
+           AttributeSet permissionDetails = new AttributeSet();
+    	   permissionDetails.put(KimConstants.KIM_ATTRIB_PROPERTY_NAME, fieldName);
+    	  
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null && maintainableFieldAttributeSecurity.isReadOnly()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_PROPERTY, permissionDetails, null)){
+    			   auths.addReadonlyAuthField(fullFieldName);
+    		   }
+    	   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+    			   MaskFormatter partialMaskFormatter = businessObjectAttributeSecurity.getPartialMaskFormatter();
+    			   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isPartialMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_PARTIALLY_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter partialMaskFormatter = maintainableFieldAttributeSecurity.getPartialMaskFormatter();
+				   auths.addPartiallyMaskedAuthField(fullFieldName, partialMaskFormatter);
+			   }
+		   }
+    	   
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isMask()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+    		       MaskFormatter maskFormatter = businessObjectAttributeSecurity.getMaskFormatter();
+    			   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+    		   }
+    	   }
+    	   
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isMask()){  
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_UNMASK_PROPERTY, permissionDetails, null)){
+				   MaskFormatter maskFormatter = maintainableFieldAttributeSecurity.getMaskFormatter();
+				   auths.addMaskedAuthField(fullFieldName, maskFormatter);
+			   }
+		   }
+    	
+    	   if(businessObjectAttributeSecurity != null && businessObjectAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, componentName);
+    		   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+    			   auths.addHiddenAuthField(fullFieldName);	  
+    		   }
+    	   }   
+
+    	   if(maintainableFieldAttributeSecurity != null  && maintainableFieldAttributeSecurity.isHide()){
+    		   permissionDetails.put(KimConstants.KIM_ATTRIB_COMPONENT_NAME, documentType);
+			   if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_VIEW_PROPERTY, permissionDetails, null)){
+				   auths.addHiddenAuthField(fullFieldName);	  
+			   }
+		   }
+  
+        }    	
+    	return auths; 
+    }
+
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+
+            	// run the super, let the common flags be set
+        MaintenanceDocumentActionFlags docActionFlags = new MaintenanceDocumentActionFlags(super.getDocumentActionFlags(document, user));
+
+        // run the fieldAuthorizations
+        MaintenanceDocument maintDoc = (MaintenanceDocument) document;
+        MaintenanceDocumentAuthorizations docAuths = getFieldAuthorizations(maintDoc, user);
+
+        // if there are any field restrictions for this user, then we need to turn off the
+        // ability to BlanketApprove, as this person doesnt have access to all the fields, so
+        // they certainly cant blanket approve it.
+        if (docAuths.hasAnyFieldRestrictions()) {
+            docActionFlags.setCanBlanketApprove(false);
+        }
+
+        return docActionFlags;
+    }
+
+    /**
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public Map getEditMode(Document document, Person user) {
+
+        // if this is not a MaintenanceDocument, then fail loudly, something is badly wrong
+        if (!MaintenanceDocument.class.isAssignableFrom(document.getClass())) {
+            throw new IllegalArgumentException("A document was passed into MaintenanceDocumentAuthorizerBase.getEditMode() " + "that is not a MaintenanceDocument descendent.  Processing cannot continue.");
+        }
+
+        Map editMode = new HashMap();
+        
+        // cast the document as a MaintenanceDocument, and get a handle on the workflowDocument
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) document;
+        KualiWorkflowDocument workflowDocument = maintenanceDocument.getDocumentHeader().getWorkflowDocument();
+
+        // default to view-only, as a safety precaution
+        String editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+
+        // if the document is cancelled, then its view only
+        if (workflowDocument.stateIsCanceled()) {
+            editModeKey = AuthorizationConstants.MaintenanceEditMode.VIEW_ONLY;
+        }
+
+        // if the document is being edited, then its full entry, or if the current user is
+        // the system supervisor
+        else if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+            if (workflowDocument.userIsInitiator(user)) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY;
+                
+                // initiators of documents for new records can view these fields for the documents while they're sitll under the control
+                // of the initiators.  If they are always allowed access to the document, then they would be able to view the changes that
+                // were made during routing, which would be a bad idea, as the router may have edited sensitive information enroute
+                if (isDocumentForCreatingNewEntry(maintenanceDocument)) {
+                    addAllMaintDocDefinedEditModesToMap(editMode, maintenanceDocument);
+                }
+            }
+        }
+
+        // if the document is in routing, then we have some special rules
+        else if (workflowDocument.stateIsEnroute()) {
+
+            // the person who has the approval request in their Actiong List
+            // should be able to modify the document
+            if (workflowDocument.isApprovalRequested()) {
+                editModeKey = AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY;
+            }
+        }
+
+        // save the editmode
+        editMode.put(editModeKey, "TRUE");
+        return editMode;
+    }
+
+    protected void addAllMaintDocDefinedEditModesToMap(Map editModes, MaintenanceDocument maintDoc) {
+        String docTypeName = maintDoc.getDocumentHeader().getWorkflowDocument().getDocumentType();
+        List<MaintainableSectionDefinition> sectionDefinitions = KNSServiceLocator.getMaintenanceDocumentDictionaryService().getMaintainableSections(docTypeName);
+        
+        for ( MaintainableSectionDefinition sectionDefinition : sectionDefinitions ) {
+            for ( MaintainableItemDefinition itemDefinition : sectionDefinition.getMaintainableItems() ) {
+                if (itemDefinition instanceof MaintainableFieldDefinition) {
+                    String displayEditMode = ((MaintainableFieldDefinition) itemDefinition).getDisplayEditMode();
+                    if (StringUtils.isNotBlank(displayEditMode)) {
+                        editModes.put(displayEditMode, "TRUE");
+                    }
+                }
+                // TODO: what about MaintainableCollectionDefinition?
+            }
+        }
+    }
+    
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+    */
+    public void canInitiate(String documentTypeName, Person user) {
+    	String nameSpaceCode = "KR-SYS";
+    	String action = (String) GlobalVariables.getUserSession().retrieveObject(DocumentAuthorizerBase.USER_SESSION_METHOD_TO_CALL_OBJECT_KEY);
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION, action);    
+    		if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null)){ 	
+    			String userName = (String) GlobalVariables.getUserSession().getPrincipalName();
+    			throw new DocumentInitiationAuthorizationException(new String[] {userName,documentTypeName});
+    		}
+    }
+    
+    /**
+     * This method returns whether this document is creating a new entry in the maintenible/underlying table
+     * 
+     * This method is useful to determine whether all the field-based edit modes should be enabled, which is 
+     * useful in determining which fields are encrypted
+     * 
+     * This method considers that Constants.MAINTENANCE_NEWWITHEXISTING_ACTION is not a new document because 
+     * there is uncertainity how documents with this action will actually be implemented
+     * 
+     * @param maintDoc
+     * @param user
+     * @return
+     */
+    protected boolean isDocumentForCreatingNewEntry(MaintenanceDocument maintDoc) {
+        // the rule is as follows: if the maint doc represents a new record AND the user is the same user who initiated the maintenance doc
+        // if the user check is not added, then it would be pointless to do any encryption since I can just pull up a document to view the encrypted values
+        
+        // A maint doc is new when the new maintainable maintenance flag is set to either Constants.MAINTENANCE_NEW_ACTION or Constants.MAINTENANCE_COPY_ACTION
+        String maintAction = maintDoc.getNewMaintainableObject().getMaintenanceAction();
+        return (KNSConstants.MAINTENANCE_NEW_ACTION.equals(maintAction) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(maintAction));
+    }
+    
+    	
+	/**
+	 * @return the maintenanceDocumentDictionaryService
+	 */
+	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+		
+		if (maintenanceDocumentDictionaryService == null ) {
+			maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+		}
+		return maintenanceDocumentDictionaryService;
+	}
+
+    
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationController.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationController.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationController.java	(revision 0)
@@ -0,0 +1,38 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.List;
+
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentPresentationController class is used for non-user related lock down 
+ * 
+ * 
+ */
+
+public interface MaintenanceDocumentPresentationController extends DocumentPresentationController {
+	
+	/**
+	 * 
+	 * 
+	 * @param document
+	 * @return the list of uncondionallyReadOnly fields
+	 */
+	public List getReadOnlyFields(Document document);
+}
+
Index: impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kim/util/KimConstants.java	(working copy)
@@ -53,29 +53,30 @@
 	public static final String DOCUMENT_STATUS_PERMISSION_TYPE = "DocumentStatusComponentAttributePermissionType";
 	public static final String KIM_ATTRIB_EDIT_MODE = "editMode";
 	public static final String USER_IS_INITIATOR = "userIsInitiator";
-	public static final String KIM_ATTRIB_ACTION_CLASS ="actionClass";	
-	public static final String KIM_ATTRIB_ACTION_REQUEST_TYPE_CODE ="actionRequestCd";		
-	public static final String KIM_ATTRIB_COMPONENT_CLASS ="componentClass";		
-	public static final String KIM_ATTRIB_ACTION_DETAILS_AT_ROLE_MEMBER_LEVEL ="actionDetailsAtRoleMemberLevel";	
-	public static final String KIM_ATTRIB_REQUIRED ="required";	
-	public static final String KIM_ATTRIB_BEAN_NAME ="beanName";	
-	public static final String KIM_ATTRIB_CAMPUS_CODE = "campusCode";
-	public static final String KIM_ATTRIB_TYPE_CODE ="typeCd";
-	public static final String KIM_ATTRIB_CREATED_SELF_ONLY ="createdBySelfOnly";	
+	public static final String KIM_ATTRIB_ACTION_CLASS ="actionClass";	
+	public static final String KIM_ATTRIB_ACTION_REQUEST_TYPE_CODE ="actionRequestCd";		
+	public static final String KIM_ATTRIB_COMPONENT_CLASS ="componentClass";		
+	public static final String KIM_ATTRIB_ACTION_DETAILS_AT_ROLE_MEMBER_LEVEL ="actionDetailsAtRoleMemberLevel";	
+	public static final String KIM_ATTRIB_REQUIRED ="required";	
+	public static final String KIM_ATTRIB_BEAN_NAME ="beanName";	
+	public static final String KIM_ATTRIB_CAMPUS_CODE = "campusCode";
+	public static final String KIM_ATTRIB_TYPE_CODE ="typeCd";
+	public static final String KIM_ATTRIB_CREATED_SELF_ONLY ="createdBySelfOnly";	
 	public static final String KIM_ATTRIB_NAMESPACE_CODE = "Namespace Code";
 	public static final String KIM_ATTRIB_DOCUMENT_TYPE_NAME = "name";
 	public static final String KIM_ATTRIB_ROUTE_STATUS_CODE = "docRouteStatus";
-	public static final String KIM_ATTRIB_ROUTE_NODE_NAME = "docRouteName";
-	public static final String KIM_ATTRIB_DOCUMENT_NUMBER = "documentNumber";
+	public static final String KIM_ATTRIB_ROUTE_NODE_NAME = "docRouteName";
+	public static final String KIM_ATTRIB_DOCUMENT_NUMBER = "documentNumber";
 	public static final String KIM_ATTRIB_PROPERTY_NAME = "propertyName";
-	public static final String KIM_ATTRIB_COMPONENT_NAME = "parameterDetailTypeCode";
+	public static final String KIM_ATTRIB_COMPONENT_NAME = "parameterDetailTypeCode";
 	public static final String KIM_ATTRIB_EXISTING_RECORDS_ONLY = "existingRecordsOnly";
-	public static final String KIM_ATTRIB_PARAMETER_NAME = "parameterName";
-	public static final String KIM_ATTRIB_PRINCIPAL_ID = "principalId";
+	public static final String KIM_ATTRIB_PARAMETER_NAME = "parameterName";
+	public static final String KIM_ATTRIB_PRINCIPAL_ID = "principalId";
 	public static final String KIM_ATTRIB_DESCEND_HIERARCHY = "descendHierarchy";
 	public static final String KIM_ATTRIB_ACTION_REQUEST_CODE = "actionRequestCd";
 	
 	public static final String KIM_ATTRIB_ACTION = "action";
+	public static final String KIM_ATTRIB_PRE_ROUTE  ="PreRoute";
 	public static final String KIM_ROLE_NAME_USER = "User";
 	public static final String KIM_ROLE_NAME_BILLER = "Biller";
 	public static final String KIM_ROLE_NAME_PROCESSOR = "Processor";	
@@ -87,8 +88,8 @@
 	
 	public static final String DEFAULT_PERMISSION_TYPE_SERVICE = "defaultPermissionTypeService";
 
-	public static final String KIM_AD_HOC  ="AdHoc";
 	
+	
 	@Deprecated
 	public static final String TEMP_GROUP_NAMESPACE = "KFS";
 	
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationControllerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationControllerBase.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationControllerBase.java	(revision 0)
@@ -0,0 +1,142 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.KualiConfigurationService;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+
+public class DocumentPresentationControllerBase implements DocumentPresentationController {
+    private static Log LOG = LogFactory.getLog(DocumentPresentationControllerBase.class);
+    
+  
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#getEdit(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canEdit(Document document){
+    	boolean canEdit = false;
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+        if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved() || workflowDocument.stateIsEnroute() || workflowDocument.stateIsException()) {
+        	canEdit = true; 
+        }
+        
+        return canEdit;
+    }
+    
+    
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canAnnotate(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canAnnotate(Document document){
+    	return canEdit(document);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canReload(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canReload(Document document){
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	return (canEdit(document) && !workflowDocument.stateIsInitiated()) ;
+             
+    }
+    
+    
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canClose(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canClose(Document document){
+    	return true;
+    }
+    
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canSave(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canSave(Document document){
+    	return canEdit(document);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canRoute(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canRoute(Document document){
+    	boolean canRoute = false;
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()){
+    		 canRoute = true;
+    	}
+    	return canRoute;
+    }
+        
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canCancel(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canCancel(Document document){
+    	return canEdit(document);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canCopy(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canCopy(Document document){
+    	 boolean canCopy = false;
+    	 if(document.getAllowsCopy()){
+    		 canCopy = true;
+    	 }
+    	 return canCopy;
+    }
+    
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canPerformRouteReport(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canPerformRouteReport(Document document){
+    	KualiConfigurationService kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+        return kualiConfigurationService.getIndicatorParameter( KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.SystemGroupParameterNames.DEFAULT_CAN_PERFORM_ROUTE_REPORT_IND);
+    }
+    
+   
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentPresentationController#canAdHocRoute(org.kuali.rice.kns.document.Document)
+     */
+    public boolean canAdHocRoute(Document document){
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+    	return (canEdit(document)&& !workflowDocument.stateIsException());
+    }
+    
+        
+}
Index: impl/src/main/resources/org/kuali/rice/kns/config/KNSSpringBeans.xml
===================================================================
--- impl/src/main/resources/org/kuali/rice/kns/config/KNSSpringBeans.xml	(revision 5571)
+++ impl/src/main/resources/org/kuali/rice/kns/config/KNSSpringBeans.xml	(working copy)
@@ -855,7 +855,11 @@
 	</bean>
 
     <bean id="documentTypePermissionTypeService" class="org.kuali.rice.kns.service.impl.DocumentTypePermissionTypeServiceImpl" />
-			
+    
+    <bean id="documentPresentationController" class="org.kuali.rice.kns.document.authorization.DocumentPresentationControllerBase" />
+    <bean id="maintenanceDocumentPresentationController" class="org.kuali.rice.kns.document.authorization.MaintenanceDocumentPresentationControllerBase" />
+	<bean id="transactionalDocumentPresentationController" class="org.kuali.rice.kns.document.authorization.TransactionalDocumentPresentationControllerBase" />
+					
   <!-- START JPA CONFIGURATION -->
 
   <!-- Used for @PersistenceContext auto-injection -->
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizerBase.java	(working copy)
@@ -1,54 +1,107 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.TransactionalDocument;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-
-/**
- * Base class for all TransactionalDocumentAuthorizers.
- */
-public class TransactionalDocumentAuthorizerBase extends DocumentAuthorizerBase implements TransactionalDocumentAuthorizer {
-    private static Log LOG = LogFactory.getLog(TransactionalDocumentAuthorizerBase.class);
-
-    /**
-     * Adds settings for transactional-document-specific flags.
-     * 
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#getDocumentActionFlags(Document, Person)
-     */
-    @Override
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-        LOG.debug("calling TransactionalDocumentAuthorizerBase.getDocumentActionFlags for document '" + document.getDocumentNumber() + "'. user '" + user.getPrincipalName() + "'");
-        TransactionalDocumentActionFlags flags = new TransactionalDocumentActionFlags(super.getDocumentActionFlags(document, user));
-
-        TransactionalDocument transactionalDocument = (TransactionalDocument) document;
-        KualiWorkflowDocument workflowDocument = transactionalDocument.getDocumentHeader().getWorkflowDocument();
-
-        if (!canCopy(workflowDocument.getDocumentType(), user)) {
-            flags.setCanCopy(false);
-            flags.setCanErrorCorrect(false);
-        }
-        else {
-            flags.setCanCopy(transactionalDocument.getAllowsCopy() && !workflowDocument.stateIsInitiated());
-            flags.setCanErrorCorrect(transactionalDocument.getAllowsErrorCorrection() && (workflowDocument.stateIsApproved() || workflowDocument.stateIsProcessed() || workflowDocument.stateIsFinal()));
-        }
-        return flags;
-    }
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Set;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kew.util.KEWConstants;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.TransactionalDocument;
+import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+
+/**
+ * Base class for all TransactionalDocumentAuthorizers.
+ */
+public class TransactionalDocumentAuthorizerBase extends DocumentAuthorizerBase implements TransactionalDocumentAuthorizer {
+    private static Log LOG = LogFactory.getLog(TransactionalDocumentAuthorizerBase.class);
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizerBase#getDocumentActionFlags(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+        TransactionalDocumentActionFlags flags = new TransactionalDocumentActionFlags(super.getDocumentActionFlags(document, user));
+
+        flags.setCanErrorCorrect(canErrorCorrect(document, user));
+      
+        return flags;
+
+    }
+    
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public void canInitiate(String documentTypeName, Person user) {
+    	
+    	String nameSpaceCode = "KR-SYS";
+    	
+    	AttributeSet permissionDetails = new AttributeSet();
+    	permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+    	
+        if(!getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_INITIATE_DOCUMENT, permissionDetails, null)){
+        	
+        	//TODO:
+        	// build authorized workgroup list for error message
+            Set authorizedWorkgroups = getAuthorizationService().getAuthorizedWorkgroups("initiate", documentTypeName);
+            String workgroupList = StringUtils.join(authorizedWorkgroups.toArray(), ",");
+            throw new DocumentInitiationAuthorizationException(new String[] {workgroupList,documentTypeName});
+        }
+    }
+    
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canAnnotate(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+     */
+    public boolean canErrorCorrect(Document document, Person user){
+    	 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+    	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_ERROR_CORRECT_DOCUMENT, permissionDetails, qualifications);
+	        	
+    }
+    
+    public boolean canUseEditMode(String editMode, Person user){
+    	String nameSpaceCode = "KR-NS"; 
+    	AttributeSet permissionDetails = new AttributeSet();
+	    permissionDetails.put(KimConstants.KIM_ATTRIB_EDIT_MODE, KEWConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ);
+	    
+	    return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_USE_TRANSACTIONAL_DOCUMENT, permissionDetails, null);
+	        	
+    }
+    
+
+}
Index: impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/web/struts/form/KualiMaintenanceForm.java	(working copy)
@@ -1,528 +1,535 @@
-/*
- * Copyright 2005-2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.web.struts.form;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.InvocationTargetException;
-import java.util.Enumeration;
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-import javax.servlet.http.HttpServletRequest;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.struts.upload.FormFile;
-import org.kuali.rice.core.config.ConfigurationException;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.bo.BusinessObject;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-import org.kuali.rice.kns.document.MaintenanceDocumentBase;
-import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
-import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
-import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
-import org.kuali.rice.kns.exception.UnknownDocumentTypeException;
-import org.kuali.rice.kns.maintenance.Maintainable;
-import org.kuali.rice.kns.service.DocumentAuthorizationService;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
-import org.kuali.rice.kns.util.FieldUtils;
-import org.kuali.rice.kns.util.GlobalVariables;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.util.ObjectUtils;
-import org.kuali.rice.kns.util.RiceKeyConstants;
-import org.kuali.rice.kns.web.format.FormatException;
-import org.kuali.rice.kns.web.format.Formatter;
-
-
-/**
- * This class is the base action form for all maintenance documents.
- * 
- * 
- */
-public class KualiMaintenanceForm extends KualiDocumentFormBase {
-    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KualiMaintenanceForm.class);
-
-    private static final long serialVersionUID = 1L;
-
-    private String businessObjectClassName;
-    private String description;
-    private boolean readOnly;
-    private Map oldMaintainableValues;
-    private Map newMaintainableValues;
-    private String maintenanceAction;
-    
-    /**
-     * Used to indicate which result set we're using when refreshing/returning from a multi-value lookup
-     */
-    private String lookupResultsSequenceNumber;
-    /**
-     * The type of result returned by the multi-value lookup
-     * 
-     * TODO: to be persisted in the lookup results service instead?
-     */
-    private String lookupResultsBOClassName;
-    
-    /**
-     * The name of the collection looked up (by a multiple value lookup)
-     */
-    private String lookedUpCollectionName;
-    
-    private MaintenanceDocumentAuthorizations authorizations;
-    
-    /**
-     * Override the default method to add the if statement which can't be called until after parameters from a multipart request
-     * have been made accessible, but which must be called before the parameter values are used to instantiate and populate business
-     * objects.
-     * 
-     * @param requestParameters
-     */
-    @Override
-    public void postprocessRequestParameters(Map requestParameters) {
-        super.postprocessRequestParameters(requestParameters);
-
-        String docTypeName = null;
-        String[] docTypeNames = (String[]) requestParameters.get(KNSConstants.DOCUMENT_TYPE_NAME);
-        if ((docTypeNames != null) && (docTypeNames.length > 0)) {
-            docTypeName = docTypeNames[0];
-        }
-
-        if (StringUtils.isNotBlank(docTypeName)) {          
-        	if(this.getDocument() == null){
-            setDocTypeName(docTypeName);
-            Class documentClass = KNSServiceLocator.getDataDictionaryService().getDocumentClassByTypeName(docTypeName);
-            if (documentClass == null) {
-                throw new UnknownDocumentTypeException("unable to get class for unknown documentTypeName '" + docTypeName + "'");
-            }
-            if (!MaintenanceDocumentBase.class.isAssignableFrom(documentClass)) {
-                throw new ConfigurationException("Document class '" + documentClass + "' is not assignable to '" + MaintenanceDocumentBase.class + "'");
-            }
-            Document document = null;
-            try {
-                Class[] defaultConstructor = new Class[]{String.class};
-                Constructor cons = documentClass.getConstructor(defaultConstructor);
-                if (ObjectUtils.isNull(cons)) {
-                    throw new ConfigurationException("Could not find constructor with document type name parameter needed for Maintenance Document Base class");
-                }
-                document = (Document) cons.newInstance(docTypeName);
-            } catch (SecurityException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (NoSuchMethodException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document: No constructor with String parameter found", e);
-            } catch (IllegalAccessException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (InstantiationException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (IllegalArgumentException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            } catch (InvocationTargetException e) {
-                throw new RuntimeException("Error instantiating Maintenance Document", e);
-            }
-            if (document == null) {
-                throw new RuntimeException("Unable to instantiate document with type name '" + docTypeName + "' and document class '" + documentClass + "'");
-            }
-            setDocument(document);
-          } 
-       }
-        
-        MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
-        
-        //Handling the Multi-Part Attachment
-        for ( Object obj : requestParameters.entrySet() ) {
-            String parameter = (String)((Map.Entry)obj).getKey(); 
-            if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-                String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-                Object propertyValue = requestParameters.get(parameter);
-                
-                if(propertyValue != null && propertyValue instanceof FormFile) {
-                    if(StringUtils.isNotEmpty(((FormFile)propertyValue).getFileName())) {
-                        maintenanceDocument.setFileAttachment((FormFile) propertyValue);
-                    }
-                    maintenanceDocument.setAttachmentPropertyName(propertyName);
-                }
-            }
-        }
-    }
-
-    /**
-     * Hook into populate so we can set the maintenance documents and feed the field values to its maintainables.
-     */
-    @Override
-    public void populate(HttpServletRequest request) {
-        super.populate(request);
-
-
-        // document type name is null on start, otherwise should be here
-        if (StringUtils.isNotBlank(getDocTypeName())) {
-            Map localOldMaintainableValues = new HashMap();
-            Map localNewMaintainableValues = new HashMap();
-            Map<String,String> localNewCollectionValues = new HashMap<String,String>();
-            for (Enumeration i = request.getParameterNames(); i.hasMoreElements();) {
-                String parameter = (String) i.nextElement();
-                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
-                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
-                    localOldMaintainableValues.put(propertyName, request.getParameter(parameter));
-                }
-                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-                    localNewMaintainableValues.put(propertyName, request.getParameter(parameter));
-                }
-            }
-            
-            // now, get all add lines and store them to a separate map
-            // for use in a separate call to the maintainable
-            for ( Object obj : localNewMaintainableValues.entrySet() ) {
-                String key = (String)((Map.Entry)obj).getKey(); 
-                if ( key.startsWith( KNSConstants.MAINTENANCE_ADD_PREFIX ) ) {
-                    localNewCollectionValues.put( key.substring( KNSConstants.MAINTENANCE_ADD_PREFIX.length() ),
-                            (String)((Map.Entry)obj).getValue() );
-                }
-            }
-            if ( LOG.isDebugEnabled() ) {
-                LOG.debug( "checked for add line parameters - got: " + localNewCollectionValues );
-            }
-            
-            this.newMaintainableValues = localNewMaintainableValues;
-            this.oldMaintainableValues = localOldMaintainableValues;
-
-            MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
-
-            GlobalVariables.getErrorMap().addToErrorPath("document.oldMaintainableObject");
-            maintenanceDocument.getOldMaintainableObject().populateBusinessObject(localOldMaintainableValues, maintenanceDocument);
-            GlobalVariables.getErrorMap().removeFromErrorPath("document.oldMaintainableObject");
-
-            GlobalVariables.getErrorMap().addToErrorPath("document.newMaintainableObject");
-            // update the main object
-            Map cachedValues = 
-            	maintenanceDocument.getNewMaintainableObject().populateBusinessObject(localNewMaintainableValues, maintenanceDocument);
-            
-            if(maintenanceDocument.getFileAttachment() != null) {
-                populateAttachmentPropertyForBO(maintenanceDocument);
-            }
-            
-            // update add lines
-            localNewCollectionValues = org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().resolvePrincipalNamesToPrincipalIds((BusinessObject)maintenanceDocument.getNewMaintainableObject().getBusinessObject(), localNewCollectionValues);
-            cachedValues.putAll( maintenanceDocument.getNewMaintainableObject().populateNewCollectionLines( localNewCollectionValues ) );
-            GlobalVariables.getErrorMap().removeFromErrorPath("document.newMaintainableObject");
-
-            if (cachedValues.size() > 0) {
-                GlobalVariables.getErrorMap().putError(KNSConstants.DOCUMENT_ERRORS, RiceKeyConstants.ERROR_DOCUMENT_MAINTENANCE_FORMATTING_ERROR);
-                for (Iterator iter = cachedValues.keySet().iterator(); iter.hasNext();) {
-                    String propertyName = (String) iter.next();
-                    String value = (String) cachedValues.get(propertyName);
-                    cacheUnconvertedValue(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE + propertyName, value);
-                }
-            }
-        }
-    }
-
-    private void populateAttachmentPropertyForBO(MaintenanceDocumentBase maintenanceDocument) {
-        try {
-            Class type = ObjectUtils.easyGetPropertyType(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName());
-            ObjectUtils.setObjectProperty(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName(), type, maintenanceDocument.getFileAttachment());
-        } catch (FormatException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (IllegalAccessException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (NoSuchMethodException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        } catch (InvocationTargetException e) {
-            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
-        }
-    }
-    
-    /**
-     * Merges rows of old and new for each section (tab) of the ui. Also, renames fields to prevent naming conflicts and does
-     * setting of read only fields.
-     * 
-     * @return Returns the maintenanceSections.
-     */
-    public List getSections() {
-        if (getDocument() == null) {
-            throw new RuntimeException("Document not set in maintenance form.");
-        }
-        if (((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject() == null) {
-            throw new RuntimeException("New maintainable not set in document.");
-        }
-        if ((KNSConstants.MAINTENANCE_EDIT_ACTION.equals(this.getMaintenanceAction()) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(this.getMaintenanceAction())) && ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject() == null) {
-            throw new RuntimeException("Old maintainable not set in document.");
-        }
-
-        // if the authorization stuff hasnt been applied yet, then apply it
-        if (authorizations == null) {
-            applyAuthorizations();
-        }
-
-        // get business object being maintained and its keys
-        List keyFieldNames = KNSServiceLocator.getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject().getBusinessObject().getClass());
-
-        // sections for maintenance document
-        Maintainable oldMaintainable = ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject();
-        oldMaintainable.setMaintenanceAction(getMaintenanceAction());
-        List oldMaintSections = oldMaintainable.getSections(null);
-        
-        Maintainable newMaintainable = ((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject();
-        newMaintainable.setMaintenanceAction(getMaintenanceAction());
-        List newMaintSections = newMaintainable.getSections(oldMaintainable);
-
-        // mesh sections for proper jsp display
-        List meshedSections = FieldUtils.meshSections(oldMaintSections, newMaintSections, keyFieldNames, getMaintenanceAction(), isReadOnly(), authorizations);
-
-        return meshedSections;
-    }
-
-    protected void applyAuthorizations() {
-        Document document = getDocument();
-        DocumentAuthorizationService docAuthService = KNSServiceLocator.getDocumentAuthorizationService();
-        DocumentAuthorizer documentAuthorizer = docAuthService.getDocumentAuthorizer(document);
-        useDocumentAuthorizer(documentAuthorizer);
-    }
-
-    @Override
-    protected void useDocumentAuthorizer(DocumentAuthorizer documentAuthorizer) {
-
-        // init some things we'll need
-        Person kualiUser = GlobalVariables.getUserSession().getPerson();
-        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) getDocument();
-        MaintenanceDocumentAuthorizer maintenanceDocumentAuthorizer = (MaintenanceDocumentAuthorizer) documentAuthorizer;
-
-        // set the overall document editing mode
-        setEditingMode(documentAuthorizer.getEditMode(maintenanceDocument, kualiUser ));
-
-        // WHY IS THIS READONLY STUFF HERE YOU ASK, GIVEN THE EDITMODE
-        //
-        // Thats a good question. It's basically just there to make the proper generation
-        // of UI stuff in the JSP code easier, as you can just set a simple var on the jsp
-        // with the isReadOnly property.
-        //
-        // ITS IMPORTANT TO NOTE that the readOnly flag is ALWAYS dependent on the EditingMode
-        // data. So EditingMode is authoritative, readOnly is there for convenience.
-        //
-
-        // set the readOnly flag for this document, default to readOnly = true
-        setReadOnly(true);
-        String editMode;
-        editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY);
-        if ("TRUE".equalsIgnoreCase(editMode)) {
-            setReadOnly(false);
-        }
-        editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY);
-        if ("TRUE".equalsIgnoreCase(editMode)) {
-            setReadOnly(false);
-        }
-
-        // set field permissions
-        setAuthorizations(maintenanceDocumentAuthorizer.getFieldAuthorizations(maintenanceDocument, kualiUser));
-
-        // set the overall document action flags
-        setDocumentActionFlags(maintenanceDocumentAuthorizer.getDocumentActionFlags(maintenanceDocument, kualiUser));
-    }
-
-    /**
-     * @return Returns the maintenanceAction.
-     */
-    public String getMaintenanceAction() {
-        return maintenanceAction;
-    }
-
-    /**
-     * @return Returns the businessObjectClassName.
-     */
-    public String getBusinessObjectClassName() {
-        return businessObjectClassName;
-    }
-
-    /**
-     * @param businessObjectClassName The businessObjectClassName to set.
-     */
-    public void setBusinessObjectClassName(String businessObjectClassName) {
-        this.businessObjectClassName = businessObjectClassName;
-    }
-
-    /**
-     * @return Returns the description.
-     */
-    public String getDescription() {
-        return description;
-    }
-
-    /**
-     * @param description The description to set.
-     */
-    public void setDescription(String description) {
-        this.description = description;
-    }
-
-    /**
-     * @return Returns the isReadOnly.
-     */
-    public boolean isReadOnly() {
-        return readOnly;
-    }
-
-    /**
-     * @param readOnly The isReadOnly to set.
-     */
-    public void setReadOnly(boolean readOnly) {
-        this.readOnly = readOnly;
-    }
-
-    /**
-     * @return Returns the newMaintainableValues.
-     */
-    public Map getNewMaintainableValues() {
-        return newMaintainableValues;
-    }
-
-    /**
-     * @return Returns the oldMaintainableValues.
-     */
-    public Map getOldMaintainableValues() {
-        return oldMaintainableValues;
-    }
-
-    /**
-     * @param maintenanceAction The maintenanceAction to set.
-     */
-    public void setMaintenanceAction(String maintenanceAction) {
-        this.maintenanceAction = maintenanceAction;
-    }
-
-    /**
-     * Gets the authorizations attribute.
-     * 
-     * @return Returns the authorizations.
-     */
-    public MaintenanceDocumentAuthorizations getAuthorizations() {
-        return authorizations;
-    }
-
-    /**
-     * Sets the authorizations attribute value.
-     * 
-     * @param authorizations The authorizations to set.
-     */
-    public void setAuthorizations(MaintenanceDocumentAuthorizations authorizations) {
-        this.authorizations = authorizations;
-    }
-
-    /**
-     * Sets the newMaintainableValues attribute value.
-     * 
-     * @param newMaintainableValues The newMaintainableValues to set.
-     */
-    public void setNewMaintainableValues(Map newMaintainableValues) {
-        this.newMaintainableValues = newMaintainableValues;
-    }
-
-
-    /**
-     * Sets the oldMaintainableValues attribute value.
-     * 
-     * @param oldMaintainableValues The oldMaintainableValues to set.
-     */
-    public void setOldMaintainableValues(Map oldMaintainableValues) {
-        this.oldMaintainableValues = oldMaintainableValues;
-    }
-
-
-    public String getLookupResultsSequenceNumber() {
-        return lookupResultsSequenceNumber;
-    }
-
-
-    public void setLookupResultsSequenceNumber(String lookupResultsSequenceNumber) {
-        this.lookupResultsSequenceNumber = lookupResultsSequenceNumber;
-    }
-
-
-    public String getLookupResultsBOClassName() {
-        return lookupResultsBOClassName;
-    }
-
-
-    public void setLookupResultsBOClassName(String lookupResultsBOClassName) {
-        this.lookupResultsBOClassName = lookupResultsBOClassName;
-    }
-
-
-    public String getLookedUpCollectionName() {
-        return lookedUpCollectionName;
-    }
-
-
-    public void setLookedUpCollectionName(String lookedUpCollectionName) {
-        this.lookedUpCollectionName = lookedUpCollectionName;
-    }
-
-    public String getAdditionalSectionsFile() {
-        if ( businessObjectClassName != null ) {
-            try {
-                MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-                String docTypeName = maintenanceDocumentDictionaryService.getDocumentTypeName(Class.forName(businessObjectClassName));
-                return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(businessObjectClassName).getAdditionalSectionsFile();
-            } catch ( ClassNotFoundException ex ) {
-                LOG.error( "Unable to resolve business object class", ex);
-            }
-        }else{
-            MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
-            return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(this.getDocTypeName()).getAdditionalSectionsFile();
-        }
-        return null;
-    }
-
-	/**
-	 * This overridden method handles the case where maint doc properties do not reflect the true nature of the 
-	 * 
-	 * @see org.kuali.rice.kns.web.struts.form.KualiForm#retrieveFormValueForLookupInquiryParameters(java.lang.String, java.lang.String)
-	 */
-	@Override
-	public String retrieveFormValueForLookupInquiryParameters(String parameterName, String parameterValueLocation) {
-		MaintenanceDocument maintDoc = (MaintenanceDocument) getDocument();
-		if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
-            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
-            if (maintDoc.getOldMaintainableObject() != null && maintDoc.getOldMaintainableObject().getBusinessObject() != null) {
-            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getOldMaintainableObject().getBusinessObject(), propertyName);
-            	if (parameterValue == null) {
-            		return null;
-            	}
-            	if (parameterValue instanceof String) {
-            		return (String) parameterValue;
-            	}
-            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
-        		return (String) formatter.format(parameterValue);	
-            }
-        }
-        if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
-            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
-            if (maintDoc.getNewMaintainableObject() != null && maintDoc.getNewMaintainableObject().getBusinessObject() != null) {
-            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getNewMaintainableObject().getBusinessObject(), propertyName);
-            	if (parameterValue == null) {
-            		return null;
-            	}
-            	if (parameterValue instanceof String) {
-            		return (String) parameterValue;
-            	}
-            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
-        		return (String) formatter.format(parameterValue);	
-            }
-        }
-		return super.retrieveFormValueForLookupInquiryParameters(parameterName, parameterValueLocation);
-	}
-}
+/*
+ * Copyright 2005-2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.web.struts.form;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.InvocationTargetException;
+import java.util.Enumeration;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.lang.StringUtils;
+import org.apache.struts.upload.FormFile;
+import org.kuali.rice.core.config.ConfigurationException;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.bo.BusinessObject;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+import org.kuali.rice.kns.document.MaintenanceDocumentBase;
+import org.kuali.rice.kns.document.authorization.DocumentAuthorizer;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizations;
+import org.kuali.rice.kns.document.authorization.MaintenanceDocumentAuthorizer;
+import org.kuali.rice.kns.exception.UnknownDocumentTypeException;
+import org.kuali.rice.kns.maintenance.Maintainable;
+import org.kuali.rice.kns.service.DocumentAuthorizationService;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+import org.kuali.rice.kns.util.FieldUtils;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.util.RiceKeyConstants;
+import org.kuali.rice.kns.web.format.FormatException;
+import org.kuali.rice.kns.web.format.Formatter;
+
+
+/**
+ * This class is the base action form for all maintenance documents.
+ * 
+ * 
+ */
+public class KualiMaintenanceForm extends KualiDocumentFormBase {
+    private static final org.apache.log4j.Logger LOG = org.apache.log4j.Logger.getLogger(KualiMaintenanceForm.class);
+
+    private static final long serialVersionUID = 1L;
+
+    private String businessObjectClassName;
+    private String description;
+    private boolean readOnly;
+    private Map oldMaintainableValues;
+    private Map newMaintainableValues;
+    private String maintenanceAction;
+    
+    /**
+     * Used to indicate which result set we're using when refreshing/returning from a multi-value lookup
+     */
+    private String lookupResultsSequenceNumber;
+    /**
+     * The type of result returned by the multi-value lookup
+     * 
+     * TODO: to be persisted in the lookup results service instead?
+     */
+    private String lookupResultsBOClassName;
+    
+    /**
+     * The name of the collection looked up (by a multiple value lookup)
+     */
+    private String lookedUpCollectionName;
+    
+    private MaintenanceDocumentAuthorizations authorizations;
+    
+    /**
+     * Override the default method to add the if statement which can't be called until after parameters from a multipart request
+     * have been made accessible, but which must be called before the parameter values are used to instantiate and populate business
+     * objects.
+     * 
+     * @param requestParameters
+     */
+    @Override
+    public void postprocessRequestParameters(Map requestParameters) {
+        super.postprocessRequestParameters(requestParameters);
+
+        String docTypeName = null;
+        String[] docTypeNames = (String[]) requestParameters.get(KNSConstants.DOCUMENT_TYPE_NAME);
+        if ((docTypeNames != null) && (docTypeNames.length > 0)) {
+            docTypeName = docTypeNames[0];
+        }
+
+        if (StringUtils.isNotBlank(docTypeName)) {          
+        	if(this.getDocument() == null){
+            setDocTypeName(docTypeName);
+            Class documentClass = KNSServiceLocator.getDataDictionaryService().getDocumentClassByTypeName(docTypeName);
+            if (documentClass == null) {
+                throw new UnknownDocumentTypeException("unable to get class for unknown documentTypeName '" + docTypeName + "'");
+            }
+            if (!MaintenanceDocumentBase.class.isAssignableFrom(documentClass)) {
+                throw new ConfigurationException("Document class '" + documentClass + "' is not assignable to '" + MaintenanceDocumentBase.class + "'");
+            }
+            Document document = null;
+            try {
+                Class[] defaultConstructor = new Class[]{String.class};
+                Constructor cons = documentClass.getConstructor(defaultConstructor);
+                if (ObjectUtils.isNull(cons)) {
+                    throw new ConfigurationException("Could not find constructor with document type name parameter needed for Maintenance Document Base class");
+                }
+                document = (Document) cons.newInstance(docTypeName);
+            } catch (SecurityException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (NoSuchMethodException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document: No constructor with String parameter found", e);
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (InstantiationException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (IllegalArgumentException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            } catch (InvocationTargetException e) {
+                throw new RuntimeException("Error instantiating Maintenance Document", e);
+            }
+            if (document == null) {
+                throw new RuntimeException("Unable to instantiate document with type name '" + docTypeName + "' and document class '" + documentClass + "'");
+            }
+            setDocument(document);
+          } 
+       }
+        
+        MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
+        
+        //Handling the Multi-Part Attachment
+        for ( Object obj : requestParameters.entrySet() ) {
+            String parameter = (String)((Map.Entry)obj).getKey(); 
+            if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+                String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+                Object propertyValue = requestParameters.get(parameter);
+                
+                if(propertyValue != null && propertyValue instanceof FormFile) {
+                    if(StringUtils.isNotEmpty(((FormFile)propertyValue).getFileName())) {
+                        maintenanceDocument.setFileAttachment((FormFile) propertyValue);
+                    }
+                    maintenanceDocument.setAttachmentPropertyName(propertyName);
+                }
+            }
+        }
+    }
+
+    /**
+     * Hook into populate so we can set the maintenance documents and feed the field values to its maintainables.
+     */
+    @Override
+    public void populate(HttpServletRequest request) {
+        super.populate(request);
+
+
+        // document type name is null on start, otherwise should be here
+        if (StringUtils.isNotBlank(getDocTypeName())) {
+            Map localOldMaintainableValues = new HashMap();
+            Map localNewMaintainableValues = new HashMap();
+            Map<String,String> localNewCollectionValues = new HashMap<String,String>();
+            for (Enumeration i = request.getParameterNames(); i.hasMoreElements();) {
+                String parameter = (String) i.nextElement();
+                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
+                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+                    localOldMaintainableValues.put(propertyName, request.getParameter(parameter));
+                }
+                if (parameter.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+                    String propertyName = parameter.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+                    localNewMaintainableValues.put(propertyName, request.getParameter(parameter));
+                }
+            }
+            
+            // now, get all add lines and store them to a separate map
+            // for use in a separate call to the maintainable
+            for ( Object obj : localNewMaintainableValues.entrySet() ) {
+                String key = (String)((Map.Entry)obj).getKey(); 
+                if ( key.startsWith( KNSConstants.MAINTENANCE_ADD_PREFIX ) ) {
+                    localNewCollectionValues.put( key.substring( KNSConstants.MAINTENANCE_ADD_PREFIX.length() ),
+                            (String)((Map.Entry)obj).getValue() );
+                }
+            }
+            if ( LOG.isDebugEnabled() ) {
+                LOG.debug( "checked for add line parameters - got: " + localNewCollectionValues );
+            }
+            
+            this.newMaintainableValues = localNewMaintainableValues;
+            this.oldMaintainableValues = localOldMaintainableValues;
+
+            MaintenanceDocumentBase maintenanceDocument = (MaintenanceDocumentBase) getDocument();
+
+            GlobalVariables.getErrorMap().addToErrorPath("document.oldMaintainableObject");
+            maintenanceDocument.getOldMaintainableObject().populateBusinessObject(localOldMaintainableValues, maintenanceDocument);
+            GlobalVariables.getErrorMap().removeFromErrorPath("document.oldMaintainableObject");
+
+            GlobalVariables.getErrorMap().addToErrorPath("document.newMaintainableObject");
+            // update the main object
+            Map cachedValues = 
+            	maintenanceDocument.getNewMaintainableObject().populateBusinessObject(localNewMaintainableValues, maintenanceDocument);
+            
+            if(maintenanceDocument.getFileAttachment() != null) {
+                populateAttachmentPropertyForBO(maintenanceDocument);
+            }
+            
+            // update add lines
+            localNewCollectionValues = org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().resolvePrincipalNamesToPrincipalIds((BusinessObject)maintenanceDocument.getNewMaintainableObject().getBusinessObject(), localNewCollectionValues);
+            cachedValues.putAll( maintenanceDocument.getNewMaintainableObject().populateNewCollectionLines( localNewCollectionValues ) );
+            GlobalVariables.getErrorMap().removeFromErrorPath("document.newMaintainableObject");
+
+            if (cachedValues.size() > 0) {
+                GlobalVariables.getErrorMap().putError(KNSConstants.DOCUMENT_ERRORS, RiceKeyConstants.ERROR_DOCUMENT_MAINTENANCE_FORMATTING_ERROR);
+                for (Iterator iter = cachedValues.keySet().iterator(); iter.hasNext();) {
+                    String propertyName = (String) iter.next();
+                    String value = (String) cachedValues.get(propertyName);
+                    cacheUnconvertedValue(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE + propertyName, value);
+                }
+            }
+        }
+    }
+
+    private void populateAttachmentPropertyForBO(MaintenanceDocumentBase maintenanceDocument) {
+        try {
+            Class type = ObjectUtils.easyGetPropertyType(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName());
+            ObjectUtils.setObjectProperty(maintenanceDocument.getNewMaintainableObject().getBusinessObject(), maintenanceDocument.getAttachmentPropertyName(), type, maintenanceDocument.getFileAttachment());
+        } catch (FormatException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (IllegalAccessException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (NoSuchMethodException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        } catch (InvocationTargetException e) {
+            throw new RuntimeException("Exception occurred while setting attachment property on NewMaintainable bo", e);
+        }
+    }
+    
+    /**
+     * Merges rows of old and new for each section (tab) of the ui. Also, renames fields to prevent naming conflicts and does
+     * setting of read only fields.
+     * 
+     * @return Returns the maintenanceSections.
+     */
+    public List getSections() {
+        if (getDocument() == null) {
+            throw new RuntimeException("Document not set in maintenance form.");
+        }
+        if (((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject() == null) {
+            throw new RuntimeException("New maintainable not set in document.");
+        }
+        if ((KNSConstants.MAINTENANCE_EDIT_ACTION.equals(this.getMaintenanceAction()) || KNSConstants.MAINTENANCE_COPY_ACTION.equals(this.getMaintenanceAction())) && ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject() == null) {
+            throw new RuntimeException("Old maintainable not set in document.");
+        }
+
+        // if the authorization stuff hasnt been applied yet, then apply it
+        if (authorizations == null) {
+            applyAuthorizations();
+        }
+
+        // get business object being maintained and its keys
+        List keyFieldNames = KNSServiceLocator.getBusinessObjectMetaDataService().listPrimaryKeyFieldNames(((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject().getBusinessObject().getClass());
+
+        // sections for maintenance document
+        Maintainable oldMaintainable = ((MaintenanceDocumentBase) getDocument()).getOldMaintainableObject();
+        oldMaintainable.setMaintenanceAction(getMaintenanceAction());
+        List oldMaintSections = oldMaintainable.getSections(null);
+        
+        Maintainable newMaintainable = ((MaintenanceDocumentBase) getDocument()).getNewMaintainableObject();
+        newMaintainable.setMaintenanceAction(getMaintenanceAction());
+        List newMaintSections = newMaintainable.getSections(oldMaintainable);
+
+        // mesh sections for proper jsp display
+        List meshedSections = FieldUtils.meshSections(oldMaintSections, newMaintSections, keyFieldNames, getMaintenanceAction(), isReadOnly(), authorizations);
+
+        return meshedSections;
+    }
+
+    protected void applyAuthorizations() {
+        Document document = getDocument();
+        DocumentAuthorizationService docAuthService = KNSServiceLocator.getDocumentAuthorizationService();
+        DocumentAuthorizer documentAuthorizer = docAuthService.getDocumentAuthorizer(document);
+        useDocumentAuthorizer(documentAuthorizer);
+    }
+
+    @Override
+    protected void useDocumentAuthorizer(DocumentAuthorizer documentAuthorizer) {
+
+        // init some things we'll need
+        Person kualiUser = GlobalVariables.getUserSession().getPerson();
+        MaintenanceDocument maintenanceDocument = (MaintenanceDocument) getDocument();
+        MaintenanceDocumentAuthorizer maintenanceDocumentAuthorizer = (MaintenanceDocumentAuthorizer) documentAuthorizer;
+
+        // set the overall document editing mode
+        //setEditingMode(documentAuthorizer.getEditMode(maintenanceDocument, kualiUser ));
+
+        // WHY IS THIS READONLY STUFF HERE YOU ASK, GIVEN THE EDITMODE
+        //
+        // Thats a good question. It's basically just there to make the proper generation
+        // of UI stuff in the JSP code easier, as you can just set a simple var on the jsp
+        // with the isReadOnly property.
+        //
+        // ITS IMPORTANT TO NOTE that the readOnly flag is ALWAYS dependent on the EditingMode
+        // data. So EditingMode is authoritative, readOnly is there for convenience.
+        //        
+        //String editMode;
+        //editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.APPROVER_EDIT_ENTRY);
+        //if ("TRUE".equalsIgnoreCase(editMode)) {
+        //    setReadOnly(false);
+        //}
+        //editMode = (String) editingMode.get(AuthorizationConstants.MaintenanceEditMode.FULL_ENTRY);
+        //if ("TRUE".equalsIgnoreCase(editMode)) {
+        //    setReadOnly(false);
+        //}
+
+        // set the readOnly flag for this document, default to readOnly = true
+        setReadOnly(true);
+        
+        // Check overall document edit permission
+        if(maintenanceDocumentAuthorizer.canEdit(getDocument(), kualiUser)){
+        	setReadOnly(false);
+        }
+        
+        // set field permissions
+        setAuthorizations(maintenanceDocumentAuthorizer.getFieldAuthorizations(maintenanceDocument, kualiUser));
+
+        // set the overall document action flags
+        setDocumentActionFlags(maintenanceDocumentAuthorizer.getDocumentActionFlags(maintenanceDocument, kualiUser));
+    }
+
+    /**
+     * @return Returns the maintenanceAction.
+     */
+    public String getMaintenanceAction() {
+        return maintenanceAction;
+    }
+
+    /**
+     * @return Returns the businessObjectClassName.
+     */
+    public String getBusinessObjectClassName() {
+        return businessObjectClassName;
+    }
+
+    /**
+     * @param businessObjectClassName The businessObjectClassName to set.
+     */
+    public void setBusinessObjectClassName(String businessObjectClassName) {
+        this.businessObjectClassName = businessObjectClassName;
+    }
+
+    /**
+     * @return Returns the description.
+     */
+    public String getDescription() {
+        return description;
+    }
+
+    /**
+     * @param description The description to set.
+     */
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    /**
+     * @return Returns the isReadOnly.
+     */
+    public boolean isReadOnly() {
+        return readOnly;
+    }
+
+    /**
+     * @param readOnly The isReadOnly to set.
+     */
+    public void setReadOnly(boolean readOnly) {
+        this.readOnly = readOnly;
+    }
+
+    /**
+     * @return Returns the newMaintainableValues.
+     */
+    public Map getNewMaintainableValues() {
+        return newMaintainableValues;
+    }
+
+    /**
+     * @return Returns the oldMaintainableValues.
+     */
+    public Map getOldMaintainableValues() {
+        return oldMaintainableValues;
+    }
+
+    /**
+     * @param maintenanceAction The maintenanceAction to set.
+     */
+    public void setMaintenanceAction(String maintenanceAction) {
+        this.maintenanceAction = maintenanceAction;
+    }
+
+    /**
+     * Gets the authorizations attribute.
+     * 
+     * @return Returns the authorizations.
+     */
+    public MaintenanceDocumentAuthorizations getAuthorizations() {
+        return authorizations;
+    }
+
+    /**
+     * Sets the authorizations attribute value.
+     * 
+     * @param authorizations The authorizations to set.
+     */
+    public void setAuthorizations(MaintenanceDocumentAuthorizations authorizations) {
+        this.authorizations = authorizations;
+    }
+
+    /**
+     * Sets the newMaintainableValues attribute value.
+     * 
+     * @param newMaintainableValues The newMaintainableValues to set.
+     */
+    public void setNewMaintainableValues(Map newMaintainableValues) {
+        this.newMaintainableValues = newMaintainableValues;
+    }
+
+
+    /**
+     * Sets the oldMaintainableValues attribute value.
+     * 
+     * @param oldMaintainableValues The oldMaintainableValues to set.
+     */
+    public void setOldMaintainableValues(Map oldMaintainableValues) {
+        this.oldMaintainableValues = oldMaintainableValues;
+    }
+
+
+    public String getLookupResultsSequenceNumber() {
+        return lookupResultsSequenceNumber;
+    }
+
+
+    public void setLookupResultsSequenceNumber(String lookupResultsSequenceNumber) {
+        this.lookupResultsSequenceNumber = lookupResultsSequenceNumber;
+    }
+
+
+    public String getLookupResultsBOClassName() {
+        return lookupResultsBOClassName;
+    }
+
+
+    public void setLookupResultsBOClassName(String lookupResultsBOClassName) {
+        this.lookupResultsBOClassName = lookupResultsBOClassName;
+    }
+
+
+    public String getLookedUpCollectionName() {
+        return lookedUpCollectionName;
+    }
+
+
+    public void setLookedUpCollectionName(String lookedUpCollectionName) {
+        this.lookedUpCollectionName = lookedUpCollectionName;
+    }
+
+    public String getAdditionalSectionsFile() {
+        if ( businessObjectClassName != null ) {
+            try {
+                MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+                String docTypeName = maintenanceDocumentDictionaryService.getDocumentTypeName(Class.forName(businessObjectClassName));
+                return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(businessObjectClassName).getAdditionalSectionsFile();
+            } catch ( ClassNotFoundException ex ) {
+                LOG.error( "Unable to resolve business object class", ex);
+            }
+        }else{
+            MaintenanceDocumentDictionaryService maintenanceDocumentDictionaryService = KNSServiceLocator.getMaintenanceDocumentDictionaryService();
+            return maintenanceDocumentDictionaryService.getMaintenanceDocumentEntry(this.getDocTypeName()).getAdditionalSectionsFile();
+        }
+        return null;
+    }
+
+	/**
+	 * This overridden method handles the case where maint doc properties do not reflect the true nature of the 
+	 * 
+	 * @see org.kuali.rice.kns.web.struts.form.KualiForm#retrieveFormValueForLookupInquiryParameters(java.lang.String, java.lang.String)
+	 */
+	@Override
+	public String retrieveFormValueForLookupInquiryParameters(String parameterName, String parameterValueLocation) {
+		MaintenanceDocument maintDoc = (MaintenanceDocument) getDocument();
+		if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.toUpperCase())) {
+            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_OLD_MAINTAINABLE.length());
+            if (maintDoc.getOldMaintainableObject() != null && maintDoc.getOldMaintainableObject().getBusinessObject() != null) {
+            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getOldMaintainableObject().getBusinessObject(), propertyName);
+            	if (parameterValue == null) {
+            		return null;
+            	}
+            	if (parameterValue instanceof String) {
+            		return (String) parameterValue;
+            	}
+            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
+        		return (String) formatter.format(parameterValue);	
+            }
+        }
+        if (parameterValueLocation.toUpperCase().startsWith(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.toUpperCase())) {
+            String propertyName = parameterValueLocation.substring(KNSConstants.MAINTENANCE_NEW_MAINTAINABLE.length());
+            if (maintDoc.getNewMaintainableObject() != null && maintDoc.getNewMaintainableObject().getBusinessObject() != null) {
+            	Object parameterValue = ObjectUtils.getPropertyValue(maintDoc.getNewMaintainableObject().getBusinessObject(), propertyName);
+            	if (parameterValue == null) {
+            		return null;
+            	}
+            	if (parameterValue instanceof String) {
+            		return (String) parameterValue;
+            	}
+            	Formatter formatter = Formatter.getFormatter(parameterValue.getClass());
+        		return (String) formatter.format(parameterValue);	
+            }
+        }
+		return super.retrieveFormValueForLookupInquiryParameters(parameterName, parameterValueLocation);
+	}
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationControllerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationControllerBase.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentPresentationControllerBase.java	(revision 0)
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kns.datadictionary.MaintainableCollectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableFieldDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableItemDefinition;
+import org.kuali.rice.kns.datadictionary.MaintainableSectionDefinition;
+import org.kuali.rice.kns.datadictionary.MaintenanceDocumentEntry;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.service.MaintenanceDocumentDictionaryService;
+
+/**
+ * Base class for all MaintenanceDocumentPresentationControllers.
+ */
+public class MaintenanceDocumentPresentationControllerBase extends DocumentPresentationControllerBase implements MaintenanceDocumentPresentationController {
+    private static Log LOG = LogFactory.getLog(MaintenanceDocumentPresentationControllerBase.class);
+
+    private static MaintenanceDocumentDictionaryService  maintenanceDocumentDictionaryService;
+    
+	/**
+	 * 
+	 * @param document
+	 * @return
+	 */
+	public List getReadOnlyFields(Document document){
+		List<MaintainableFieldDefinition> readOnlyFields = new ArrayList();
+		
+		String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+
+    	MaintenanceDocumentEntry objectEntry = getMaintenanceDocumentDictionaryService().getMaintenanceDocumentEntry(documentType);
+    	
+    	List<MaintainableSectionDefinition> maintainableSectionDefinitions = objectEntry.getMaintainableSections();
+		for (MaintainableSectionDefinition maintainableSectionDefinition : maintainableSectionDefinitions) {
+			List<MaintainableItemDefinition> maintainableItems = maintainableSectionDefinition.getMaintainableItems();
+			
+			readOnlyFields.addAll(getReadOnlyFieldList(readOnlyFields,maintainableItems));
+			
+		}
+		return readOnlyFields;
+	}
+	
+	private static List<MaintainableFieldDefinition> getReadOnlyFieldList(
+			List<MaintainableFieldDefinition> returnList, List items) {
+		
+		for (Object item: items) {
+			if (item instanceof MaintainableFieldDefinition) {
+				MaintainableFieldDefinition maintainableFieldDefinition = (MaintainableFieldDefinition) item;
+				
+				if(maintainableFieldDefinition.isUnconditionallyReadOnly()){
+					returnList.add(maintainableFieldDefinition);
+				}
+			} else if (item instanceof MaintainableCollectionDefinition) {
+				MaintainableCollectionDefinition maintainableCollectionDefinition = (MaintainableCollectionDefinition) item;
+				getReadOnlyFieldList(
+						returnList,
+						maintainableCollectionDefinition.getMaintainableCollections());
+				getReadOnlyFieldList(
+						returnList,
+						maintainableCollectionDefinition.getMaintainableFields());
+			}
+		}
+		return returnList;
+	}
+
+	/**
+	 * @return the maintenanceDocumentDictionaryService
+	 */
+	public static MaintenanceDocumentDictionaryService getMaintenanceDocumentDictionaryService() {
+		return maintenanceDocumentDictionaryService;
+	}
+	
+	
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/MaintenanceDocumentAuthorizer.java	(working copy)
@@ -1,40 +1,44 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.MaintenanceDocument;
-
-/**
- * Extension to DocumentAuthorizer for Maintenance Document specific methods
- * 
- * 
- */
-public interface MaintenanceDocumentAuthorizer extends DocumentAuthorizer {
-
-    /**
-     * 
-     * This method returns the set of authorization restrictions (if any) that apply to this object in this context.
-     * 
-     * @param document
-     * @param user
-     * @return MaintenanceDocumentAuthorizations
-     * 
-     */
-    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
-
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.document.MaintenanceDocument;
+
+/**
+ * Extension to DocumentAuthorizer for Maintenance Document specific methods
+ * 
+ * 
+ */
+public interface MaintenanceDocumentAuthorizer extends DocumentAuthorizer {
+
+    /**
+     * 
+     * This method returns the set of authorization restrictions (if any) that apply to this object in this context.
+     * 
+     * @param document
+     * @param user
+     * @return MaintenanceDocumentAuthorizations
+     * 
+     */
+    public MaintenanceDocumentAuthorizations getFieldAuthorizations(MaintenanceDocument document, Person user);
+    
+   
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationController.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationController.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationController.java	(revision 0)
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentPresentationController class is used for non-user related lock down 
+ * 
+ * 
+ */
+public interface TransactionalDocumentPresentationController extends DocumentPresentationController {
+	 /**
+     * @param document
+     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
+     *         allowed to take on that document.
+     */
+    public Map getEditMode(Document document);
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationController.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationController.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentPresentationController.java	(revision 0)
@@ -0,0 +1,96 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentPresentationController class is used for non-user related lock down 
+ * 
+ * 
+ */
+public interface DocumentPresentationController {
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be edited 
+     */
+    public boolean canEdit(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be annotated
+     */
+    public boolean canAnnotate(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be reloaded
+     */
+    public boolean canReload(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be closed
+     */
+    public boolean canClose(Document document);
+    
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be saved
+     */
+    public boolean canSave(Document document);
+    
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be routed
+     */
+    public boolean canRoute(Document document);
+    
+  
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be canceled
+     */
+    public boolean canCancel(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether the document can be copied
+     */
+    public boolean canCopy(Document document);
+    
+    
+    /**
+     * @param document
+     * @return boolean indicating whether can perform route report
+     */
+    public boolean canPerformRouteReport(Document document);
+    
+    /**
+     * @param document
+     * @return boolean indicating whether can ad hoc route
+     */
+    public boolean canAdHocRoute(Document document);
+    
+    
+}
+
Index: impl/src/main/java/org/kuali/rice/kns/service/KNSServiceLocator.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/service/KNSServiceLocator.java	(revision 5588)
+++ impl/src/main/java/org/kuali/rice/kns/service/KNSServiceLocator.java	(working copy)
@@ -26,9 +26,8 @@
 import org.kuali.rice.core.resourceloader.GlobalResourceLoader;
 import org.kuali.rice.core.resourceloader.RiceResourceLoaderFactory;
 import org.kuali.rice.core.service.EncryptionService;
-import org.kuali.rice.kns.dao.BusinessObjectDao;
 import org.kuali.rice.kns.dao.DocumentDao;
-import org.kuali.rice.kns.dbplatform.KualiDBPlatform;
+import org.kuali.rice.kns.document.authorization.DocumentPresentationController;
 import org.kuali.rice.kns.inquiry.Inquirable;
 import org.kuali.rice.kns.lookup.LookupResultsService;
 import org.kuali.rice.kns.lookup.Lookupable;
@@ -432,15 +431,21 @@
         return (DocumentDao) getService(DOCUMENT_DAO);
     }
     
-    public static final String BUSINESS_OBJECT_DAO = "businessObjectDao";
+    public static final String DOCUMENT_PRESENTATION_CONTROLLER = "documentPresentationController";
+
+    public static final DocumentPresentationController getDocumentPresentationController() {
+	return (DocumentPresentationController) getService(DOCUMENT_PRESENTATION_CONTROLLER);
+    }
     
-    public static BusinessObjectDao getBusinessObjectDao() {
-        return (BusinessObjectDao) getService(BUSINESS_OBJECT_DAO);
+    public static final String MAINTENANCE_DOCUMENT_PRESENTATION_CONTROLLER = "maintenanceDocumentPresentationController";
+
+    public static final DocumentPresentationController getMaintenanceDocumentPresentationController() {
+	return (DocumentPresentationController) getService(MAINTENANCE_DOCUMENT_PRESENTATION_CONTROLLER);
     }
     
-    public static final String DB_PLATFORM = "dbPlatform";
-    
-    public static KualiDBPlatform getKualiDbPlatform() {
-        return (KualiDBPlatform) getService(DB_PLATFORM);
+    public static final String TRANSACTIONAL_DOCUMENT_PRESENTATION_CONTROLLER = "transactionalDocumentPresentationController";
+
+    public static final DocumentPresentationController getTransactionalDocumentPresentationController() {
+	return (DocumentPresentationController) getService(TRANSACTIONAL_DOCUMENT_PRESENTATION_CONTROLLER);
     }
-}
\ No newline at end of file
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationControllerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationControllerBase.java	(revision 0)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentPresentationControllerBase.java	(revision 0)
@@ -0,0 +1,35 @@
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * Base class for all TransactionalDocumentPresentationControllers.
+ */
+public class TransactionalDocumentPresentationControllerBase extends DocumentPresentationControllerBase implements TransactionalDocumentPresentationController {
+    private static Log LOG = LogFactory.getLog(TransactionalDocumentPresentationControllerBase.class);
+
+    public Map getEditMode(Document document){
+    	Map editModeMap = new HashMap();
+    	return editModeMap;
+    }
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizer.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/TransactionalDocumentAuthorizer.java	(working copy)
@@ -1,23 +1,43 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-
-/**
- * Extension to DocumentAuthorizer interface which adds transactional-document-specific methods.
- */
-public interface TransactionalDocumentAuthorizer extends DocumentAuthorizer {
-}
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+
+/**
+ * Extension to DocumentAuthorizer interface which adds transactional-document-specific methods.
+ */
+public interface TransactionalDocumentAuthorizer extends DocumentAuthorizer {
+	
+	/**
+	 * 
+	 * @param editMode
+	 * @param user
+     * @return boolean indicating whether the user has permission to use this edit mode
+     */
+
+	public boolean canUseEditMode(String editMode, Person user); 
+
+	 /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to correct errors for the document
+     */
+    public boolean canErrorCorrect(Document document, Person user); 
+    
+}
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizerBase.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizerBase.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizerBase.java	(working copy)
@@ -1,590 +1,898 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import org.apache.commons.lang.StringUtils;
-import org.apache.commons.logging.Log;
-import org.apache.commons.logging.LogFactory;
-import org.kuali.rice.core.util.RiceConstants;
-import org.kuali.rice.kew.dto.ActionRequestDTO;
-import org.kuali.rice.kew.dto.ValidActionsDTO;
-import org.kuali.rice.kew.exception.WorkflowException;
-import org.kuali.rice.kew.util.KEWConstants;
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kim.service.IdentityManagementService;
-import org.kuali.rice.kim.service.KIMServiceLocator;
-import org.kuali.rice.kns.authorization.AuthorizationConstants;
-import org.kuali.rice.kns.document.Document;
-import org.kuali.rice.kns.exception.DocumentInitiationAuthorizationException;
-import org.kuali.rice.kns.exception.PessimisticLockingException;
-import org.kuali.rice.kns.service.AuthorizationService;
-import org.kuali.rice.kns.service.KNSServiceLocator;
-import org.kuali.rice.kns.service.KualiConfigurationService;
-import org.kuali.rice.kns.util.KNSConstants;
-import org.kuali.rice.kns.util.ObjectUtils;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
-import org.kuali.rice.kns.workflow.service.KualiWorkflowInfo;
-
-
-/**
- * DocumentAuthorizer containing common, reusable document-level authorization code.
- */
-public class DocumentAuthorizerBase implements DocumentAuthorizer {
-    private static Log LOG = LogFactory.getLog(DocumentAuthorizerBase.class);
-    
-    public static final String EDIT_MODE_DEFAULT_TRUE_VALUE = "TRUE";
-    public static final String USER_SESSION_METHOD_TO_CALL_OBJECT_KEY = "METHOD_TO_CALL_KEYS_METHOD_OBJECT_KEY";
-    public static final String USER_SESSION_METHOD_TO_CALL_COMPLETE_OBJECT_KEY = "METHOD_TO_CALL_KEYS_COMPLETE_OBJECT_KEY";
-
-    private static AuthorizationService authorizationService;
-    private static KualiWorkflowInfo kualiWorkflowInfo;
-    private static KualiConfigurationService kualiConfigurationService;
-    private static IdentityManagementService identityManagementService;
-
-    /**
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public Map getEditMode(Document d, Person u) {
-        Map editModeMap = new HashMap();
-        String editMode = AuthorizationConstants.EditMode.VIEW_ONLY;
-
-        KualiWorkflowDocument workflowDocument = d.getDocumentHeader().getWorkflowDocument();
-        if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-            if (hasInitiateAuthorization(d, u)) {
-                editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
-            }
-        }
-        else if (workflowDocument.stateIsEnroute() && workflowDocument.isApprovalRequested()) {
-            editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
-        }
-
-        editModeMap.put(editMode, EDIT_MODE_DEFAULT_TRUE_VALUE);
-
-        return editModeMap;
-    }
-    
-    /**
-     * Individual document families will need to reimplement this according to their own needs; this version should be good enough
-     * to be usable during initial development.
-     *
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
-     *      org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
-        LOG.debug("calling DocumentAuthorizerBase.getDocumentActionFlags for document '" + document.getDocumentNumber() + "'. user '" + user.getPrincipalName() + "'");
-
-        DocumentActionFlags flags = new DocumentActionFlags(); // all flags default to false
-
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-        boolean hasInitiateAuthorization = hasInitiateAuthorization(document, user);
-
-        flags.setCanClose(true); // can always close a document
-
-        // if a document is canceled, everything other than close should be set to false
-        // if a document is NOT canceled, then we want to process the rest
-        if (!workflowDocument.stateIsCanceled()) {
-            flags.setCanReload(!workflowDocument.stateIsInitiated());
-
-            flags.setCanBlanketApprove(workflowDocument.isBlanketApproveCapable());
-
-            // The only exception to the supervisor user canSupervise is when the supervisor
-            // user is also the initiator, and does NOT have an approval request. In other words if they
-            // are the document initiator, and its still in Initiated or Saved phase, they cant have access
-            // to the supervisor buttons. If they're the initiator, but for some reason they are also
-            // approving the document, then they can have the supervisor button & functions.
-            boolean canSuperviseAsInitiator = !(hasInitiateAuthorization && !workflowDocument.isApprovalRequested());
-            flags.setCanSupervise(org.kuali.rice.kim.service.KIMServiceLocator.getIdentityManagementService().isMemberOfGroup(user.getPrincipalId(), org.kuali.rice.kim.util.KimConstants.TEMP_GROUP_NAMESPACE,	KNSServiceLocator.getKualiConfigurationService().getParameterValue(KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.CoreApcParms.SUPERVISOR_WORKGROUP)) && canSuperviseAsInitiator);
-
-            // default normal documents to be unable to copy
-            flags.setCanCopy(false);
-            // default route report to false and set individually based on workflow doc status below
-            flags.setCanPerformRouteReport(allowsPerformRouteReport(document, user));
-
-            if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
-                ValidActionsDTO validActions = workflowDocument.getRouteHeader().getValidActions();
-                boolean hasPreRouteEditAuthorization = hasPreRouteEditAuthorization(document, user);
-                flags.setCanCancel(hasPreRouteEditAuthorization && validActions.contains(KEWConstants.ACTION_TAKEN_CANCELED_CD));
-
-                flags.setCanSave(hasPreRouteEditAuthorization && validActions.contains(KEWConstants.ACTION_TAKEN_SAVED_CD));
-
-                flags.setCanRoute(hasPreRouteEditAuthorization && validActions.contains(KEWConstants.ACTION_TAKEN_ROUTED_CD));
-
-                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
-                flags.setCanFYI(workflowDocument.isFYIRequested());
-
-                flags.setCanAdHocRoute(flags.getCanSave() || flags.getCanRoute());
-            }
-            else if (workflowDocument.stateIsEnroute()) {
-                flags.setCanApprove(workflowDocument.isApprovalRequested());
-
-                flags.setCanDisapprove(workflowDocument.isApprovalRequested());
-
-                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
-                flags.setCanFYI(workflowDocument.isFYIRequested());
-
-                flags.setCanAdHocRoute(workflowDocument.isApprovalRequested() || workflowDocument.isAcknowledgeRequested());
-            }
-            else if (workflowDocument.stateIsApproved() || workflowDocument.stateIsFinal() || workflowDocument.stateIsDisapproved()) {
-                flags.setCanAcknowledge(workflowDocument.isAcknowledgeRequested());
-                flags.setCanFYI(workflowDocument.isFYIRequested());
-
-                flags.setCanAdHocRoute(false);
-            }
-            else if (workflowDocument.stateIsException()) {
-            try {
-                    ActionRequestDTO[] requests = getKualiWorkflowInfo().getActionRequests(workflowDocument.getRouteHeaderId());
-                    boolean reqFound = false;
-                    for ( ActionRequestDTO req : requests ) {
-                        if ( req.isExceptionRequest() && req.getActionTakenId() == null ) {
-                        if ( req.getGroupId()!= null ) {
-                        	
-                        List<String> principalIds = KIMServiceLocator.getIdentityManagementService().getGroupMemberPrincipalIds(req.getGroupId());
-                        for ( String principalId : principalIds ) {
-                            if ( principalId.equals( user.getPrincipalId() ) ) {
-                            flags.setCanCancel( true );
-                                    flags.setCanApprove( true );
-                                    flags.setCanDisapprove( true );
-                                    reqFound = true; // used to break out of outer loop
-                                    break;
-                            }
-                        }
-                        if ( reqFound ) {
-                            break;
-                        }
-                        } else {
-                        LOG.error( "Unable to retrieve user list for exceptiongroup.  ActionRequestVO.getGroupVO() returned null" );
-                        LOG.error( "request: " + req );
-                        }
-                    }
-                    }
-            } catch( WorkflowException ex ) {
-                LOG.error("Unable to retrieve action requests for document: " + document.getDocumentNumber(),ex);
-            }
-
-                flags.setCanAdHocRoute(false);
-            }
-        }
-
-        setAnnotateFlag(flags);
-
-        return flags;
-    }
-    
-    protected KualiConfigurationService getKualiConfigurationService() {
-    if ( kualiConfigurationService == null ) {
-        kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
-    }
-    return kualiConfigurationService;
-    }
-    
-    protected AuthorizationService getAuthorizationService() {
-    if ( authorizationService == null ) {
-        authorizationService = KNSServiceLocator.getAuthorizationService();
-    }
-    return authorizationService;
-    }
-    
-    protected KualiWorkflowInfo getKualiWorkflowInfo() {
-    if ( kualiWorkflowInfo == null ) {
-        kualiWorkflowInfo = KNSServiceLocator.getWorkflowInfoService();
-    }
-    return kualiWorkflowInfo;
-    }
-    
-    /**
-     * Helper method to disallow the perform route report button globally for a particular authorizer class
-     * @param document - current document
-     * @param user - current user
-     * @return boolean to allow or disallow route report button to show for user
-     */
-    public boolean allowsPerformRouteReport(Document document, Person user) {
-        KualiConfigurationService kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
-        return kualiConfigurationService.getIndicatorParameter( KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.SystemGroupParameterNames.DEFAULT_CAN_PERFORM_ROUTE_REPORT_IND);
-    }
-
-    /**
-     * Helper method to set the annotate flag based on other workflow tags
-     * @param flags
-     */
-    public void setAnnotateFlag(DocumentActionFlags flags) {
-        boolean canWorkflow = flags.getCanSave() || flags.getCanRoute() || flags.getCanCancel() || flags.getCanBlanketApprove() || flags.getCanApprove() || flags.getCanDisapprove() || flags.getCanAcknowledge() || flags.getCanAdHocRoute();
-        flags.setCanAnnotate(canWorkflow);
-    }
-
-    /**
-     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public void canInitiate(String documentTypeName, Person user) {
-        if (!getAuthorizationService().isAuthorized(user, "initiate", documentTypeName)) {
-            // build authorized workgroup list for error message
-            Set authorizedWorkgroups = getAuthorizationService().getAuthorizedWorkgroups("initiate", documentTypeName);
-            String workgroupList = StringUtils.join(authorizedWorkgroups.toArray(), ",");
-            throw new DocumentInitiationAuthorizationException(new String[] {workgroupList,documentTypeName});
-        }
-    }
-
-    /**
-     * Default implementation here is if a user cannot initiate a document they cannot copy one.
-     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canCopy(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
-     */
-    public boolean canCopy(String documentTypeName, Person user) {
-        return getAuthorizationService().isAuthorized(user, "initiate", documentTypeName);
-    }
-
-    /**
-     * This method checks to see if a document is using Pessimistic Locking first. If the document is not using Pessimistic
-     * Locking this method will return the value returned by {@link #hasInitiateAuthorization(Document, Person)}. If
-     * the document is using pessimistic locking and the value of {@link #hasInitiateAuthorization(Document, Person)}
-     * is true, the system will check to see that the given user has a lock on the document and return true if one is found.
-     * 
-     * @param document - document to check
-     * @param user - current user
-     * @return true if the document is using Pessimistic Locking, the user has initiate authorization (see
-     *         {@link #hasInitiateAuthorization(Document, Person)}), and the document has a lock owned by the given
-     *         user. If the document is not using Pessimistic Locking the value returned will be that returned by
-     *         {@link #hasInitiateAuthorization(Document, Person)}.
-     */
-    public boolean hasPreRouteEditAuthorization(Document document, Person user) {
-        if (usesPessimisticLocking(document)) {
-            if (hasInitiateAuthorization(document, user)) {
-                for (Iterator iterator = document.getPessimisticLocks().iterator(); iterator.hasNext();) {
-                    PessimisticLock lock = (PessimisticLock) iterator.next();
-                    if (lock.isOwnedByUser(user)) {
-                        return true;
-                    }
-                }
-            }
-            return false;
-        } else {
-            return hasInitiateAuthorization(document, user);
-        }
-    }
-    
-    protected boolean usesPessimisticLocking(Document document) {
-        return KNSServiceLocator.getDataDictionaryService().getDataDictionary().getDocumentEntry(document.getClass().getName()).getUsePessimisticLocking();
-    }
-    
-    /**
-     * Determines whether the given user should have initiate permissions on the given document.
-     * @param document - current document
-     * @param user - current user
-     * @return boolean (true if they should have permissions)
-     */
-    public boolean hasInitiateAuthorization(Document document, Person user) {
-        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
-        return workflowDocument.getInitiatorNetworkId().equalsIgnoreCase(user.getPrincipalName());
-    }
-
-    /**
-     * Determines whether the given user should be able to view the attachment on the given document
-     * and the attachment type
-     * @param attachmentTypeName - the attachment type
-     * @param document - current document
-     * @param user - current user
-     * @return boolean (true if they should have permissions)
-     */
-    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user) {
-        return true;
-    }
-
-    /**
-     * This method creates a new {@link PessimisticLock} when Workflow processing requires one
-     * 
-     * @param document - the document to create the lock against and add the lock to
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
-     */
-    public void establishWorkflowPessimisticLocking(Document document) {
-        PessimisticLock lock = createNewPessimisticLock(document, new HashMap(), getWorkflowPessimisticLockOwnerUser());
-        document.addPessimisticLock(lock);
-    }
-    
-    /**
-     * This method releases locks created via the {@link #establishWorkflowPessimisticLocking(Document)} method for the given document
-     * 
-     * @param document - document to release locks from
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#releaseWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
-     */
-    public void releaseWorkflowPessimisticLocking(Document document) {
-        KNSServiceLocator.getPessimisticLockService().releaseAllLocksForUser(document.getPessimisticLocks(), getWorkflowPessimisticLockOwnerUser());
-        document.refreshPessimisticLocks();
-    }
-
-    /**
-     * This method identifies the user that should be used to create and clear {@link PessimisticLock} objects required by
-     * Workflow.<br>
-     * <br>
-     * The default is the Kuali system user defined by {@link RiceConstants#SYSTEM_USER}. This method can be overriden by
-     * implementing documents if another user is needed.
-     * 
-     * @return a valid {@link Person} object
-     */
-    protected Person getWorkflowPessimisticLockOwnerUser() {
-        String networkId = KNSConstants.SYSTEM_USER;
-        return org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().getPersonByPrincipalName(networkId);
-    }
-    
-    /**
-     * This implementation will check the given document, editMode map, and user object to verify Pessimistic Locking. If the
-     * given edit mode map contains an 'entry type' edit mode then the system will check the locks already in existance on
-     * the document. If a valid lock for the given user is found the system will return the given edit mode map. If a valid
-     * lock is found but is owned by another user the edit mode map returned will have any 'entry type' edit modes removed. If the
-     * given document has no locks and the edit mode map passed in has at least one 'entry type' mode then a new
-     * {@link PessimisticLock} object will be created and set on the document for the given user.<br>
-     * <br> 
-     * NOTE: This method is only called if the document uses pessimistic locking as described in the data dictionary file.
-     * 
-     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishLocks(org.kuali.rice.kns.document.Document,
-     *      java.util.Map, org.kuali.rice.kim.bo.Person)
-     */
-    public Map establishLocks(Document document, Map editMode, Person user) {
-        Map editModeMap = new HashMap();
-        // givenUserLockDescriptors is a list of lock descriptors currently held on the document by the given user
-        List<String> givenUserLockDescriptors = new ArrayList<String>();
-        // lockDescriptorUsers is a map with lock descriptors as keys and users other than the given user who hold a lock of each descriptor 
-        Map<String,Set<Person>> lockDescriptorUsers = new HashMap<String,Set<Person>>();
-
-        // build the givenUserLockDescriptors set and the lockDescriptorUsers map
-        for (PessimisticLock lock : document.getPessimisticLocks()) {
-            if (lock.isOwnedByUser(user)) {
-                // lock is owned by given user
-                givenUserLockDescriptors.add(lock.getLockDescriptor());
-            } else {
-                // lock is not owned by the given user
-                if (!lockDescriptorUsers.containsKey(lock.getLockDescriptor())) {
-                    lockDescriptorUsers.put(lock.getLockDescriptor(), new HashSet<Person>());
-                }
-                ((Set<Person>) lockDescriptorUsers.get(lock.getLockDescriptor())).add(lock.getOwnedByUser());
-            }
-        }
-
-        // verify that no locks held by current user exist for any other user
-        for (String givenUserLockDescriptor : givenUserLockDescriptors) {
-            if ( (lockDescriptorUsers.containsKey(givenUserLockDescriptor)) && (lockDescriptorUsers.get(givenUserLockDescriptor).size() > 0) ) {
-                Set<Person> users = lockDescriptorUsers.get(givenUserLockDescriptor);
-                if ( (users.size() != 1) || (!getWorkflowPessimisticLockOwnerUser().getPrincipalId().equals(users.iterator().next().getPrincipalId())) ) {
-                    String descriptorText = (useCustomLockDescriptors()) ? " using lock descriptor '" + givenUserLockDescriptor + "'" : "";
-                    String errorMsg = "Found an invalid lock status on document number " + document.getDocumentNumber() + "with current user and other user both having locks" + descriptorText + " concurrently";
-                    LOG.debug(errorMsg);
-                    throw new PessimisticLockingException(errorMsg);
-                }
-            }
-        }
-        
-        // check to see if the given user has any locks in the system at all
-        if (givenUserLockDescriptors.isEmpty()) {
-            // given user has no locks... check for other user locks
-            if (lockDescriptorUsers.isEmpty()) {
-                // no other user has any locks... set up locks for given user if user has edit privileges
-                if (isLockRequiredByUser(document, editMode, user)) {
-                    document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
-                }
-                editModeMap.putAll(editMode);
-            } else {
-                // at least one other user has at least one other lock... adjust edit mode for read only
-                if (useCustomLockDescriptors()) {
-                    // check to see if the custom lock descriptor is already in use
-                    String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
-                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
-                        // at least one other user has this descriptor locked... remove editable edit modes
-                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
-                    } else {
-                        // no other user has a lock with this descriptor
-                        if (isLockRequiredByUser(document, editMode, user)) {
-                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
-                        }
-                        editModeMap.putAll(editMode);
-                    }
-                } else {
-                    editModeMap = getEditModeWithEditableModesRemoved(editMode);
-                }
-            }
-        } else {
-            // given user already has at least one lock descriptor
-            if (useCustomLockDescriptors()) {
-                // get the custom lock descriptor and check to see if if the given user has a lock with that descriptor
-                String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
-                if (givenUserLockDescriptors.contains(customLockDescriptor)) {
-                    // user already has lock that is required
-                    editModeMap.putAll(editMode);
-                } else {
-                    // user does not have lock for descriptor required
-                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
-                        // another user has the lock descriptor that the given user requires... disallow lock and alter edit modes to have read only
-                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
-                    } else {
-                        // no other user has a lock with this descriptor... check if this user needs a lock
-                        if (isLockRequiredByUser(document, editMode, user)) {
-                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
-                        }
-                        editModeMap.putAll(editMode);
-                    }
-                }
-            } else {
-                // user already has lock and no descriptors are being used... use the existing edit modes
-                editModeMap.putAll(editMode);
-            }
-        }
-
-        return editModeMap;
-    }
-    
-    /**
-     * This method is used to check if the given parameters warrant a new lock to be created for the given user. This method
-     * utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method.
-     * 
-     * @param document -
-     *            document to verify lock creation against
-     * @param editMode -
-     *            edit modes list to check for 'entry type' edit modes
-     * @param user -
-     *            user the lock will be 'owned' by
-     * @return true if the given edit mode map has at least one 'entry type' edit mode... false otherwise
-     */
-    protected boolean isLockRequiredByUser(Document document, Map editMode, Person user) {
-        // check for entry edit mode
-        for (Iterator iterator = editMode.entrySet().iterator(); iterator.hasNext();) {
-            Map.Entry entry = (Map.Entry) iterator.next();
-            if (isEntryEditMode(entry)) {
-                return true;
-            }
-        }
-        return false;
-    }
-    
-   /**
-     * This method is used to remove edit modes from the given map that allow the user to edit data on the document. This
-     * method utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method to identify if an edit mode is defined as an
-     * 'entry type' edit mode. It also uses the {@link #getEntryEditModeReplacementMode(java.util.Map.Entry)} method to replace
-     * any 'entry type' edit modes it finds.
-     * 
-     * @param currentEditMode -
-     *            current set of edit modes the user has assigned to them
-     * @return an adjusted edit mode map where 'entry type' edit modes have been removed or replaced using the
-     *         {@link #getEntryEditModeReplacementMode()} method
-     */
-    protected Map getEditModeWithEditableModesRemoved(Map currentEditMode) {
-        Map editModeMap = new HashMap();
-        for (Iterator iterator = currentEditMode.entrySet().iterator(); iterator.hasNext();) {
-            Map.Entry entry = (Map.Entry) iterator.next();
-            if (isEntryEditMode(entry)) {
-                editModeMap.putAll(getEntryEditModeReplacementMode(entry));
-            } else {
-                editModeMap.put(entry.getKey(), entry.getValue());
-            }
-        }
-        return editModeMap;
-    }
-    
-    /**
-     * This method is used to check if the given {@link Map.Entry} is an 'entry type' edit mode and that the value is set to
-     * signify that this user has that edit mode available to them
-     * 
-     * @param entry -
-     *            the {@link Map.Entry} object that contains an edit mode such as the ones returned but
-     *            {@link #getEditMode(Document, Person)}
-     * @return true if the given entry has a key signifying an 'entry type' edit mode and the value is equal to
-     *         {@link #EDIT_MODE_DEFAULT_TRUE_VALUE}... false if not
-     */
-    protected boolean isEntryEditMode(Map.Entry entry) {
-        // check for FULL_ENTRY edit mode set to default true value
-        if (AuthorizationConstants.EditMode.FULL_ENTRY.equals(entry.getKey())) {
-            String fullEntryEditModeValue = (String)entry.getValue();
-            return ( (ObjectUtils.isNotNull(fullEntryEditModeValue)) && (EDIT_MODE_DEFAULT_TRUE_VALUE.equals(fullEntryEditModeValue)) );
-        }
-        return false;
-    }
-    
-    /**
-     * This method is used to return values needed to replace the given 'entry type' edit mode {@link Map.Entry} with one that will not allow the user to enter data on the document 
-     * 
-     * @param entry - the current 'entry type' edit mode to replace 
-     * @return a Map of edit modes that will be used to replace this edit mode (represented by the given entry parameter)
-     */
-    protected Map getEntryEditModeReplacementMode(Map.Entry entry) {
-        Map editMode = new HashMap();
-        editMode.put(AuthorizationConstants.EditMode.VIEW_ONLY, EDIT_MODE_DEFAULT_TRUE_VALUE);
-        return editMode;
-    }
-    
-    /**
-     * This method creates a new {@link PessimisticLock} object using the given document and user. If the
-     * {@link #useCustomLockDescriptors()} method returns true then the new lock will also have a custom lock descriptor
-     * value set to the return value of {@link #getCustomLockDescriptor(Document, Map, Person)}.
-     * 
-     * @param document -
-     *            document to place the lock on
-     * @param editMode -
-     *            current edit modes for given user
-     * @param user -
-     *            user who will 'own' the new lock object
-     * @return the newly created lock object
-     */
-    protected PessimisticLock createNewPessimisticLock(Document document, Map editMode, Person user) {
-        if (useCustomLockDescriptors()) {
-            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), getCustomLockDescriptor(document, editMode, user), user);
-        } else {
-            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), user);
-        }
-    }
-    
-    /**
-     * This method should be overriden by groups requiring the lock descriptor field in the {@link PessimisticLock} objects.
-     * If it is not overriden and {@link #useCustomLockDescriptors()} returns true then this method will throw a
-     * {@link PessimisticLockingException}
-     * 
-     * @param document - document being checked for locking
-     * @param editMode - editMode generated for passed in user
-     * @param user - user attempting to establish locks
-     * @return a {@link PessimisticLockingException} will be thrown as the default implementation
-     */
-    protected String getCustomLockDescriptor(Document document, Map editMode, Person user) {
-        throw new PessimisticLockingException("Document " + document.getDocumentNumber() + " is using Pessimistic Locking with lock descriptors but the authorizer class has not defined the getCustomLockDescriptor() method");
-    }
-
-    /**
-     * This method should be used to define Document Authorizer classes which will use custom lock descriptors in the
-     * {@link PessimisticLock} objects NOTE: if this method is overriden to return true then the method
-     * {@link #getCustomLockDescriptor(Document, Map, Person)} must be overriden
-     * 
-     * @return false if the document will not be using lock descriptors or true if the document will use lock descriptors.
-     *         The default return value is false
-     */
-    protected boolean useCustomLockDescriptors() {
-        return false;
-    }
-    
-     /**
-	  * @return the identityManagementService
-	  */
-	 public static IdentityManagementService getIdentityManagementService() {
-			
-		if (identityManagementService == null ) {
-			identityManagementService = KIMServiceLocator.getIdentityManagementService();
-		}
-		return identityManagementService;
-	}
-    
-}
+
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.logging.Log;
+import org.apache.commons.logging.LogFactory;
+import org.kuali.rice.core.util.RiceConstants;
+import org.kuali.rice.kew.util.KEWConstants;
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kim.bo.types.dto.AttributeSet;
+import org.kuali.rice.kim.service.IdentityManagementService;
+import org.kuali.rice.kim.service.KIMServiceLocator;
+import org.kuali.rice.kim.util.KimConstants;
+import org.kuali.rice.kns.authorization.AuthorizationConstants;
+import org.kuali.rice.kns.document.Document;
+import org.kuali.rice.kns.exception.PessimisticLockingException;
+import org.kuali.rice.kns.service.AuthorizationService;
+import org.kuali.rice.kns.service.KNSServiceLocator;
+import org.kuali.rice.kns.service.KualiConfigurationService;
+import org.kuali.rice.kns.util.GlobalVariables;
+import org.kuali.rice.kns.util.KNSConstants;
+import org.kuali.rice.kns.util.ObjectUtils;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowDocument;
+import org.kuali.rice.kns.workflow.service.KualiWorkflowInfo;
+
+
+/**
+ * DocumentAuthorizer containing common, reusable document-level authorization code.
+ */
+/**
+ * This is a description of what this class does - zjzhou don't forget to fill this in. 
+ * 
+ * @author Kuali Rice Team (kuali-rice@googlegroups.com)
+ *
+ */
+public class DocumentAuthorizerBase implements DocumentAuthorizer {
+    private static Log LOG = LogFactory.getLog(DocumentAuthorizerBase.class);
+    
+    public static final String EDIT_MODE_DEFAULT_TRUE_VALUE = "TRUE";
+    public static final String USER_SESSION_METHOD_TO_CALL_OBJECT_KEY = "METHOD_TO_CALL_KEYS_METHOD_OBJECT_KEY";
+    public static final String USER_SESSION_METHOD_TO_CALL_COMPLETE_OBJECT_KEY = "METHOD_TO_CALL_KEYS_COMPLETE_OBJECT_KEY";
+
+    private static AuthorizationService authorizationService;
+    private static KualiWorkflowInfo kualiWorkflowInfo;
+    private static KualiConfigurationService kualiConfigurationService;
+    private static IdentityManagementService identityManagementService;
+    private static DocumentPresentationController documentPresentationController;
+   
+    /**
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getEditMode(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public Map getEditMode(Document d, Person u) {
+        Map editModeMap = new HashMap();
+        String editMode = AuthorizationConstants.EditMode.VIEW_ONLY;
+
+        KualiWorkflowDocument workflowDocument = d.getDocumentHeader().getWorkflowDocument();
+        if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+            if (hasInitiateAuthorization(d, u)) {
+                editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
+            }
+        }
+        else if (workflowDocument.stateIsEnroute() && workflowDocument.isApprovalRequested()) {
+            editMode = AuthorizationConstants.EditMode.FULL_ENTRY;
+        }
+
+        editModeMap.put(editMode, EDIT_MODE_DEFAULT_TRUE_VALUE);
+
+        return editModeMap;
+    }
+    
+    
+    /**
+     * Individual document families will need to reimplement this according to their own needs; this version should be good enough
+     * to be usable during initial development.
+     *
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#getDocumentActionFlags(org.kuali.rice.kns.document.Document,
+     *      org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user) {
+        LOG.debug("calling DocumentAuthorizerBase.getDocumentActionFlags for document '" + document.getDocumentNumber() + "'. user '" + user.getPrincipalName() + "'");
+
+        DocumentActionFlags flags = new DocumentActionFlags(); // all flags default to false
+
+        flags.setCanClose(getDocumentPresentationController().canClose(document)); 
+
+        flags.setCanReload(getDocumentPresentationController().canReload(document)); 
+        
+        flags.setCanBlanketApprove(canBlanketApprove(document, user));
+        
+        flags.setCanCopy(getDocumentPresentationController().canCopy(document)? canCopy(document, user):false);
+        
+        flags.setCanPerformRouteReport(getDocumentPresentationController().canPerformRouteReport(document));
+        
+        //boolean canSuperviseAsInitiator = !(hasInitiateAuthorization && !workflowDocument.isApprovalRequested());
+        //flags.setCanSupervise(org.kuali.rice.kim.service.KIMServiceLocator.getIdentityManagementService().isMemberOfGroup(user.getPrincipalId(), org.kuali.rice.kim.util.KimConstants.TEMP_GROUP_NAMESPACE,	KNSServiceLocator.getKualiConfigurationService().getParameterValue(KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.CoreApcParms.SUPERVISOR_WORKGROUP)) && canSuperviseAsInitiator);
+        
+        
+        if(getDocumentPresentationController().canCancel(document)){
+        	boolean hasPreRouteEditAuthorization = hasPreRouteEditAuthorization(document, user);
+        	 flags.setCanCancel(hasPreRouteEditAuthorization &&canCancel(document, user));
+        }
+        
+        if(getDocumentPresentationController().canSave(document)){
+        	boolean hasPreRouteEditAuthorization = hasPreRouteEditAuthorization(document, user);
+        	flags.setCanSave(hasPreRouteEditAuthorization &&canSave(document, user));
+        }
+        
+        if(getDocumentPresentationController().canRoute(document)){
+        	boolean hasPreRouteEditAuthorization = hasPreRouteEditAuthorization(document, user);
+        	flags.setCanRoute(hasPreRouteEditAuthorization &&canRoute(document, user));
+        }
+
+        flags.setCanAcknowledge(canAcknowledge(document, user));
+        flags.setCanFYI(canClearFYI(document, user));
+        
+        
+        if(getDocumentPresentationController().canAdHocRoute(document)){
+        	flags.setCanAdHocRoute(flags.getCanSave() || flags.getCanRoute());
+        } 
+         
+        flags.setCanApprove(canApprove(document, user));
+        flags.setCanDisapprove(canDisapprove(document, user));
+        
+        flags.setCanAnnotate(getDocumentPresentationController().canAnnotate(document)? canAnnotate(document, user):false);
+        
+        return flags;
+    }
+    
+    protected KualiConfigurationService getKualiConfigurationService() {
+    if ( kualiConfigurationService == null ) {
+        kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+    }
+    return kualiConfigurationService;
+    }
+    
+    protected AuthorizationService getAuthorizationService() {
+    if ( authorizationService == null ) {
+        authorizationService = KNSServiceLocator.getAuthorizationService();
+    }
+    return authorizationService;
+    }
+    
+    protected KualiWorkflowInfo getKualiWorkflowInfo() {
+    if ( kualiWorkflowInfo == null ) {
+        kualiWorkflowInfo = KNSServiceLocator.getWorkflowInfoService();
+    }
+    return kualiWorkflowInfo;
+    }
+    
+    /**
+     * Helper method to disallow the perform route report button globally for a particular authorizer class
+     * @param document - current document
+     * @param user - current user
+     * @return boolean to allow or disallow route report button to show for user
+     */
+    public boolean allowsPerformRouteReport(Document document, Person user) {
+        KualiConfigurationService kualiConfigurationService = KNSServiceLocator.getKualiConfigurationService();
+        return kualiConfigurationService.getIndicatorParameter( KNSConstants.KNS_NAMESPACE, KNSConstants.DetailTypes.DOCUMENT_DETAIL_TYPE, KNSConstants.SystemGroupParameterNames.DEFAULT_CAN_PERFORM_ROUTE_REPORT_IND);
+    }
+
+    /**
+     * Helper method to set the annotate flag based on other workflow tags
+     * @param flags
+     */
+    public void setAnnotateFlag(DocumentActionFlags flags) {
+        boolean canWorkflow = flags.getCanSave() || flags.getCanRoute() || flags.getCanCancel() || flags.getCanBlanketApprove() || flags.getCanApprove() || flags.getCanDisapprove() || flags.getCanAcknowledge() || flags.getCanAdHocRoute();
+        flags.setCanAnnotate(canWorkflow);
+    }
+
+    /**
+     * DocumentTypeAuthorizationException can be extended to customize the initiate error message
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canInitiate(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public void canInitiate(String documentTypeName, Person user) {
+    	
+    }
+
+    /**
+     * Default implementation here is if a user cannot initiate a document they cannot copy one.
+     * @see org.kuali.rice.kns.authorization.DocumentAuthorizer#canCopy(java.lang.String, org.kuali.rice.kns.bo.user.KualiUser)
+     */
+    public boolean canCopy(String documentTypeName, Person user) {
+        return false;
+    }
+
+    /**
+     * This method checks to see if a document is using Pessimistic Locking first. If the document is not using Pessimistic
+     * Locking this method will return the value returned by {@link #hasInitiateAuthorization(Document, Person)}. If
+     * the document is using pessimistic locking and the value of {@link #hasInitiateAuthorization(Document, Person)}
+     * is true, the system will check to see that the given user has a lock on the document and return true if one is found.
+     * 
+     * @param document - document to check
+     * @param user - current user
+     * @return true if the document is using Pessimistic Locking, the user has initiate authorization (see
+     *         {@link #hasInitiateAuthorization(Document, Person)}), and the document has a lock owned by the given
+     *         user. If the document is not using Pessimistic Locking the value returned will be that returned by
+     *         {@link #hasInitiateAuthorization(Document, Person)}.
+     */
+    public boolean hasPreRouteEditAuthorization(Document document, Person user) {
+        if (usesPessimisticLocking(document)) {
+            if (hasInitiateAuthorization(document, user)) {
+                for (Iterator iterator = document.getPessimisticLocks().iterator(); iterator.hasNext();) {
+                    PessimisticLock lock = (PessimisticLock) iterator.next();
+                    if (lock.isOwnedByUser(user)) {
+                        return true;
+                    }
+                }
+            }
+            return false;
+        } else {
+            return hasInitiateAuthorization(document, user);
+        }
+    }
+    
+    protected boolean usesPessimisticLocking(Document document) {
+        return KNSServiceLocator.getDataDictionaryService().getDataDictionary().getDocumentEntry(document.getClass().getName()).getUsePessimisticLocking();
+    }
+    
+    /**
+     * Determines whether the given user should have initiate permissions on the given document.
+     * @param document - current document
+     * @param user - current user
+     * @return boolean (true if they should have permissions)
+     */
+    public boolean hasInitiateAuthorization(Document document, Person user) {
+        KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+        return workflowDocument.getInitiatorNetworkId().equalsIgnoreCase(user.getPrincipalName());
+    }
+
+    /**
+     * Determines whether the given user should be able to view the attachment on the given document
+     * and the attachment type
+     * @param attachmentTypeName - the attachment type
+     * @param document - current document
+     * @param user - current user
+     * @return boolean (true if they should have permissions)
+     */
+    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user) {
+        return true;
+    }
+
+    /**
+     * This method creates a new {@link PessimisticLock} when Workflow processing requires one
+     * 
+     * @param document - the document to create the lock against and add the lock to
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
+     */
+    public void establishWorkflowPessimisticLocking(Document document) {
+        PessimisticLock lock = createNewPessimisticLock(document, new HashMap(), getWorkflowPessimisticLockOwnerUser());
+        document.addPessimisticLock(lock);
+    }
+    
+    /**
+     * This method releases locks created via the {@link #establishWorkflowPessimisticLocking(Document)} method for the given document
+     * 
+     * @param document - document to release locks from
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#releaseWorkflowPessimisticLocking(org.kuali.rice.kns.document.Document)
+     */
+    public void releaseWorkflowPessimisticLocking(Document document) {
+        KNSServiceLocator.getPessimisticLockService().releaseAllLocksForUser(document.getPessimisticLocks(), getWorkflowPessimisticLockOwnerUser());
+        document.refreshPessimisticLocks();
+    }
+
+    /**
+     * This method identifies the user that should be used to create and clear {@link PessimisticLock} objects required by
+     * Workflow.<br>
+     * <br>
+     * The default is the Kuali system user defined by {@link RiceConstants#SYSTEM_USER}. This method can be overriden by
+     * implementing documents if another user is needed.
+     * 
+     * @return a valid {@link Person} object
+     */
+    protected Person getWorkflowPessimisticLockOwnerUser() {
+        String networkId = KNSConstants.SYSTEM_USER;
+        return org.kuali.rice.kim.service.KIMServiceLocator.getPersonService().getPersonByPrincipalName(networkId);
+    }
+    
+    /**
+     * This implementation will check the given document, editMode map, and user object to verify Pessimistic Locking. If the
+     * given edit mode map contains an 'entry type' edit mode then the system will check the locks already in existance on
+     * the document. If a valid lock for the given user is found the system will return the given edit mode map. If a valid
+     * lock is found but is owned by another user the edit mode map returned will have any 'entry type' edit modes removed. If the
+     * given document has no locks and the edit mode map passed in has at least one 'entry type' mode then a new
+     * {@link PessimisticLock} object will be created and set on the document for the given user.<br>
+     * <br> 
+     * NOTE: This method is only called if the document uses pessimistic locking as described in the data dictionary file.
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#establishLocks(org.kuali.rice.kns.document.Document,
+     *      java.util.Map, org.kuali.rice.kim.bo.Person)
+     */
+    public Map establishLocks(Document document, Map editMode, Person user) {
+        Map editModeMap = new HashMap();
+        // givenUserLockDescriptors is a list of lock descriptors currently held on the document by the given user
+        List<String> givenUserLockDescriptors = new ArrayList<String>();
+        // lockDescriptorUsers is a map with lock descriptors as keys and users other than the given user who hold a lock of each descriptor 
+        Map<String,Set<Person>> lockDescriptorUsers = new HashMap<String,Set<Person>>();
+
+        // build the givenUserLockDescriptors set and the lockDescriptorUsers map
+        for (PessimisticLock lock : document.getPessimisticLocks()) {
+            if (lock.isOwnedByUser(user)) {
+                // lock is owned by given user
+                givenUserLockDescriptors.add(lock.getLockDescriptor());
+            } else {
+                // lock is not owned by the given user
+                if (!lockDescriptorUsers.containsKey(lock.getLockDescriptor())) {
+                    lockDescriptorUsers.put(lock.getLockDescriptor(), new HashSet<Person>());
+                }
+                ((Set<Person>) lockDescriptorUsers.get(lock.getLockDescriptor())).add(lock.getOwnedByUser());
+            }
+        }
+
+        // verify that no locks held by current user exist for any other user
+        for (String givenUserLockDescriptor : givenUserLockDescriptors) {
+            if ( (lockDescriptorUsers.containsKey(givenUserLockDescriptor)) && (lockDescriptorUsers.get(givenUserLockDescriptor).size() > 0) ) {
+                Set<Person> users = lockDescriptorUsers.get(givenUserLockDescriptor);
+                if ( (users.size() != 1) || (!getWorkflowPessimisticLockOwnerUser().getPrincipalId().equals(users.iterator().next().getPrincipalId())) ) {
+                    String descriptorText = (useCustomLockDescriptors()) ? " using lock descriptor '" + givenUserLockDescriptor + "'" : "";
+                    String errorMsg = "Found an invalid lock status on document number " + document.getDocumentNumber() + "with current user and other user both having locks" + descriptorText + " concurrently";
+                    LOG.debug(errorMsg);
+                    throw new PessimisticLockingException(errorMsg);
+                }
+            }
+        }
+        
+        // check to see if the given user has any locks in the system at all
+        if (givenUserLockDescriptors.isEmpty()) {
+            // given user has no locks... check for other user locks
+            if (lockDescriptorUsers.isEmpty()) {
+                // no other user has any locks... set up locks for given user if user has edit privileges
+                if (isLockRequiredByUser(document, editMode, user)) {
+                    document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
+                }
+                editModeMap.putAll(editMode);
+            } else {
+                // at least one other user has at least one other lock... adjust edit mode for read only
+                if (useCustomLockDescriptors()) {
+                    // check to see if the custom lock descriptor is already in use
+                    String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
+                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
+                        // at least one other user has this descriptor locked... remove editable edit modes
+                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
+                    } else {
+                        // no other user has a lock with this descriptor
+                        if (isLockRequiredByUser(document, editMode, user)) {
+                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
+                        }
+                        editModeMap.putAll(editMode);
+                    }
+                } else {
+                    editModeMap = getEditModeWithEditableModesRemoved(editMode);
+                }
+            }
+        } else {
+            // given user already has at least one lock descriptor
+            if (useCustomLockDescriptors()) {
+                // get the custom lock descriptor and check to see if if the given user has a lock with that descriptor
+                String customLockDescriptor = getCustomLockDescriptor(document, editMode, user);
+                if (givenUserLockDescriptors.contains(customLockDescriptor)) {
+                    // user already has lock that is required
+                    editModeMap.putAll(editMode);
+                } else {
+                    // user does not have lock for descriptor required
+                    if (lockDescriptorUsers.containsKey(customLockDescriptor)) {
+                        // another user has the lock descriptor that the given user requires... disallow lock and alter edit modes to have read only
+                        editModeMap = getEditModeWithEditableModesRemoved(editMode);
+                    } else {
+                        // no other user has a lock with this descriptor... check if this user needs a lock
+                        if (isLockRequiredByUser(document, editMode, user)) {
+                            document.addPessimisticLock(createNewPessimisticLock(document, editMode, user));
+                        }
+                        editModeMap.putAll(editMode);
+                    }
+                }
+            } else {
+                // user already has lock and no descriptors are being used... use the existing edit modes
+                editModeMap.putAll(editMode);
+            }
+        }
+
+        return editModeMap;
+    }
+    
+    /**
+     * This method is used to check if the given parameters warrant a new lock to be created for the given user. This method
+     * utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method.
+     * 
+     * @param document -
+     *            document to verify lock creation against
+     * @param editMode -
+     *            edit modes list to check for 'entry type' edit modes
+     * @param user -
+     *            user the lock will be 'owned' by
+     * @return true if the given edit mode map has at least one 'entry type' edit mode... false otherwise
+     */
+    protected boolean isLockRequiredByUser(Document document, Map editMode, Person user) {
+        // check for entry edit mode
+        for (Iterator iterator = editMode.entrySet().iterator(); iterator.hasNext();) {
+            Map.Entry entry = (Map.Entry) iterator.next();
+            if (isEntryEditMode(entry)) {
+                return true;
+            }
+        }
+        return false;
+    }
+    
+   /**
+     * This method is used to remove edit modes from the given map that allow the user to edit data on the document. This
+     * method utilizes the {@link #isEntryEditMode(java.util.Map.Entry)} method to identify if an edit mode is defined as an
+     * 'entry type' edit mode. It also uses the {@link #getEntryEditModeReplacementMode(java.util.Map.Entry)} method to replace
+     * any 'entry type' edit modes it finds.
+     * 
+     * @param currentEditMode -
+     *            current set of edit modes the user has assigned to them
+     * @return an adjusted edit mode map where 'entry type' edit modes have been removed or replaced using the
+     *         {@link #getEntryEditModeReplacementMode()} method
+     */
+    protected Map getEditModeWithEditableModesRemoved(Map currentEditMode) {
+        Map editModeMap = new HashMap();
+        for (Iterator iterator = currentEditMode.entrySet().iterator(); iterator.hasNext();) {
+            Map.Entry entry = (Map.Entry) iterator.next();
+            if (isEntryEditMode(entry)) {
+                editModeMap.putAll(getEntryEditModeReplacementMode(entry));
+            } else {
+                editModeMap.put(entry.getKey(), entry.getValue());
+            }
+        }
+        return editModeMap;
+    }
+    
+    /**
+     * This method is used to check if the given {@link Map.Entry} is an 'entry type' edit mode and that the value is set to
+     * signify that this user has that edit mode available to them
+     * 
+     * @param entry -
+     *            the {@link Map.Entry} object that contains an edit mode such as the ones returned but
+     *            {@link #getEditMode(Document, Person)}
+     * @return true if the given entry has a key signifying an 'entry type' edit mode and the value is equal to
+     *         {@link #EDIT_MODE_DEFAULT_TRUE_VALUE}... false if not
+     */
+    protected boolean isEntryEditMode(Map.Entry entry) {
+        // check for FULL_ENTRY edit mode set to default true value
+        if (AuthorizationConstants.EditMode.FULL_ENTRY.equals(entry.getKey())) {
+            String fullEntryEditModeValue = (String)entry.getValue();
+            return ( (ObjectUtils.isNotNull(fullEntryEditModeValue)) && (EDIT_MODE_DEFAULT_TRUE_VALUE.equals(fullEntryEditModeValue)) );
+        }
+        return false;
+    }
+    
+    /**
+     * This method is used to return values needed to replace the given 'entry type' edit mode {@link Map.Entry} with one that will not allow the user to enter data on the document 
+     * 
+     * @param entry - the current 'entry type' edit mode to replace 
+     * @return a Map of edit modes that will be used to replace this edit mode (represented by the given entry parameter)
+     */
+    protected Map getEntryEditModeReplacementMode(Map.Entry entry) {
+        Map editMode = new HashMap();
+        editMode.put(AuthorizationConstants.EditMode.VIEW_ONLY, EDIT_MODE_DEFAULT_TRUE_VALUE);
+        return editMode;
+    }
+    
+    /**
+     * This method creates a new {@link PessimisticLock} object using the given document and user. If the
+     * {@link #useCustomLockDescriptors()} method returns true then the new lock will also have a custom lock descriptor
+     * value set to the return value of {@link #getCustomLockDescriptor(Document, Map, Person)}.
+     * 
+     * @param document -
+     *            document to place the lock on
+     * @param editMode -
+     *            current edit modes for given user
+     * @param user -
+     *            user who will 'own' the new lock object
+     * @return the newly created lock object
+     */
+    protected PessimisticLock createNewPessimisticLock(Document document, Map editMode, Person user) {
+        if (useCustomLockDescriptors()) {
+            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), getCustomLockDescriptor(document, editMode, user), user);
+        } else {
+            return KNSServiceLocator.getPessimisticLockService().generateNewLock(document.getDocumentNumber(), user);
+        }
+    }
+    
+    /**
+     * This method should be overriden by groups requiring the lock descriptor field in the {@link PessimisticLock} objects.
+     * If it is not overriden and {@link #useCustomLockDescriptors()} returns true then this method will throw a
+     * {@link PessimisticLockingException}
+     * 
+     * @param document - document being checked for locking
+     * @param editMode - editMode generated for passed in user
+     * @param user - user attempting to establish locks
+     * @return a {@link PessimisticLockingException} will be thrown as the default implementation
+     */
+    protected String getCustomLockDescriptor(Document document, Map editMode, Person user) {
+        throw new PessimisticLockingException("Document " + document.getDocumentNumber() + " is using Pessimistic Locking with lock descriptors but the authorizer class has not defined the getCustomLockDescriptor() method");
+    }
+
+    /**
+     * This method should be used to define Document Authorizer classes which will use custom lock descriptors in the
+     * {@link PessimisticLock} objects NOTE: if this method is overriden to return true then the method
+     * {@link #getCustomLockDescriptor(Document, Map, Person)} must be overriden
+     * 
+     * @return false if the document will not be using lock descriptors or true if the document will use lock descriptors.
+     *         The default return value is false
+     */
+    protected boolean useCustomLockDescriptors() {
+        return false;
+    }
+    
+
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canOpen(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+     */
+    public boolean canOpen(Document document, Person user){
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     String action = (String) GlobalVariables.getUserSession().retrieveObject(DocumentAuthorizerBase.USER_SESSION_METHOD_TO_CALL_OBJECT_KEY);
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	 
+	     AttributeSet qualifications = new AttributeSet();
+    	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_OPEN_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	    
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canEdit(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canEdit(Document document, Person user){
+		 boolean canEdit = false;
+	     String nameSpaceCode = "KR-NS";
+	    	
+	     KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+	     String documentType = document.getDocumentHeader().getWorkflowDocument().getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+	    	
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentType);
+	    	
+	     if (workflowDocument.stateIsInitiated() || workflowDocument.stateIsSaved()) {
+	    	 permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, KimConstants.KIM_ATTRIB_PRE_ROUTE);
+	    		
+	     }else{
+	        permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     }
+	    	
+	    AttributeSet qualifications = null;
+	    qualifications = new AttributeSet();
+        qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, document.getDocumentNumber());
+
+	 	if(getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_EDIT_DOCUMENT, permissionDetails, qualifications)){
+	 		canEdit = true;
+	 	}
+	 	   
+	    return canEdit;
+	 }
+	 
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canCopy(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canCopy(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     String action = (String) GlobalVariables.getUserSession().retrieveObject(DocumentAuthorizerBase.USER_SESSION_METHOD_TO_CALL_OBJECT_KEY);
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION, action);
+	     
+
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_COPY_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	    
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canCancel(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canCancel(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-WKFLW";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_CANCEL_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	 
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canRoute(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canRoute(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-WKFLW";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_ROUTE_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	
+	
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canSave(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canSave(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-WKFLW";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_SAVE_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	 
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canBlanketApprove(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canBlanketApprove(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-WKFLW";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_BLANKET_APPROVE_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	 
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canReceiveAdHoc(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canReceiveAdHoc(Document document, Person user, String actionRequestCode){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-WKFLW";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, actionRequestCode);
+	     AttributeSet qualifications = new AttributeSet();
+    	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_BLANKET_APPROVE_DOCUMENT, permissionDetails, qualifications);
+	        	
+	 }
+	 
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canApprove(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canApprove(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_APPROVE_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_TAKE_REQUESTED_ACTION, permissionDetails, qualifications);
+	        	
+	 }
+	 
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canClearFYI(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canClearFYI(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_FYI_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_TAKE_REQUESTED_ACTION, permissionDetails, qualifications);
+	        	
+	 }
+	
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canAcknowledge(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canAcknowledge(Document document, Person user){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_COMPLETE_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_TAKE_REQUESTED_ACTION, permissionDetails, qualifications);
+	        	
+	 }
+	
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canComplete(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canComplete(Document document, Person user ){
+		 KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+     	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+     	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_TAKE_REQUESTED_ACTION, permissionDetails, qualifications);
+	        	
+	 }
+	
+	 /**
+	 * 
+	 * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canDisapprove(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+	 */
+	public boolean canDisapprove(Document document, Person user){
+		 return canApprove(document, user);
+	 }
+	
+	
+    /**
+     * 
+     * @see org.kuali.rice.kns.document.authorization.DocumentAuthorizer#canAnnotate(org.kuali.rice.kns.document.Document, org.kuali.rice.kim.bo.Person)
+     */
+    public boolean canAnnotate(Document document, Person user){
+    	KualiWorkflowDocument workflowDocument = document.getDocumentHeader().getWorkflowDocument();
+		 String documentTypeName = workflowDocument.getDocumentType();
+	     String docStatus = workflowDocument.getRouteHeader().getDocRouteStatus();      	 
+	     String documentNumber = document.getDocumentNumber();
+	     String routeNodeNames = workflowDocument.getCurrentRouteNodeNames();
+		 String nameSpaceCode = "KR-NS";
+		 
+	     AttributeSet permissionDetails = new AttributeSet();
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_DOCUMENT_TYPE_NAME, documentTypeName);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_STATUS_CODE, docStatus);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ROUTE_NODE_NAME, routeNodeNames);
+	     permissionDetails.put(KimConstants.KIM_ATTRIB_ACTION_REQUEST_CODE, KEWConstants.ACTION_REQUEST_ACKNOWLEDGE_REQ);
+	    
+	     AttributeSet qualifications = new AttributeSet();
+    	 qualifications.put(KimConstants.KIM_ATTRIB_DOCUMENT_NUMBER, documentNumber);
+    	
+	     return getIdentityManagementService().isAuthorizedByTemplateName(user.getPrincipalId(), nameSpaceCode, KimConstants.PERMISSION_ADD_NOTE, permissionDetails, qualifications);
+	        	
+    }
+    
+	 
+	 /**
+	  * @return the identityManagementService
+	  */
+	 public static IdentityManagementService getIdentityManagementService() {
+			
+		if (identityManagementService == null ) {
+			identityManagementService = KIMServiceLocator.getIdentityManagementService();
+		}
+		return identityManagementService;
+	}
+
+
+	/**
+	 * @return the documentPresentationController
+	 */
+	public static DocumentPresentationController getDocumentPresentationController() {
+		if (documentPresentationController == null ) {
+			documentPresentationController = KNSServiceLocator.getDocumentPresentationController();
+		}
+		return documentPresentationController;
+	}
+	 
+      
+}
\ No newline at end of file
Index: impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java
===================================================================
--- impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java	(revision 5584)
+++ impl/src/main/java/org/kuali/rice/kns/document/authorization/DocumentAuthorizer.java	(working copy)
@@ -1,88 +1,190 @@
-/*
- * Copyright 2007 The Kuali Foundation.
- * 
- * Licensed under the Educational Community License, Version 1.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- * http://www.opensource.org/licenses/ecl1.php
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.kuali.rice.kns.document.authorization;
-
-import java.util.Map;
-
-import org.kuali.rice.kim.bo.Person;
-import org.kuali.rice.kns.document.Document;
-
-/**
- * The DocumentAuthorizer class associated with a given Document is used to dynamically determine what editing mode and what actions
- * are allowed for a given user on a given document instance.
- * 
- * 
- */
-public interface DocumentAuthorizer {
-    /**
-     * @param document
-     * @param user
-     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
-     *         allowed to take on that document.
-     */
-    public Map getEditMode(Document document, Person user);
-
-    /**
-     * @param document - the document locks are to be established against or by
-     * @param editMode - the editMode returned by the method {@link #getEditMode(Document, Person)}
-     * @param user - the user locks are being established for
-     * @return New map generated by locking logic combined with passed in parameter editMode.  Map contains keys 
-     *         AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently 
-     *         allowed to take on that document.  This may be a modified list of 
-     */
-    public Map establishLocks(Document document, Map editMode, Person user);
-
-    /**
-     * @param document - the document to create the lock against and add the lock to
-     */
-    public void establishWorkflowPessimisticLocking(Document document);
-
-    /**
-     * @param document - document to release locks from
-     */
-    public void releaseWorkflowPessimisticLocking(Document document);
-    
-    /**
-     * @param document
-     * @param user
-     * @return DocumentActionFlags instance indicating which actions are permitted the given user on the given document
-     */
-    public DocumentActionFlags getDocumentActionFlags(Document document, Person user);
-
-    /**
-     * @param documentTypeName
-     * @param user
-     * @return true if the given user is allowed to initiate documents of the given document type
-     */
-    public void canInitiate(String documentTypeName, Person user);
-    
-    /**
-     * @param documentTypeName
-     * @param user
-     * @returns boolean indicating whether a user can copy a document
-     */
-    public boolean canCopy(String documentTypeName, Person user);
-
-    /**
-     * 
-     * @param attachmentTypeName
-     * @param document
-     * @param user
-     * @return
-     */
-    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user);
-}
-
+/*
+ * Copyright 2007 The Kuali Foundation.
+ * 
+ * Licensed under the Educational Community License, Version 1.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ * http://www.opensource.org/licenses/ecl1.php
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.kuali.rice.kns.document.authorization;
+
+import java.util.Map;
+
+import org.kuali.rice.kim.bo.Person;
+import org.kuali.rice.kns.document.Document;
+
+/**
+ * The DocumentAuthorizer class associated with a given Document is used to dynamically determine what editing mode and what actions
+ * are allowed for a given user on a given document instance.
+ * 
+ * 
+ */
+public interface DocumentAuthorizer {
+    /**
+     * @param document
+     * @param user
+     * @return Map with keys AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently
+     *         allowed to take on that document.
+     */
+    public Map getEditMode(Document document, Person user);
+    
+    /**
+     * @param document - the document locks are to be established against or by
+     * @param editMode - the editMode returned by the method {@link #getEditMode(Document, Person)}
+     * @param user - the user locks are being established for
+     * @return New map generated by locking logic combined with passed in parameter editMode.  Map contains keys 
+     *         AuthorizationConstants.EditMode value (String) which indicates what operations the user is currently 
+     *         allowed to take on that document.  This may be a modified list of 
+     */
+    public Map establishLocks(Document document, Map editMode, Person user);
+
+    /**
+     * @param document - the document to create the lock against and add the lock to
+     */
+    public void establishWorkflowPessimisticLocking(Document document);
+
+    /**
+     * @param document - document to release locks from
+     */
+    public void releaseWorkflowPessimisticLocking(Document document);
+    
+    /**
+     * @param document
+     * @param user
+     * @return DocumentActionFlags instance indicating which actions are permitted the given user on the given document
+     */
+    public DocumentActionFlags getDocumentActionFlags(Document document, Person user);
+
+    /**
+     * @param documentTypeName
+     * @param user
+     * @return true if the given user is allowed to initiate documents of the given document type
+     */
+    public void canInitiate(String documentTypeName, Person user);
+    
+    /**
+     * @param documentTypeName
+     * @param user
+     * @returns boolean indicating whether a user can copy a document
+     */
+    public boolean canCopy(String documentTypeName, Person user);
+
+    /**
+     * 
+     * @param attachmentTypeName
+     * @param document
+     * @param user
+     * @return
+     */
+    public boolean canViewAttachment(String attachmentTypeName, Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to open the document
+     */
+    public boolean canOpen(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to edit the document
+     */
+    public boolean canEdit(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to copy the document
+     */
+    public boolean canCopy(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to cancel the document
+     */
+    public boolean canCancel(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to Route the document
+     */
+    public boolean canRoute(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to save the document
+     */
+    public boolean canSave(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to approve the document
+     */
+    public boolean canBlanketApprove(Document document, Person user); 
+    
+    /**
+     * @param document
+     * @param user
+     * @param actionRequestCode
+     * @return true if the given user is allowed to receive ad hoc
+     */
+    public boolean canReceiveAdHoc(Document document, Person user, String actionRequestCode);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to approve the document
+     */
+    public boolean canApprove(Document document, Person user); 
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to clear FYI
+     */
+    public boolean canClearFYI(Document document, Person user);
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to acknowledge
+     */
+    public boolean canAcknowledge(Document document, Person user); 
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to complete the document
+     */
+    public boolean canComplete(Document document, Person user ); 
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to disapprove the document
+     */
+    public boolean canDisapprove(Document document, Person user); 
+    
+    
+    /**
+     * @param document
+     * @param user
+     * @return true if the given user is allowed to annotate the document
+     */
+    public boolean canAnnotate(Document document, Person user); 
+    
+    
+}
+
